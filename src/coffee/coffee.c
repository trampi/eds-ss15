/*****************************************************************************
* Model: coffeeAo.qm
* File:  src\coffee/coffee.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/* @(/3/0) .................................................................*/

#include  "alarm.h"
#include "coffee.h"


extern CoffeeAO l_CoffeeAO;

unsigned char me1s[] = "Set Brew time";
unsigned char me2s[] = "Set Clock";
unsigned char me3s[] = "Pot inside: %u";
unsigned char me4s[] = "Autobrewing: %u";
unsigned char me5s[] = "Start brewing";
unsigned char me6s[] = "Brew strength %u";

static struct Entry menu_entries[] = {
    { GO_SET_BREW_TIME_CLOCK_SIG, &me1s[0], NOTHING },
    { GO_SET_TIME_OF_DAY_SIG, &me2s[0], NOTHING },
    { GO_COFFEE_POT_TOGGLE_SIG, &me3s[0], IS_COFFEE_POT_IN_MACHINE },
    { GO_TIME_BREW_TOGGLE_SIG, &me4s[0], IS_AUTOMATIC_BREW_ACTIVE },
    { GO_START_BREWING_SIG, &me5s[0], NOTHING },
    { GO_SET_BREW_STRENGTH_SIG, &me6s[0], BREW_STRENGTH }
};


/* @(/2/0) .................................................................*/
/* @(/2/0/9) ...............................................................*/
/* @(/2/0/9/0) */
QState CoffeeAO_initial(CoffeeAO * const me, QEvt const * const e) {
    (void)e;               /* avoid compiler warning about unused parameter */
    me->current_time = 0;
    Alarm_init(&me->alarm);      /* the initial transition in the component */
    me->max_menu_index = 6;
    me->current_menu_index = 0;
    return Q_TRAN(&CoffeeAO_menu);
}
/* @(/2/0/9/1) .............................................................*/
QState CoffeeAO_coffeemachine(CoffeeAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/0/9/1/0) */
        case BREW_SIG: {
            printf("testing for coffee pot\n");
            /* @(/2/0/9/1/0/0) */
            if (l_CoffeeAO.is_coffee_pot_in_machine != 0) {
                printf("test for coffee pot ok, starting to brew\n");
                status_ = Q_HANDLED();
            }
            /* @(/2/0/9/1/0/1) */
            else {
                printf("Insert pot before brewing\n");
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/* @(/2/0/9/1/1) ...........................................................*/
QState CoffeeAO_menu(CoffeeAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/0/9/1/1/0) */
        case ADWHEEL_SIG: {
            // calculate current menu entry
            char menu_text[20];
            struct Entry* menu_entry = &menu_entries[me->current_menu_index];
            me->current_menu_index = ((AdEvt*)e)->val * me->max_menu_index / 1024;
            lcd_clear();
            set_cursor(0, 0);
            switch (menu_entry->interpolate_with) {
            case NOTHING:
                strcpy(menu_text, menu_entry->menu_label);
                break;
            case BREW_STRENGTH:
                sprintf(menu_text, menu_entry->menu_label, l_CoffeeAO.current_brew_strength + 1);
                break;
            case IS_COFFEE_POT_IN_MACHINE:
                sprintf(menu_text, menu_entry->menu_label, l_CoffeeAO.is_coffee_pot_in_machine);
                break;
            case IS_AUTOMATIC_BREW_ACTIVE:
                sprintf(menu_text, menu_entry->menu_label, l_CoffeeAO.is_automatic_brew_active);
                break;
            }
            lcd_print(menu_text);

            set_cursor(4, 1);
            sprintf(menu_text, "%02u:%02u:%02u", l_CoffeeAO.alarm.real_current_time.hours, l_CoffeeAO.alarm.real_current_time.minutes, l_CoffeeAO.alarm.real_current_time.seconds);
            lcd_print(menu_text);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/0/9/1/1/1) */
        case INT_SIG: {
            QEvent *menuEvt = Q_NEW(QEvent, menu_entries[me->current_menu_index].signal);
            //QEvent *menuEvt = Q_NEW(QEvent, GO_COFFEE_POT_TOGGLE_SIG);
            QF_INT_ENABLE();
            QActive_postFIFO((QActive *)&l_CoffeeAO, menuEvt);
            QF_INT_DISABLE();

            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/0/9/1/1/2) */
        case GO_COFFEE_POT_TOGGLE_SIG: {
            status_ = Q_TRAN(&CoffeeAO_coffeePotToggle);
            break;
        }
        /* @(/2/0/9/1/1/3) */
        case GO_TIME_BREW_TOGGLE_SIG: {
            status_ = Q_TRAN(&CoffeeAO_timeBrewActivatedToggle);
            break;
        }
        /* @(/2/0/9/1/1/4) */
        case GO_SET_BREW_TIME_CLOCK_SIG: {
            status_ = Q_TRAN(&CoffeeAO_set_brew_h1);
            break;
        }
        /* @(/2/0/9/1/1/5) */
        case GO_SET_TIME_OF_DAY_SIG: {
            status_ = Q_TRAN(&CoffeeAO_set_clock_h1);
            break;
        }
        /* @(/2/0/9/1/1/6) */
        case GO_START_BREWING_SIG: {
            status_ = Q_TRAN(&CoffeeAO_startBrewingNow);
            break;
        }
        /* @(/2/0/9/1/1/7) */
        case GO_SET_BREW_STRENGTH_SIG: {
            status_ = Q_TRAN(&CoffeeAO_setBrewStrength);
            break;
        }
        default: {
            status_ = Q_SUPER(&CoffeeAO_coffeemachine);
            break;
        }
    }
    return status_;
}
/* @(/2/0/9/1/2) ...........................................................*/
QState CoffeeAO_submenu(CoffeeAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/0/9/1/2/0) */
        case GO_BACK_SIG: {
            status_ = Q_TRAN(&CoffeeAO_menu);
            break;
        }
        default: {
            status_ = Q_SUPER(&CoffeeAO_coffeemachine);
            break;
        }
    }
    return status_;
}
/* @(/2/0/9/1/2/1) .........................................................*/
QState CoffeeAO_setBrewStrength(CoffeeAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/0/9/1/2/1) */
        case Q_ENTRY_SIG: {
            lcd_clear();
            set_cursor(0, 0);
            lcd_print("Use AD-Wheel");
            set_cursor(0, 1);
            lcd_print("Use int0 to save");
            printf("Changing brew strength...\n");
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/0/9/1/2/1) */
        case Q_EXIT_SIG: {
            printf("saved brew strength: %u\n", l_CoffeeAO.current_brew_strength);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/0/9/1/2/1/0) */
        case ADWHEEL_SIG: {
            const int led_count = 8;
            int i = 0;
            l_CoffeeAO.current_brew_strength = ((AdEvt*)e)->val * led_count / 1024;
            for(i = 0; i < led_count; i++) {
                if (i <= l_CoffeeAO.current_brew_strength) {
                    LED_On(i);
                } else {
                    LED_Off(i);
                }
            }

            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/0/9/1/2/1/1) */
        case INT_SIG: {
            QActive_postFIFO((QActive *)&l_CoffeeAO, Q_NEW(QEvent, GO_BACK_SIG));
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&CoffeeAO_submenu);
            break;
        }
    }
    return status_;
}
/* @(/2/0/9/1/2/2) .........................................................*/
QState CoffeeAO_startBrewingNow(CoffeeAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/0/9/1/2/2) */
        case Q_ENTRY_SIG: {
            QF_INT_ENABLE();
            printf("Starting to brew\n %i", l_CoffeeAO.i++);
            QActive_postFIFO((QActive *)&l_CoffeeAO, Q_NEW(QEvent, BREW_SIG));
            QActive_postFIFO((QActive *)&l_CoffeeAO, Q_NEW(QEvent, GO_BACK_SIG));
            QF_INT_DISABLE();

            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&CoffeeAO_submenu);
            break;
        }
    }
    return status_;
}
/* @(/2/0/9/1/2/3) .........................................................*/
QState CoffeeAO_timeBrewActivatedToggle(CoffeeAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/0/9/1/2/3) */
        case Q_ENTRY_SIG: {
            l_CoffeeAO.is_automatic_brew_active = l_CoffeeAO.is_automatic_brew_active == 0 ? 1 : 0;
            Alarm_dispatch((QFsm *)&l_CoffeeAO.alarm, Q_NEW(QEvent, ALARM_TOGGLE_SIG));
            QActive_postFIFO((QActive *)&l_CoffeeAO, Q_NEW(QEvent, GO_BACK_SIG));
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/0/9/1/2/3) */
        case Q_EXIT_SIG: {
            printf("toggled automatic brew to: %u\n", l_CoffeeAO.is_automatic_brew_active);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&CoffeeAO_submenu);
            break;
        }
    }
    return status_;
}
/* @(/2/0/9/1/2/4) .........................................................*/
QState CoffeeAO_set_brew_h1(CoffeeAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/0/9/1/2/4) */
        case Q_ENTRY_SIG: {
            lcd_clear();
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/0/9/1/2/4/0) */
        case ADWHEEL_SIG: {
            char clock_message[20];
            int value = ((AdEvt*)e)->val * 3 / 1024;
            HourAndMinute* ham = &l_CoffeeAO.alarm.alarm_time;
            ham->hours = MIN(10*value + ham->hours % 10, 23);
            sprintf(clock_message, "%02u:%02u", ham->hours, ham->minutes);

            set_cursor(0, 0);
            lcd_print(clock_message);
            set_cursor(0, 1);
            lcd_print("^");
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/0/9/1/2/4/1) */
        case INT_SIG: {
            status_ = Q_TRAN(&CoffeeAO_set_brew_h2);
            break;
        }
        default: {
            status_ = Q_SUPER(&CoffeeAO_submenu);
            break;
        }
    }
    return status_;
}
/* @(/2/0/9/1/2/5) .........................................................*/
QState CoffeeAO_set_clock_h1(CoffeeAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/0/9/1/2/5) */
        case Q_ENTRY_SIG: {
            lcd_clear();
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/0/9/1/2/5/0) */
        case ADWHEEL_SIG: {
            char clock_message[20];
            int value = ((AdEvt*)e)->val * 3 / 1024;
            HourAndMinute* ham = &l_CoffeeAO.alarm.current_time;
            ham->hours = MIN(10*value + ham->hours % 10, 23);
            sprintf(clock_message, "%02u:%02u", ham->hours, ham->minutes);

            set_cursor(0, 0);
            lcd_print(clock_message);
            set_cursor(0, 1);
            lcd_print("^");
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/0/9/1/2/5/1) */
        case INT_SIG: {
            status_ = Q_TRAN(&CoffeeAO_set_clock_h2);
            break;
        }
        default: {
            status_ = Q_SUPER(&CoffeeAO_submenu);
            break;
        }
    }
    return status_;
}
/* @(/2/0/9/1/2/6) .........................................................*/
QState CoffeeAO_set_clock_h2(CoffeeAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/0/9/1/2/6) */
        case Q_ENTRY_SIG: {
            lcd_clear();
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/0/9/1/2/6/0) */
        case INT_SIG: {
            status_ = Q_TRAN(&CoffeeAO_set_clock_m1);
            break;
        }
        /* @(/2/0/9/1/2/6/1) */
        case ADWHEEL_SIG: {
            char clock_message[20];
            int value = ((AdEvt*)e)->val * 10 / 1024;
            HourAndMinute* ham = &l_CoffeeAO.alarm.current_time;
            ham->hours = MIN((ham->hours / 10) * 10 + value, 23);
            sprintf(clock_message, "%02u:%02u", ham->hours, ham->minutes);

            set_cursor(0, 0);
            lcd_print(clock_message);
            set_cursor(1, 1);
            lcd_print("^");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&CoffeeAO_submenu);
            break;
        }
    }
    return status_;
}
/* @(/2/0/9/1/2/7) .........................................................*/
QState CoffeeAO_set_clock_m1(CoffeeAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/0/9/1/2/7) */
        case Q_ENTRY_SIG: {
            lcd_clear();
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/0/9/1/2/7/0) */
        case INT_SIG: {
            status_ = Q_TRAN(&CoffeeAO_set_clock_m2);
            break;
        }
        /* @(/2/0/9/1/2/7/1) */
        case ADWHEEL_SIG: {
            char clock_message[20];
            int value = ((AdEvt*)e)->val * 6 / 1024;
            HourAndMinute* ham = &l_CoffeeAO.alarm.current_time;
            ham->minutes = 10*value + ham->minutes % 10;
            sprintf(clock_message, "%02u:%02u", ham->hours, ham->minutes);

            set_cursor(0, 0);
            lcd_print(clock_message);
            set_cursor(3, 1);
            lcd_print("^");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&CoffeeAO_submenu);
            break;
        }
    }
    return status_;
}
/* @(/2/0/9/1/2/8) .........................................................*/
QState CoffeeAO_set_clock_m2(CoffeeAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/0/9/1/2/8) */
        case Q_ENTRY_SIG: {
            lcd_clear();
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/0/9/1/2/8/0) */
        case ADWHEEL_SIG: {
            char clock_message[20];
            int value = ((AdEvt*)e)->val * 10 / 1024;
            HourAndMinute* ham = &l_CoffeeAO.alarm.current_time;
            ham->minutes = (ham->minutes / 10) * 10 + value;
            sprintf(clock_message, "%02u:%02u", ham->hours, ham->minutes);

            set_cursor(0, 0);
            lcd_print(clock_message);
            set_cursor(4, 1);
            lcd_print("^");
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/0/9/1/2/8/1) */
        case INT_SIG: {
            RtcEvt* rtc_evt = Q_NEW(RtcEvt, TIME_SET_SIG);
            rtc_evt->rtc.hours = l_CoffeeAO.alarm.current_time.hours;
            rtc_evt->rtc.minutes = l_CoffeeAO.alarm.current_time.minutes;

            Alarm_dispatch((QFsm *)&l_CoffeeAO.alarm, (QEvt *) rtc_evt);
            QActive_postFIFO((QActive *)&l_CoffeeAO, Q_NEW(QEvent, GO_BACK_SIG));

            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&CoffeeAO_submenu);
            break;
        }
    }
    return status_;
}
/* @(/2/0/9/1/2/9) .........................................................*/
QState CoffeeAO_set_brew_h2(CoffeeAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/0/9/1/2/9) */
        case Q_ENTRY_SIG: {
            lcd_clear();
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/0/9/1/2/9/0) */
        case INT_SIG: {
            status_ = Q_TRAN(&CoffeeAO_set_brew_m1);
            break;
        }
        /* @(/2/0/9/1/2/9/1) */
        case ADWHEEL_SIG: {
            char clock_message[20];
            int value = ((AdEvt*)e)->val * 10 / 1024;
            HourAndMinute* ham = &l_CoffeeAO.alarm.alarm_time;
            ham->hours = MIN((ham->hours / 10) * 10 + value, 23);
            sprintf(clock_message, "%02u:%02u", ham->hours, ham->minutes);

            set_cursor(0, 0);
            lcd_print(clock_message);
            set_cursor(1, 1);
            lcd_print("^");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&CoffeeAO_submenu);
            break;
        }
    }
    return status_;
}
/* @(/2/0/9/1/2/10) ........................................................*/
QState CoffeeAO_set_brew_m1(CoffeeAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/0/9/1/2/10) */
        case Q_ENTRY_SIG: {
            lcd_clear();
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/0/9/1/2/10/0) */
        case INT_SIG: {
            status_ = Q_TRAN(&CoffeeAO_set_brew_m2);
            break;
        }
        /* @(/2/0/9/1/2/10/1) */
        case ADWHEEL_SIG: {
            char clock_message[20];
            int value = ((AdEvt*)e)->val * 6 / 1024;
            HourAndMinute* ham = &l_CoffeeAO.alarm.alarm_time;
            ham->minutes = 10*value + ham->minutes % 10;
            sprintf(clock_message, "%02u:%02u", ham->hours, ham->minutes);

            set_cursor(0, 0);
            lcd_print(clock_message);
            set_cursor(3, 1);
            lcd_print("^");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&CoffeeAO_submenu);
            break;
        }
    }
    return status_;
}
/* @(/2/0/9/1/2/11) ........................................................*/
QState CoffeeAO_set_brew_m2(CoffeeAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/0/9/1/2/11) */
        case Q_ENTRY_SIG: {
            lcd_clear();
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/0/9/1/2/11/0) */
        case ADWHEEL_SIG: {
            char clock_message[20];
            int value = ((AdEvt*)e)->val * 10 / 1024;
            HourAndMinute* ham = &l_CoffeeAO.alarm.alarm_time;
            ham->minutes = MIN((ham->minutes / 10) * 10 + value, 59);
            sprintf(clock_message, "%02u:%02u", ham->hours, ham->minutes);

            set_cursor(0, 0);
            lcd_print(clock_message);
            set_cursor(4, 1);
            lcd_print("^");
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/0/9/1/2/11/1) */
        case INT_SIG: {
            QActive_postFIFO((QActive *)&l_CoffeeAO, Q_NEW(QEvent, GO_BACK_SIG));
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&CoffeeAO_submenu);
            break;
        }
    }
    return status_;
}
/* @(/2/0/9/1/2/12) ........................................................*/
QState CoffeeAO_coffeePotToggle(CoffeeAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/0/9/1/2/12) */
        case Q_ENTRY_SIG: {
            l_CoffeeAO.is_coffee_pot_in_machine = l_CoffeeAO.is_coffee_pot_in_machine == 0 ? 1 : 0;
            QActive_postFIFO((QActive *)&l_CoffeeAO, Q_NEW(QEvent, GO_BACK_SIG));
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/0/9/1/2/12) */
        case Q_EXIT_SIG: {
            printf("toggled coffee pot in machine to: %u\n", l_CoffeeAO.is_coffee_pot_in_machine);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&CoffeeAO_submenu);
            break;
        }
    }
    return status_;
}

/* @(/2/2) .................................................................*/
void CoffeeAO_ctor(CoffeeAO* me) {
    QActive_ctor(&me->super, (QStateHandler)&CoffeeAO_initial);
    Alarm_ctor(&me->alarm);                /* orthogonal component ctor */
    QTimeEvt_ctor(&me->timeEvt, TICK_SIG);       /* private time event ctor */
}
