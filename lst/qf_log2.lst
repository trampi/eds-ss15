L 1 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\qf\source\qf_log2.c"
N/**
N* \file
N* \brief ::QF_log2Lkup[] definition.
N* \ingroup qf
N* \cond
N******************************************************************************
N* Product: QF/C
N* Last updated for version 5.3.0
N* Last updated on  2014-04-09
N*
N*                    Q u a n t u m     L e a P s
N*                    ---------------------------
N*                    innovating embedded systems
N*
N* Copyright (C) Quantum Leaps, www.state-machine.com.
N*
N* This program is open source software: you can redistribute it and/or
N* modify it under the terms of the GNU General Public License as published
N* by the Free Software Foundation, either version 3 of the License, or
N* (at your option) any later version.
N*
N* Alternatively, this program may be distributed and modified under the
N* terms of Quantum Leaps commercial licenses, which expressly supersede
N* the GNU General Public License and are specifically designed for
N* licensees interested in retaining the proprietary status of their code.
N*
N* This program is distributed in the hope that it will be useful,
N* but WITHOUT ANY WARRANTY; without even the implied warranty of
N* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
N* GNU General Public License for more details.
N*
N* You should have received a copy of the GNU General Public License
N* along with this program. If not, see <http://www.gnu.org/licenses/>.
N*
N* Contact information:
N* Web:   www.state-machine.com
N* Email: info@state-machine.com
N******************************************************************************
N* \endcond
N*/
N#define QP_IMPL           /* this is QP implementation */
N#include "qf_port.h"      /* QF port */
L 1 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil\qf_port.h" 1
N/* Product: Product: QP/Cs
N* Last Updated for Version: 5.1.1
N* Date of the Last Update:  Nov 17, 2013
N* Ported to dresden elektronic deRFarm7 Gateway - Atmel AT91SAM7X-512 MCPU
N* Keil  ARM - µLink Environment */
N
N#ifndef qf_port_h
N#define qf_port_h
N
N                 /* The maximum number of active objects in the application */
N#define QF_MAX_ACTIVE               8
N
N#define QF_MAX_TICK_RATE            2
N
N
N
N
Nvoid __swi(0xFE)  disable_irq (void);
Nvoid __swi(0xFF)  enable_irq (void);
N
N#ifdef QK
S#define QF_INT_LOCK(dummy)        disable_irq();    	
S#define QF_INT_UNLOCK(dummy)      enable_irq();  
S
S
N#else
N#define QF_INT_LOCK(dummy)         	__disable_irq();
N#define QF_INT_UNLOCK(dummy)        __enable_irq();
N
N#endif                                            /* QF interrupt disable/enable */
N#define QF_INT_DISABLE()            (__disable_irq())
N#define QF_INT_ENABLE()             (__enable_irq())
N
N
N
N	
N
N
N                                          /* QF critical section entry/exit */
N/* QF_CRIT_STAT_TYPE not defined: unconditional interrupt unlocking" policy */
N#define QF_CRIT_ENTRY(dummy)       disable_irq();
N#define QF_CRIT_EXIT(dummy)        enable_irq(); 
N
N
N
N
N#include "qep_port.h"                                           /* QEP port */
L 1 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil\qep_port.h" 1
N/* Product: Product: QP/Cs
N* Last Updated for Version: 5.1.0
N* Date of the Last Update:  Nov 18, 2013
N* Ported to dresden elektronic deRFarm7 Gateway - Atmel AT91SAM7X-512 MCPU
N* Keil  ARM - µLink Environment */
N
N#ifndef qep_port_h
N#define qep_port_h
N
N#include <stdint.h>        /* exact-width integers, WG14/N843 C99, 7.18.1.1 */
L 1 "C:\Keil_v5\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 180721 $
N * Checkin $Date: 2013-06-24 09:41:57 +0100 (Mon, 24 Jun 2013) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5040049
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 11 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil\qep_port.h" 2
N#include <stdbool.h>
L 1 "C:\Keil_v5\ARM\ARMCC\bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision: 177844 $
N * Checkin $Date: 2012-11-21 11:51:12 +0000 (Wed, 21 Nov 2012) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5040049
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 12 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil\qep_port.h" 2
N
N#include "qep.h"               /* QEP platform-independent public interface */
L 1 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qep.h" 1
N/**
N* \file
N* \brief Public QEP/C interface.
N* \ingroup qep
N* \cond
N******************************************************************************
N* Product: QEP/C
N* Last updated for version 5.3.1
N* Last updated on  2014-09-18
N*
N*                    Q u a n t u m     L e a P s
N*                    ---------------------------
N*                    innovating embedded systems
N*
N* Copyright (C) Quantum Leaps, www.state-machine.com.
N*
N* This program is open source software: you can redistribute it and/or
N* modify it under the terms of the GNU General Public License as published
N* by the Free Software Foundation, either version 3 of the License, or
N* (at your option) any later version.
N*
N* Alternatively, this program may be distributed and modified under the
N* terms of Quantum Leaps commercial licenses, which expressly supersede
N* the GNU General Public License and are specifically designed for
N* licensees interested in retaining the proprietary status of their code.
N*
N* This program is distributed in the hope that it will be useful,
N* but WITHOUT ANY WARRANTY; without even the implied warranty of
N* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
N* GNU General Public License for more details.
N*
N* You should have received a copy of the GNU General Public License
N* along with this program. If not, see <http://www.gnu.org/licenses/>.
N*
N* Contact information:
N* Web:   www.state-machine.com
N* Email: info@state-machine.com
N******************************************************************************
N* \endcond
N*/
N#ifndef qep_h
N#define qep_h
N
N/****************************************************************************/
N/*! The current QP/C version number */
N/**
N* \description
N* version of the QP/C framework as a decimal constant XYZ, where X is a
N* 1-digit major version number, Y is a 1-digit minor version number, and Z
N* is a 1-digit release number.
N*/
N#define QP_VERSION      531
N
N/*! The current QP version string */
N#define QP_VERSION_STR  "5.3.1"
N
N/*! Tamperproof current QP release (5.3.1) and date (14-09-18) */
N#define QP_RELEASE      0xAC019C8CU
N
N/****************************************************************************/
N#ifndef Q_SIGNAL_SIZE
N
N    /*! The size (in bytes) of the signal of an event. Valid values:
N    * 1, 2, or 4; default 1 */
N    /**
N    * \description
N    * This macro can be defined in the QEP port file (qep_port.h) to
N    * configure the ::QSignal type. When the macro is not defined, the
N    * default of 2 bytes is applied.
N    */
N    #define Q_SIGNAL_SIZE 2
N#endif
N#if (Q_SIGNAL_SIZE == 1)
X#if (2 == 1)
S    typedef uint8_t QSignal;
N#elif (Q_SIGNAL_SIZE == 2)
X#elif (2 == 2)
N    /*! QSignal represents the signal of an event. */
N    /**
N    * \description
N    * The relationship between an event and a signal is as follows. A signal
N    * in UML is the specification of an asynchronous stimulus that triggers
N    * reactions, and as such is an essential part of an event.
N    * (The signal conveys the type of the occurrence-what happened?)
N    * However, an event can also contain additional quantitative information
N    * about the occurrence in form of event parameters.
N    */
N    typedef uint16_t QSignal;
N#elif (Q_SIGNAL_SIZE == 4)
S    typedef uint32_t QSignal;
S#else
S    #error "Q_SIGNAL_SIZE defined incorrectly, expected 1, 2, or 4"
N#endif
N
N/****************************************************************************/
N#ifndef Q_ROM
N    /*! Macro to specify compiler-specific directive for placing a
N    * constant object in ROM. */
N    /**
N    * \description
N    * Many compilers for 8-bit Harvard-architecture MCUs provide non-standard
N    * extensions to support placement of objects in different memories.
N    * In order to conserve the precious RAM, QP uses the Q_ROM macro for
N    * all constant objects that can be allocated in ROM.
N    *
N    * \note
N    * To override the empty definition of Q_ROM, you need to define the
N    * Q_ROM macro in the qep_port.h header file. Some examples of valid
N    * Q_ROM macro definitions are: __code (IAR 8051 compiler), code (Keil
N    * Cx51 compiler), PROGMEM (gcc for AVR), __flash (IAR for AVR).
N    */
N    #define Q_ROM
N#endif
N#ifndef Q_ROM_BYTE
N    /*! Macro to access a byte allocated in ROM */
N    /**
N    * \description
N    * Some compilers for Harvard-architecture MCUs, such as gcc for AVR, do
N    * not generate correct code for accessing data allocated in the program
N    * space (ROM). The workaround for such compilers is to explicitly add
N    * assembly code to access each data element allocated in the program
N    * space. The macro Q_ROM_BYTE() retrieves a byte from the given ROM
N    * address. If the macro is left undefined, the default definition simply
N    * returns the argument.
N    *
N    * \arguments
N    * \arg[in] \c rom_var_ address of the ROM-based byte variable
N    * \returns the byte value from ROM
N    *
N    * \note The Q_ROM_BYTE() macro should be re-defined for compilers that
N    * cannot handle correctly data placed in ROM (such as the gcc for AVR).
N    */
N    #define Q_ROM_BYTE(rom_var_)   (rom_var_)
N#endif
N
N/****************************************************************************/
N/* typedefs for basic numerical types; MISRA-C 2004 rule 6.3(req). */
N
N/*! typedef for character strings. */
N/**
N* \description
N* This typedef specifies character type for exclusive use in character
N* strings. Use of this type, rather than plain 'char', is in compliance
N* with the MISRA-C 2004 Rules 6.1(req), 6.3(adv).
N*/
Ntypedef char char_t;
N
N/*! typedef for line numbers in assertions and return from QF_run() */
Ntypedef int int_t;
N
N/*! typedef for enumerations used for event signals */
Ntypedef int enum_t;
N
N/*! IEEE 754 32-bit floating point number, MISRA-C 2004 rule 6.3(req) */
N/**
N* \note QP does not use floating-point types anywhere in the internal
N* implementation, except in QS software tracing, where utilities for
N* output of floating-point numbers are provided for application-level
N* trace records.
N*/
Ntypedef float float32_t;
N
N/*! IEEE 754 64-bit floating point number, MISRA-C 2004 rule 6.3(req) */
N/**
N* \note QP does not use floating-point types anywhere in the internal
N* implementation, except in QS software tracing, where utilities for
N* output of floating-point numbers are provided for application-level
N* trace records.
N*/
Ntypedef double float64_t;
N
N/****************************************************************************/
N/*! Event structure. */
N/**
N* \description
N* QEvt represents events without parameters and serves as the base structure
N* for derivation of events with parameters.
N*
N* \usage
N* The following example illustrates how to add an event parameter by
N* derivation of the QEvt structure. Please note that the QEvt member
N* super_ is defined as the FIRST member of the derived struct.
N* \include qep_qevt.c
N*
N* \sa \ref derivation
N*/
Ntypedef struct {
N    QSignal sig;              /*!< signal of the event instance */
N    uint8_t poolId_;          /*!< pool ID (0 for static event) */
N    uint8_t volatile refCtr_; /*!< reference counter */
N} QEvt;
N
N#ifdef Q_EVT_CTOR /* Shall the constructor for the QEvt class be provided? */
S
S/*! Custom event constructor. */
SQEvt *QEvt_ctor(QEvt * const me, enum_t const sig);
S
N#endif
N
N/****************************************************************************/
N/*! Perform upcast from a subclass of ::QMsm to the base class ::QMsm */
N/**
N* \description
N* Upcasting from a subclass to superclass is a very frequent and __safe__
N* operation in object-oriented programming and object-oriented languages
N* (such as C++) perform such upcasting automatically. However, OOP is
N* implemented in C just as a set of coding conventions (see \ref derivation),
N* and the C compiler does not "know" that certain types are related by
N* inheritance. Therefore for C, the upcast must be performed explicitly.
N* Unfortunately, pointer casting violates the advisory MISRA-C 2004 rule 11.4
N* "cast pointer to pointer". This macro encapsulates this deviation and
N* provides a descriptive name for the reason of this cast.
N*/
N#define Q_MSM_UPCAST(ptr_) ((QMsm *)(ptr_))
N
N/*! Perform downcast of an event onto a subclass of QEvt \a class_ */
N/**
N* \description
N* QEvt represents events without parameters and serves as the base structure
N* This macro encapsulates the downcast of QEvt pointers, which violates
N* MISRA-C 2004 rule 11.4(advisory). This macro helps to localize this
N* deviation.
N*/
N#define Q_EVT_CAST(class_) ((class_ const *)e)
N
N/*! Helper macro to calculate static dimension of a 1-dim \a array_ */
N#define Q_DIM(array_) (sizeof(array_) / sizeof((array_)[0]))
N
N/*! Perform cast from unsigned integer \a uint_ to pointer
N* of type \a type_. */
N/**
N* \description
N* This macro encapsulates the cast to (type_ *), which QP ports or
N* application might use to access embedded hardware registers.
N* Such uses can trigger PC-Lint "Note 923: cast from int to pointer" and
N* this macro helps to encapsulate this deviation.
N*/
N#define Q_UINT2PTR_CAST(type_, uint_)  ((type_ *)(uint_))
N
N/****************************************************************************/
N/*! typedef of the return type from a state/action-handler function. */
Ntypedef uint_fast8_t QState;
N
N/*! Pointer to a state-handler function. */
Ntypedef QState (*QStateHandler)(void * const me, QEvt const * const e);
N
N/*! Pointer to an action-handler function. */
Ntypedef QState (*QActionHandler)(void * const me);
N
N/*! Perform cast to ::QStateHandler. */
N/**
N* \description
N* This macro encapsulates the cast of a specific state handler function
N* pointer to QStateHandler, which violates MISRA-C 2004 rule 11.4(advisory).
N* This macro helps to localize this deviation.
N*
N* \usage
N* \include qep_qhsm_ctor.c
N*/
N#define Q_STATE_CAST(handler_)  ((QStateHandler)(handler_))
N
N/*! Perform cast to QActionHandler. */
N/**
N* \description
N* This macro encapsulates the cast of a specific action handler function
N* pointer to ::QActionHandler, which violates MISRA-C 2004 rule 11.4(adv).
N* This macro helps to localize this deviation.
N*/
N#define Q_ACTION_CAST(action_)  ((QActionHandler)(action_))
N
N/*! State object for the ::QMsm class (Meta State Machine). */
N/**
N* \description
N* This class groups together the attributes of a ::QMsm state, such as the
N* parent state (state nesting), the associated state handler function and
N* the exit action handler function. These attributes are used inside the
N* QMsm_dispatch() and QMsm_init() functions.
N*
N* \attention
N* The ::QMState class is only intended for the QM code generator and should
N* not be used in hand-crafted code.
N*/
Ntypedef struct QMState {
N    struct QMState const *superstate;   /*!< superstate of this state */
N    QStateHandler  const stateHandler;  /*!< state handler function */
N    QActionHandler const entryAction;   /*!< entry action handler function */
N    QActionHandler const exitAction;    /*!< exit action handler function */
N    QActionHandler const initAction;    /*!< init action handler function */
N} QMState;
N
N/*! Transition-Action Table for the Meta State Machine. */
Ntypedef struct {
N    QMState        const *target;
N    QActionHandler const act[1];
N} QMTranActTable;
N
N/*! Attribute of for the ::QMsm class (Meta State Machine). */
N/**
N* \description
N* This union represents possible values stored in the 'state' and 'temp'
N* attributes of the ::QMsm class.
N*/
Nunion QMAttr {
N    QMState        const *obj;   /*!< pointer to QMState object */
N    QMTranActTable const *tatbl; /*!< transition-action table */
N    QStateHandler  fun;          /*!< pointer to a state-handler function */
N    QActionHandler act;          /*!< pointer to an action-handler function */
N};
N
N
N/****************************************************************************/
N/*! virtual table for the ::QMsm class. */
Ntypedef struct QMsmVtbl QMsmVtbl;
N
N/*! Meta State Machine. */
N/**
N* \description
N* QMsm represents the most fundamental State Machine in QP. The application-
N* level state machines derived directly from QMsm typically require the use
N* of the QM modeling tool, but are the fastest and need the least run-time
N* support (the smallest event-processor taking up the least code space).\n
N* \n
N* QMsm is also the base class for the QFsm and QHsm state machines, which
N* can be coded and maintained by hand (as well as by QM), but aren't as fast
N* and require significantly more run-time code (0.5-1KB) to execute.
N*
N* \note QMsm is not intended to be instantiated directly, but rather serves
N* as the base structure for derivation of state machines in the application
N* code.
N*
N* \usage
N* The following example illustrates how to derive a state machine structure
N* from QMsm. Please note that the QMsm member 'super' is defined as the
N* _first_ member of the derived struct.
N* \include qep_qmsm.c
N*
N* \sa \ref derivation
N*/
Ntypedef struct {
N    QMsmVtbl const *vptr; /*!< virtual pointer */
N    union QMAttr state;   /*!< current active state (state-variable) */
N    union QMAttr temp;    /*!< temporary: tran. chain, target state, etc. */
N} QMsm;
N
N/*! Virtual table for the ::QMsm class. */
Nstruct QMsmVtbl {
N    /*! Triggers the top-most initial transition in a SM. */
N    void (*init)(QMsm * const me, QEvt const * const e);
N
N    /*! Dispatches an event to a SM. */
N    void (*dispatch)(QMsm * const me, QEvt const * const e);
N};
N
N/*! Protected "constructor" of a ::QMsm */
Nvoid QMsm_ctor(QMsm * const me, QStateHandler initial);
N
N/*! Obtain the current active state from a MSM (read only). */
N#define QMsm_stateObj(me_) (Q_MSM_UPCAST(me_)->state.obj)
N
N/*! Polymorphically executes the top-most initial transition in a SM. */
N/**
N* \arguments
N* \arg[in,out] \c me_ pointer (see \ref derivation)
N* \arg[in]     \c e_  constant pointer the ::QEvt or a class derived from
N*                     ::QEvt (see \ref derivation)
N* \note Must be called only ONCE after the SM "constructor".
N*
N* \usage
N* The following example illustrates how to initialize a SM, and dispatch
N* events to it:
N* \include qep_qmsm_use.c
N*/
N#define QMSM_INIT(me_, e_) ((*(me_)->vptr->init)((me_), (e_)))
N
N/*! Implementation of the top-most initial transition in ::QMsm. */
Nvoid QMsm_init_(QMsm * const me, QEvt const * const e);
N
N/*! Polymorphically dispatches an event to a SM. */
N/**
N* \description
N* Processes one event at a time in Run-to-Completion fashion.
N*
N* \arguments
N* \arg[in,out] \c me_ pointer (see \ref derivation)
N* \arg[in]     \c e_  constant pointer the ::QEvt or a structure derived from
N*                     ::QEvt (see \ref derivation)
N* \note Must be called after the "constructor" and after QMSM_INIT().
N*/
N#define QMSM_DISPATCH(me_, e_) ((*(me_)->vptr->dispatch)((me_), (e_)))
N
N/*! Implementation of disparching events to QMsm. */
Nvoid QMsm_dispatch_(QMsm * const me, QEvt const * const e);
N
N/*! Internal helper function to exectue a transition-action table. */
NQState QMsm_execTatbl_(QMsm * const me, QMTranActTable const *tatbl);
N
N/*! Tests if a given state is part of the current active state
N* configuration in a MSM.
N*/
Nbool QMsm_isInState(QMsm * const me, QMState const * const state);
X_Bool QMsm_isInState(QMsm * const me, QMState const * const state);
N
N/****************************************************************************/
N/*! Hierarchical State Machine. */
N/**
N* \description
N* QHsm represents a Hierarchical State Machine (HSM) with full support for
N* hierarchical nesting of states, entry/exit actions, and initial transitions
N* in any composite state. QHsm inherits QMsm "as is" without adding new
N* attributes, so it is typedef'ed as QMsm.
N*
N* \note QHsm is not intended to be instantiated directly, but rather serves
N* as the base structure for derivation of state machines in the application
N* code.
N*
N* \usage
N* The following example illustrates how to derive a state machine structure
N* from QHsm. Please note that the QHsm member super is defined as the FIRST
N* member of the derived struct.
N* \include qep_qhsm.c
N*/
Ntypedef QMsm QHsm;
N
N/* public methods */
N
N/*! protected "constructor" of a HSM. */
Nvoid QHsm_ctor(QHsm * const me, QStateHandler initial);
N
N/*! Obtain the current active state from a HSM (read only). */
N/**
N* \arguments
N* \arg[in] \c me_ pointer (see \ref derivation)
N* \returns the current active state of a HSM
N*/
N#define QHsm_state(me_) (Q_STATE_CAST(Q_MSM_UPCAST(me_)->state.fun))
N
N/*! Implementation of the top-most initial transition in QHsm.
N*/
Nvoid QHsm_init_(QHsm * const me, QEvt const * const e);
N
N/*! Implementation of dispatching events to QHsm.
N*/
Nvoid QHsm_dispatch_(QHsm * const me, QEvt const * const e);
N
N/*! Tests if a given state is part of the current active state
N* configuration in a HSM.
N*/
Nbool QHsm_isIn(QHsm * const me, QStateHandler const state);
X_Bool QHsm_isIn(QHsm * const me, QStateHandler const state);
N
N/* protected methods */
N
N/*! the top-state. */
NQState QHsm_top(void const * const me, QEvt const * const e);
N
N
N/****************************************************************************/
N/*! Non-hierarchical Finite State Machine */
N/**
N* \description
N* QFsm represents a traditional non-hierarchical Finite State Machine (FSM)
N* without state hierarchy, but with entry/exit actions. QFsm inherits QMsm
N* "as is" without adding new attributes, so it is typedef'ed as QMsm.
N*
N* \note QFsm is not intended to be instantiated directly, but rather serves
N* as the base structure for derivation of state machines in the application
N* code.
N*
N* \usage
N* The following example illustrates how to derive a state machine structure
N* from QFsm. Please note that the QFsm member super is defined as the FIRST
N* member of the derived struct.
N* \include qep_qfsm.c
N*/
Ntypedef QMsm QFsm;
N
N/*! Protected "constructor" of a FSM. */
Nvoid QFsm_ctor(QFsm * const me, QStateHandler initial);
N
N/*! Implementation of the top-most initial transition in QFsm. */
Nvoid QFsm_init_(QFsm * const me, QEvt const * const e);
N
N/*! Implementation of dispatching events to QFsm. */
Nvoid QFsm_dispatch_(QFsm * const me, QEvt const * const e);
N
N
N/****************************************************************************/
N/*! obtain the current QEP version number string */
N/**
N* \description
N* version of QEP as a constant 5-character string of the form X.Y.Z,
N* where X is a 1-digit major version number, Y is a 1-digit minor
N* version number, and Z is a 1-digit release number.
N*/
N#define QEP_getVersion() (QP_VERSION_STR)
N
N/****************************************************************************/
N/*! All possible values returned from state/action handlers */
N/**
N* \note The order matters for algorithmic correctness.
N*/
Nenum {
N    /* unhandled and need to "bubble up" */
N    Q_RET_SUPER,     /*!< event passed to superstate to handle */
N    Q_RET_SUPER_SUB, /*!< event passed to submachine superstate */
N    Q_RET_UNHANDLED, /*!< event unhandled due to a guard */
N
N    /* handled and do not need to "bubble up" */
N    Q_RET_HANDLED,   /*!< event handled (internal transition) */
N    Q_RET_IGNORED,   /*!< event silently ignored (bubbled up to top) */
N
N    /* entry/exit */
N    Q_RET_ENTRY,     /*!< state entry action executed */
N    Q_RET_EXIT,      /*!< state exit  action executed */
N
N    /* no side effects */
N    Q_RET_NULL,      /*!< return value without any effect */
N
N    /* transitions need to execute transition-action table in QMsm */
N    Q_RET_TRAN,      /*!< event handled (regular transition) */
N    Q_RET_TRAN_INIT, /*!< initial transition in a state or submachine */
N    Q_RET_TRAN_HIST, /*!< event handled (transition to history) */
N    Q_RET_TRAN_EP,   /*!< entry-point transition into a submachine */
N    Q_RET_TRAN_XP    /*!< exit-point transition out of a submachine */
N};
N
N#ifdef Q_SPY
S    /*! Macro to call in a QM action-handler when it executes
S    * an entry action. Applicable only to QMSMs.
S    */
S    #define QM_ENTRY(state_) \
S        ((Q_MSM_UPCAST(me))->temp.obj = (state_), (QState)Q_RET_ENTRY)
X    #define QM_ENTRY(state_)         ((Q_MSM_UPCAST(me))->temp.obj = (state_), (QState)Q_RET_ENTRY)
S
S    /*! Macro to call in a QM action-handler when it executes
S    * an exit action. Applicable only to QMSMs.
S    */
S    #define QM_EXIT(state_) \
S        ((Q_MSM_UPCAST(me))->temp.obj = (state_), (QState)Q_RET_EXIT)
X    #define QM_EXIT(state_)         ((Q_MSM_UPCAST(me))->temp.obj = (state_), (QState)Q_RET_EXIT)
S
N#else
N    #define QM_ENTRY(dummy) ((QState)Q_RET_ENTRY)
N
N    #define QM_EXIT(dummy)  ((QState)Q_RET_EXIT)
N
N#endif /* Q_SPY */
N
N/*! Macro to call in a QM state-handler when it executes a regular
N* transition. Applicable only to QMSMs.
N*/
N#define QM_TRAN(tatbl_) \
N    ((Q_MSM_UPCAST(me))->temp.tatbl = (QMTranActTable const *)(tatbl_), \
N        (QState)Q_RET_TRAN)
X#define QM_TRAN(tatbl_)     ((Q_MSM_UPCAST(me))->temp.tatbl = (QMTranActTable const *)(tatbl_),         (QState)Q_RET_TRAN)
N
N/*! Macro to call in a QM state-handler when it executes an initial
N* transition. Applicable only to QMSMs.
N*/
N#define QM_TRAN_INIT(tatbl_) \
N    ((Q_MSM_UPCAST(me))->temp.tatbl = (QMTranActTable const *)(tatbl_), \
N        (QState)Q_RET_TRAN_INIT)
X#define QM_TRAN_INIT(tatbl_)     ((Q_MSM_UPCAST(me))->temp.tatbl = (QMTranActTable const *)(tatbl_),         (QState)Q_RET_TRAN_INIT)
N
N/*! Macro to call in a QM state-handler when it executes a transition
N* to history. Applicable only to QMSMs.
N*/
N#define QM_TRAN_HIST(history_, tatbl_) \
N    ((((Q_MSM_UPCAST(me))->state.obj = (history_)), \
N      ((Q_MSM_UPCAST(me))->temp.tatbl = (QMTranActTable const *)(tatbl_))), \
N       (QState)Q_RET_TRAN_HIST)
X#define QM_TRAN_HIST(history_, tatbl_)     ((((Q_MSM_UPCAST(me))->state.obj = (history_)),       ((Q_MSM_UPCAST(me))->temp.tatbl = (QMTranActTable const *)(tatbl_))),        (QState)Q_RET_TRAN_HIST)
N
N/*! Macro to call in a QM state-handler when it executes a transition
N* to the submachine via an entry point.
N*/
N#define QM_TRAN_EP(tatbl_) \
N    ((Q_MSM_UPCAST(me))->temp.tatbl = (QMTranActTable const *)(tatbl_), \
N        (QState)Q_RET_TRAN_EP)
X#define QM_TRAN_EP(tatbl_)     ((Q_MSM_UPCAST(me))->temp.tatbl = (QMTranActTable const *)(tatbl_),         (QState)Q_RET_TRAN_EP)
N
N/*! Macro to call in a QM state-handler when it executes a transition
N* to exit point. Applicable only to QMSMs.
N*/
N#define QM_TRAN_XP(xp_, tatbl_) \
N    ((((Q_MSM_UPCAST(me))->state.act = (xp_)), \
N        ((Q_MSM_UPCAST(me))->temp.tatbl = (QMTranActTable const *)(tatbl_))),\
N        (QState)Q_RET_TRAN_XP)
X#define QM_TRAN_XP(xp_, tatbl_)     ((((Q_MSM_UPCAST(me))->state.act = (xp_)),         ((Q_MSM_UPCAST(me))->temp.tatbl = (QMTranActTable const *)(tatbl_))),        (QState)Q_RET_TRAN_XP)
N
N/*! Macro to call in a QM state-handler when it handled an event.
N* Applicable only to QMSMs.
N*/
N#define QM_HANDLED()     ((QState)Q_RET_HANDLED)
N
N/*! Macro to call in a QM state-handler when when it attempts to
N* handle an event but a guard condition evaluates to 'false' and there is
N* no other explicit way of handling the event. Applicable only to QMSMs.
N*/
N#define QM_UNHANDLED()   ((QState)Q_RET_UNHANDLED)
N
N/*! Macro to call in a QM state-handler when it designates the
N* superstate to handle an event. Applicable only to QMSMs.
N*/
N#define QM_SUPER()       ((QState)Q_RET_SUPER)
N
N/*! Macro to call in a QM submachine-handler when it designates the
N* host state to handle an event. Applicable only to QMSMs.
N*/
N#define QM_SUPER_SUB(host_) \
N    ((Q_MSM_UPCAST(me))->temp.obj = (host_), (QState)Q_RET_SUPER_SUB)
X#define QM_SUPER_SUB(host_)     ((Q_MSM_UPCAST(me))->temp.obj = (host_), (QState)Q_RET_SUPER_SUB)
N
N
N/*! Macro to call in a state-handler when it executes a regular
N* or and initial transition. Applicable to both HSMs and FSMs.
N* \include qep_qtran.c
N*/
N#define Q_TRAN(target_)  \
N    ((Q_MSM_UPCAST(me))->temp.fun = Q_STATE_CAST(target_), (QState)Q_RET_TRAN)
X#define Q_TRAN(target_)      ((Q_MSM_UPCAST(me))->temp.fun = Q_STATE_CAST(target_), (QState)Q_RET_TRAN)
N
N/*! Macro to call in a state-handler when it executes a transition
N* to history. Applicable only to HSMs.
N*
N* \usage
N* \include qep_qhist.c
N*/
N#define Q_TRAN_HIST(hist_)  \
N    ((Q_MSM_UPCAST(me))->temp.fun = (hist_), (QState)Q_RET_TRAN_HIST)
X#define Q_TRAN_HIST(hist_)      ((Q_MSM_UPCAST(me))->temp.fun = (hist_), (QState)Q_RET_TRAN_HIST)
N
N/*! Macro to call in a state-handler when it designates the
N* superstate of a given state. Applicable only to HSMs.
N*
N* \usage
N* \include qep_qtran.c
N*/
N#define Q_SUPER(super_)  \
N    ((Q_MSM_UPCAST(me))->temp.fun = Q_STATE_CAST(super_), (QState)Q_RET_SUPER)
X#define Q_SUPER(super_)      ((Q_MSM_UPCAST(me))->temp.fun = Q_STATE_CAST(super_), (QState)Q_RET_SUPER)
N
N/*! Macro to call in a state-handler when it handles an event.
N*  Applicable to both HSMs and FSMs.
N*/
N#define Q_HANDLED()      ((QState)Q_RET_HANDLED)
N
N/*! Macro to call in a state-handler when it attempts to handle
N* an event but a guard condition evaluates to 'false' and there is no other
N* explicit way of handling the event. Applicable only to HSMs.
N*/
N#define Q_UNHANDLED()    ((QState)Q_RET_UNHANDLED)
N
N/*! Macro to call in a non-hierarchical state-handler when it
N* ignores (does not handle) an event. Applicable only to FSMs.
N*/
N#define Q_IGNORED()      ((QState)Q_RET_IGNORED)
N
N
N/*! QEP reserved signals */
Nenum {
N    Q_ENTRY_SIG = 1,  /*!< signal for coding entry actions */
N    Q_EXIT_SIG,       /*!< signal for coding exit actions */
N    Q_INIT_SIG,       /*!< signal for coding initial transitions */
N    Q_USER_SIG        /*!< first signal that can be used for user signals */
N};
N
N#endif /* qep_h */
N
L 14 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil\qep_port.h" 2
N
N#endif                                                        /* qep_port_h */
L 48 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil\qf_port.h" 2
N#ifdef QK
S#include "qk.h"
N#else
N#include "qvanilla.h"                       /* "Vanilla" cooperative kernel */
L 1 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qvanilla.h" 1
N/**
N* \file
N* \brief platform-independent interface to the cooperative "vanilla" kernel.
N* \ingroup qf
N* \cond
N******************************************************************************
N* Product: QF/C
N* Last updated for version 5.3.0
N* Last updated on  2014-02-24
N*
N*                    Q u a n t u m     L e a P s
N*                    ---------------------------
N*                    innovating embedded systems
N*
N* Copyright (C) Quantum Leaps, www.state-machine.com.
N*
N* This program is open source software: you can redistribute it and/or
N* modify it under the terms of the GNU General Public License as published
N* by the Free Software Foundation, either version 3 of the License, or
N* (at your option) any later version.
N*
N* Alternatively, this program may be distributed and modified under the
N* terms of Quantum Leaps commercial licenses, which expressly supersede
N* the GNU General Public License and are specifically designed for
N* licensees interested in retaining the proprietary status of their code.
N*
N* This program is distributed in the hope that it will be useful,
N* but WITHOUT ANY WARRANTY; without even the implied warranty of
N* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
N* GNU General Public License for more details.
N*
N* You should have received a copy of the GNU General Public License
N* along with this program. If not, see <http://www.gnu.org/licenses/>.
N*
N* Contact information:
N* Web:   www.state-machine.com
N* Email: info@state-machine.com
N******************************************************************************
N* \endcond
N*/
N#ifndef qvanilla_h
N#define qvanilla_h
N
N#include "qequeue.h" /* "Vanilla" kernel uses the native QF event queue  */
L 1 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qequeue.h" 1
N/**
N* \file
N* \brief platform-independent "raw" event queue interface.
N* \ingroup qf
N* \cond
N******************************************************************************
N* Product: QF/C
N* Last updated for version 5.3.0
N* Last updated on  2014-02-17
N*
N*                    Q u a n t u m     L e a P s
N*                    ---------------------------
N*                    innovating embedded systems
N*
N* Copyright (C) Quantum Leaps, www.state-machine.com.
N*
N* This program is open source software: you can redistribute it and/or
N* modify it under the terms of the GNU General Public License as published
N* by the Free Software Foundation, either version 3 of the License, or
N* (at your option) any later version.
N*
N* Alternatively, this program may be distributed and modified under the
N* terms of Quantum Leaps commercial licenses, which expressly supersede
N* the GNU General Public License and are specifically designed for
N* licensees interested in retaining the proprietary status of their code.
N*
N* This program is distributed in the hope that it will be useful,
N* but WITHOUT ANY WARRANTY; without even the implied warranty of
N* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
N* GNU General Public License for more details.
N*
N* You should have received a copy of the GNU General Public License
N* along with this program. If not, see <http://www.gnu.org/licenses/>.
N*
N* Contact information:
N* Web:   www.state-machine.com
N* Email: info@state-machine.com
N******************************************************************************
N* \endcond
N*/
N#ifndef qequeue_h
N#define qequeue_h
N
N/**
N* \description
N* This header file must be included in all QF ports that use native QF
N* event queue for active objects. Also, this file needs to be included
N* in the QP/C library when the application uses QActive_defer()/
N* QActive_recall(). Finally, this file is also needed when the "raw"
N* thread-safe queues are used for communication between active objects
N* and non-framework entities, such as ISRs, device drivers, or legacy
N* code.
N*/
N
N#ifndef QF_EQUEUE_CTR_SIZE
N
N    /*! The size (in bytes) of the ring-buffer counters used in the
N    * native QF event queue implementation. Valid values: 1, 2, or 4;
N    * default 1. */
N    /**
N    * \description
N    * This macro can be defined in the QF port file (qf_port.h) to
N    * configure the ::QEQueueCtr type. Here the macro is not defined so the
N    * default of 1 byte is chosen.
N    */
N    #define QF_EQUEUE_CTR_SIZE 1
N#endif
N#if (QF_EQUEUE_CTR_SIZE == 1)
X#if (1 == 1)
N
N    /*! The data type to store the ring-buffer counters based on
N    * the macro #QF_EQUEUE_CTR_SIZE. */
N    /**
N    * \description
N    * The dynamic range of this data type determines the maximum length
N    * of the ring buffer managed by the native QF event queue.
N    */
N    typedef uint_fast8_t QEQueueCtr;
N#elif (QF_EQUEUE_CTR_SIZE == 2)
S    typedef uint_fast16_t QEQueueCtr;
S#elif (QF_EQUEUE_CTR_SIZE == 4)
S    typedef uint_fast32_t QEQueueCtr;
S#else
S    #error "QF_EQUEUE_CTR_SIZE defined incorrectly, expected 1, 2, or 4"
N#endif
N
N/****************************************************************************/
N/*! Native QF Event Queue */
N/**
N* \description
N* This class describes the native QF event queue, which can be used as
N* the event queue for active objects, or as a simple "raw" event queue for
N* thread-safe event passing among non-framework entities, such as ISRs,
N* device drivers, or other third-party components.\n
N* \n
N* The native QF event queue is configured by defining the macro
N* #QF_EQUEUE_TYPE as ::QEQueue in the specific QF port header file.\n
N* \n
N* The ::QEQueue structure contains only data members for managing an event
N* queue, but does not contain the storage for the queue buffer, which must
N* be provided externally during the queue initialization.\n
N* \n
N* The event queue can store only event pointers, not the whole events. The
N* internal implementation uses the standard ring-buffer plus one external
N* location that optimizes the queue operation for the most frequent case
N* of empty queue.\n
N* \n
N* The ::QEQueue structure is used with two sets of functions. One set is for
N* the active object event queue, which might need to block the active object
N* task when the event queue is empty and might need to unblock it when
N* events are posted to the queue. The interface for the native active object
N* event queue consists of the following functions: QActive_post(),
N* QActive_postLIFO(), and QActive_get_(). Additionally the function
N* QEQueue_init() is used to initialize the queue.\n
N* \n
N* The other set of functions, uses ::QEQueue as a simple "raw" event
N* queue to pass events between entities other than active objects, such as
N* ISRs. The "raw" event queue is not capable of blocking on the get()
N* operation, but is still thread-safe because it uses QF critical section
N* to protect its integrity. The interface for the "raw" thread-safe queue
N* consists of the following functions: QEQueue_post(),
N* QEQueue_postLIFO(), and QEQueue_get(). Additionally the function
N* QEQueue_init() is used to initialize the queue.
N*
N* \note Most event queue operations (both the active object queues and
N* the "raw" queues) internally use  the QF critical section. You should be
N* careful not to invoke those operations from other critical sections when
N* nesting of critical sections is not supported.
N*
N* \sa ::QEQueue for the description of the data members
N*/
Ntypedef struct QEQueue {
N    /*! pointer to event at the front of the queue. */
N    /**
N    * \description
N    * All incoming and outgoing events pass through the frontEvt location.
N    * When the queue is empty (which is most of the time), the extra
N    * frontEvt location allows to bypass the ring buffer altogether,
N    * greatly optimizing the performance of the queue. Only bursts of events
N    * engage the ring buffer.
N    *
N    * \note The additional role of this attribute is to indicate the empty
N    * status of the queue. The queue is empty when frontEvt is NULL.
N    */
N    QEvt const * volatile frontEvt;
N
N    /*! pointer to the start of the ring buffer. */
N    QEvt const **ring;
N
N    /*! offset of the end of the ring buffer from the start of the buffer. */
N    QEQueueCtr end;
N
N    /*! offset to where next event will be inserted into the buffer. */
N    QEQueueCtr volatile head;
N
N    /*! offset of where next event will be extracted from the buffer. */
N    QEQueueCtr volatile tail;
N
N    /*! number of free events in the ring buffer. */
N    QEQueueCtr volatile nFree;
N
N    /*! minimum number of free events ever in the ring buffer. */
N    /**
N    * \description
N    * this attribute remembers the low-watermark of the ring buffer,
N    * which provides a valuable information for sizing event queues.
N    * \sa QF_getQueueMargin().
N    */
N    QEQueueCtr nMin;
N} QEQueue;
N
N/* public class operations */
N
N/*! Initialize the native QF event queue */
Nvoid QEQueue_init(QEQueue * const me,
N                  QEvt const *qSto[], uint_fast16_t const qLen);
N
N/*! Post an event to the "raw" thread-safe event queue (FIFO). */
Nbool QEQueue_post(QEQueue * const me, QEvt const * const e,
X_Bool QEQueue_post(QEQueue * const me, QEvt const * const e,
N                  uint_fast16_t const margin);
N
N/*! Post an event to the "raw" thread-safe event queue (LIFO). */
Nvoid QEQueue_postLIFO(QEQueue * const me, QEvt const * const e);
N
N/*! Obtain an event from the "raw" thread-safe queue. */
NQEvt const *QEQueue_get(QEQueue * const me);
N
N/*! "raw" thread-safe QF event queue operation for obtaining the number
N* of free entries still available in the queue. */
N/**
N* \description
N* This operation needs to be used with caution because the number of free
N* entries can change unexpectedly. The main intent for using this operation
N* is in conjunction with event deferral. In this case the queue is accessed
N* only from a single thread (by a single AO),  so the number of free
N* entries cannot change unexpectedly.
N*
N* \arguments
N* \arg[in] \c me_ pointer (see \ref derivation)
N*
N* \returns the current number of free slots in the queue.
N*/
N#define QEQueue_getNFree(me_) ((me_)->nFree)
N
N/*! "raw" thread-safe QF event queue operation to find out if the queue
N* is empty. */
N/**
N* \description
N* This operation needs to be used with caution because the queue status
N* can change unexpectedly. The main intent for using this operation is in
N* conjunction with event deferral. In this case the queue is accessed only
N* from a single thread (by a single AO), so no other entity can post
N* events to the queue.
N*
N* \arguments
N* \arg[in] \c me_  pointer (see \ref derivation)
N*
N* \returns 'true' if the queue is current empty and 'false' otherwise.
N*/
N#define QEQueue_isEmpty(me_) ((me_)->frontEvt == (QEvt const *)0)
N
N#endif /* qequeue_h */
N
L 45 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qvanilla.h" 2
N#include "qmpool.h"  /* "Vanilla" kernel uses the native QF memory pool  */
L 1 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qmpool.h" 1
N/**
N* \file
N* \brief platform-independent memory pool ::QMPool interface.
N* \ingroup qf
N* \cond
N******************************************************************************
N* Product: QF/C
N* Last updated for version 5.3.0
N* Last updated on  2014-04-10
N*
N*                    Q u a n t u m     L e a P s
N*                    ---------------------------
N*                    innovating embedded systems
N*
N* Copyright (C) Quantum Leaps, www.state-machine.com.
N*
N* This program is open source software: you can redistribute it and/or
N* modify it under the terms of the GNU General Public License as published
N* by the Free Software Foundation, either version 3 of the License, or
N* (at your option) any later version.
N*
N* Alternatively, this program may be distributed and modified under the
N* terms of Quantum Leaps commercial licenses, which expressly supersede
N* the GNU General Public License and are specifically designed for
N* licensees interested in retaining the proprietary status of their code.
N*
N* This program is distributed in the hope that it will be useful,
N* but WITHOUT ANY WARRANTY; without even the implied warranty of
N* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
N* GNU General Public License for more details.
N*
N* You should have received a copy of the GNU General Public License
N* along with this program. If not, see <http://www.gnu.org/licenses/>.
N*
N* Contact information:
N* Web:   www.state-machine.com
N* Email: info@state-machine.com
N******************************************************************************
N* \endcond
N*/
N#ifndef qmpool_h
N#define qmpool_h
N
N/****************************************************************************/
N#ifndef QF_MPOOL_SIZ_SIZE
N    /*! macro to override the default ::QMPoolSize size.
N    * Valid values 1, 2, or 4; default 2
N    */
N    #define QF_MPOOL_SIZ_SIZE 2
N#endif
N#if (QF_MPOOL_SIZ_SIZE == 1)
X#if (2 == 1)
S
S    /*! The data type to store the block-size based on the macro
S    * #QF_MPOOL_SIZ_SIZE.
S    */
S    /**
S    * \description
S    * The dynamic range of this data type determines the maximum size
S    * of blocks that can be managed by the native QF event pool.
S    */
S    typedef uint8_t QMPoolSize;
N#elif (QF_MPOOL_SIZ_SIZE == 2)
X#elif (2 == 2)
N
N    typedef uint16_t QMPoolSize;
N#elif (QF_MPOOL_SIZ_SIZE == 4)
S    typedef uint32_t QMPoolSize;
S#else
S    #error "QF_MPOOL_SIZ_SIZE defined incorrectly, expected 1, 2, or 4"
N#endif
N
N/****************************************************************************/
N#ifndef QF_MPOOL_CTR_SIZE
N    /*! macro to override the default ::QMPoolCtr size.
N    * Valid values 1, 2, or 4; default 2
N    */
N    #define QF_MPOOL_CTR_SIZE 2
N#endif
N#if (QF_MPOOL_CTR_SIZE == 1)
X#if (2 == 1)
S
S    /*! The data type to store the block-counter based on the macro
S    * #QF_MPOOL_CTR_SIZE.
S    */
S    /**
S    * \description
S    * The dynamic range of this data type determines the maximum number
S    * of blocks that can be stored in the pool.
S    */
S    typedef uint8_t QMPoolCtr;
N#elif (QF_MPOOL_CTR_SIZE == 2)
X#elif (2 == 2)
N    typedef uint16_t QMPoolCtr;
N#elif (QF_MPOOL_CTR_SIZE == 4)
S    typedef uint32_t QMPoolCtr;
S#else
S    #error "QF_MPOOL_CTR_SIZE defined incorrectly, expected 1, 2, or 4"
N#endif
N
N/****************************************************************************/
N/*! Native QF Memory Pool */
N/**
N* \description
N* A fixed block-size memory pool is a very fast and efficient data
N* structure for dynamic allocation of fixed block-size chunks of memory.
N* A memory pool offers fast and deterministic allocation and recycling of
N* memory blocks and is not subject to fragmenation.\n
N* \n
N* The ::QMPool class describes the native QF memory pool, which can be used as
N* the event pool for dynamic event allocation, or as a fast, deterministic
N* fixed block-size heap for any other objects in your application.
N*
N* \note
N* ::QMPool contains only data members for managing a memory pool, but
N* does not contain the pool storage, which must be provided externally
N* during the pool initialization.
N*
N* \note
N* The native QF event pool is configured by defining the macro
N* #QF_EPOOL_TYPE_ as ::QMPool in the specific QF port header file.
N*/
Ntypedef struct {
N    /*! The head of the linked list of free blocks */
N    void * volatile free_head;
N
N    /*! the original start this pool */
N    void *start;
N
N    /*! the last memory block managed by this memory pool */
N    void *end;
N
N    /*!  maximum block size (in bytes) */
N    QMPoolSize blockSize;
N
N    /*! total number of blocks */
N    QMPoolCtr nTot;
N
N    /*! number of free blocks remaining */
N    QMPoolCtr volatile nFree;
N
N    /*! minimum number of free blocks ever present in this pool */
N    /**
N    * \description
N    * this attribute remembers the low watermark of the pool, which
N    * provides a valuable information for sizing event pools.
N    * \sa QF_getPoolMin().
N    */
N    QMPoolCtr nMin;
N} QMPool;
N
N/* public functions: */
N
N/*! Initializes the native QF memory pool */
Nvoid QMPool_init(QMPool * const me, void * const poolSto,
N                 uint_fast16_t poolSize, uint_fast16_t blockSize);
N
N/*! Obtains a memory block from a memory pool. */
Nvoid *QMPool_get(QMPool * const me, uint_fast16_t const margin);
N
N/*! Recycles a memory block back to a memory pool. */
Nvoid QMPool_put(QMPool * const me, void *b);
N
N/*! Memory pool element to allocate correctly aligned storage
N* for QMPool class.
N*/
N/**
N* \arguments
N* \arg[in] \c evType_ event type (name of the subclass of QEvt)
N*/
N#define QF_MPOOL_EL(evType_) \
N    struct { void *sto_[((sizeof(evType_) - 1U)/sizeof(void*)) + 1U]; }
X#define QF_MPOOL_EL(evType_)     struct { void *sto_[((sizeof(evType_) - 1U)/sizeof(void*)) + 1U]; }
N
N#endif /* qmpool_h */
N
L 46 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qvanilla.h" 2
N#include "qpset.h"   /* "Vanilla" kernel uses the native QF priority set */
L 1 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qpset.h" 1
N/**
N* \file
N* \brief platform-independent priority sets of 8 or 64 elements.
N* \ingroup qf
N* \cond
N******************************************************************************
N* Product: QF/C
N* Last updated for version 5.3.0
N* Last updated on  2014-02-24
N*
N*                    Q u a n t u m     L e a P s
N*                    ---------------------------
N*                    innovating embedded systems
N*
N* Copyright (C) Quantum Leaps, www.state-machine.com.
N*
N* This program is open source software: you can redistribute it and/or
N* modify it under the terms of the GNU General Public License as published
N* by the Free Software Foundation, either version 3 of the License, or
N* (at your option) any later version.
N*
N* Alternatively, this program may be distributed and modified under the
N* terms of Quantum Leaps commercial licenses, which expressly supersede
N* the GNU General Public License and are specifically designed for
N* licensees interested in retaining the proprietary status of their code.
N*
N* This program is distributed in the hope that it will be useful,
N* but WITHOUT ANY WARRANTY; without even the implied warranty of
N* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
N* GNU General Public License for more details.
N*
N* You should have received a copy of the GNU General Public License
N* along with this program. If not, see <http://www.gnu.org/licenses/>.
N*
N* Contact information:
N* Web:   www.state-machine.com
N* Email: info@state-machine.com
N******************************************************************************
N* \endcond
N*/
N#ifndef qpset_h
N#define qpset_h
N
N/****************************************************************************/
N/*! Priority Set of up to 8 elements for building various schedulers */
N/**
N* The priority set represents the set of active objects that are ready to
N* run and need to be considered by the scheduling algorithm. The set is
N* capable of storing up to 8 priority levels.
N*
N* The priority set allows to build cooperative multitasking schedulers
N* to manage up to 8 tasks.
N*/
Ntypedef struct {
N    uint_fast8_t volatile bits;  /*!< bitmask with a bit for each element */
N} QPSet8;
N
N/*! Evaluates to TRUE if the priority set \c me_ has elements */
N#define QPSet8_isEmpty(me_) ((me_)->bits == (uint_fast8_t)0)
N
N/*! Evaluates to TRUE if the priority set \c me_ is empty */
N#define QPSet8_notEmpty(me_) ((me_)->bits != (uint_fast8_t)0)
N
N/*! Evaluates to TRUE if the priority set \c me_ has element \c n_ */
N#define QPSet8_hasElement(me_, n_) \
N    (((me_)->bits & (uint_fast8_t)Q_ROM_BYTE(QF_pwr2Lkup[(n_)])) \
N    != (uint_fast8_t)0)
X#define QPSet8_hasElement(me_, n_)     (((me_)->bits & (uint_fast8_t)Q_ROM_BYTE(QF_pwr2Lkup[(n_)]))     != (uint_fast8_t)0)
N
N/*! Insert element \c n_ into the set \c me_, n_= 1..8 */
N#define QPSet8_insert(me_, n_) \
N    ((me_)->bits |= (uint_fast8_t)Q_ROM_BYTE(QF_pwr2Lkup[(n_)]))
X#define QPSet8_insert(me_, n_)     ((me_)->bits |= (uint_fast8_t)Q_ROM_BYTE(QF_pwr2Lkup[(n_)]))
N
N/*! Remove element n_ from the set \c me_, n_= 1..8 */
N#define QPSet8_remove(me_, n_) \
N    ((me_)->bits &= (uint_fast8_t)Q_ROM_BYTE(QF_invPwr2Lkup[(n_)]))
X#define QPSet8_remove(me_, n_)     ((me_)->bits &= (uint_fast8_t)Q_ROM_BYTE(QF_invPwr2Lkup[(n_)]))
N
N/*! Find the maximum element in the set, and assign it to n_ */
N/** \note if the set \c me_ is empty, \c n_ is set to zero.
N*/
N#define QPSet8_findMax(me_, n_) \
N    ((n_) = (uint_fast8_t)QF_LOG2((me_)->bits))
X#define QPSet8_findMax(me_, n_)     ((n_) = (uint_fast8_t)QF_LOG2((me_)->bits))
N
N
N/****************************************************************************/
N/*! Priority Set of up to 64 elements for building various schedulers */
N/**
N* The priority set represents the set of active objects that are ready to
N* run and need to be considered by the scheduling algorithm. The set is
N* capable of storing up to 64 priority levels.
N*
N* The priority set allows to build cooperative multitasking schedulers
N* to manage up to 64 tasks. It is also used in the Quantum Kernel (QK)
N* preemptive scheduler.
N*/
Ntypedef struct {
N
N    /** \brief bimask representing 8-element subsets of the set
N    *
N    * Each bit in the bytes set represents a subset (8-elements)
N    * as follows: \n
N    * bit 0 in bytes is 1 when bits[0] is not empty \n
N    * bit 1 in bytes is 1 when bits[1] is not empty \n
N    * bit 2 in bytes is 1 when bits[2] is not empty \n
N    * bit 3 in bytes is 1 when bits[3] is not empty \n
N    * bit 4 in bytes is 1 when bits[4] is not empty \n
N    * bit 5 in bytes is 1 when bits[5] is not empty \n
N    * bit 6 in bytes is 1 when bits[6] is not empty \n
N    * bit 7 in bytes is 1 when bits[7] is not empty \n
N    */
N    uint_fast8_t volatile bytes;
N
N    /** \brief bits representing elements in the set as follows: \n
N    * bits[0] represent elements  1..8  \n
N    * bits[1] represent elements  9..16 \n
N    * bits[2] represent elements 17..24 \n
N    * bits[3] represent elements 25..32 \n
N    * bits[4] represent elements 33..40 \n
N    * bits[5] represent elements 41..48 \n
N    * bits[6] represent elements 49..56 \n
N    * bits[7] represent elements 57..64 \n
N    */
N    uint_fast8_t volatile bits[8];
N} QPSet64;
N
N/*! Evaluates to TRUE if the priority set \c me_ has elements */
N#define QPSet64_isEmpty(me_)    ((me_)->bytes == (uint_fast8_t)0)
N
N/*! Evaluates to TRUE if the priority set \c me is empty */
N#define QPSet64_notEmpty(me_)   ((me_)->bytes != (uint_fast8_t)0)
N
N/*! Evaluates to TRUE if the priority set \c me_ has element \c n_. */
N#define QPSet64_hasElement(me_, n_) \
N    (((me_)->bits[Q_ROM_BYTE(QF_div8Lkup[(n_)])] \
N      & (uint_fast8_t)Q_ROM_BYTE(QF_pwr2Lkup[(n_)])) != ((uint_fast8_t)0)
X#define QPSet64_hasElement(me_, n_)     (((me_)->bits[Q_ROM_BYTE(QF_div8Lkup[(n_)])]       & (uint_fast8_t)Q_ROM_BYTE(QF_pwr2Lkup[(n_)])) != ((uint_fast8_t)0)
N
N/*! insert element \c n_ into the set \c me_, n_= 1..64 */
N#define QPSet64_insert(me_, n_) do { \
N    uint_fast8_t m_  = (uint_fast8_t)Q_ROM_BYTE(QF_div8Lkup[(n_)]); \
N    (me_)->bits[m_] |= (uint_fast8_t)Q_ROM_BYTE(QF_pwr2Lkup[(n_)]); \
N    (me_)->bytes    |= (uint_fast8_t)Q_ROM_BYTE(QF_pwr2Lkup[m_ \
N                                               + (uint_fast8_t)1]); \
N} while (0)
X#define QPSet64_insert(me_, n_) do {     uint_fast8_t m_  = (uint_fast8_t)Q_ROM_BYTE(QF_div8Lkup[(n_)]);     (me_)->bits[m_] |= (uint_fast8_t)Q_ROM_BYTE(QF_pwr2Lkup[(n_)]);     (me_)->bytes    |= (uint_fast8_t)Q_ROM_BYTE(QF_pwr2Lkup[m_                                                + (uint_fast8_t)1]); } while (0)
N
N/*! Remove element n_ from the set \c me_, n_= 1..64 */
N#define QPSet64_remove(me_, n_) do { \
N    uint_fast8_t m_ = (uint_fast8_t)Q_ROM_BYTE(QF_div8Lkup[(n_)]); \
N    if (((me_)->bits[m_] &= (uint_fast8_t)Q_ROM_BYTE( \
N                            QF_invPwr2Lkup[(n_)])) == (uint_fast8_t)0) { \
N        (me_)->bytes &= (uint_fast8_t)Q_ROM_BYTE( \
N                                      QF_invPwr2Lkup[m_ + (uint_fast8_t)1]); \
N    } \
N} while (0)
X#define QPSet64_remove(me_, n_) do {     uint_fast8_t m_ = (uint_fast8_t)Q_ROM_BYTE(QF_div8Lkup[(n_)]);     if (((me_)->bits[m_] &= (uint_fast8_t)Q_ROM_BYTE(                             QF_invPwr2Lkup[(n_)])) == (uint_fast8_t)0) {         (me_)->bytes &= (uint_fast8_t)Q_ROM_BYTE(                                       QF_invPwr2Lkup[m_ + (uint_fast8_t)1]);     } } while (0)
N
N/*! Find the maximum element in the set, and assign it to \c n_ */
N/** \note if the set \c me_ is empty, \c n_ is set to zero.
N*/
N#define QPSet64_findMax(me_, n_) do { \
N    if ((me_)->bytes != (uint_fast8_t)0) { \
N        (n_) = (uint_fast8_t)QF_LOG2((me_)->bytes) - (uint_fast8_t)1; \
N        (n_) = (uint_fast8_t)QF_LOG2((me_)->bits[(n_)]) \
N                              + (uint_fast8_t)((n_) << 3); \
N    } \
N    else { \
N       (n_) = (uint_fast8_t)0; \
N    } \
N} while (0)
X#define QPSet64_findMax(me_, n_) do {     if ((me_)->bytes != (uint_fast8_t)0) {         (n_) = (uint_fast8_t)QF_LOG2((me_)->bytes) - (uint_fast8_t)1;         (n_) = (uint_fast8_t)QF_LOG2((me_)->bits[(n_)])                               + (uint_fast8_t)((n_) << 3);     }     else {        (n_) = (uint_fast8_t)0;     } } while (0)
N
N#endif /* qpset_h */
N
L 47 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qvanilla.h" 2
N
N/*! This macro defines the type of the event queue used for the
N* active objects. For the built-in Vanilla kernel, this is ::QEqueue.
N*/
N#define QF_EQUEUE_TYPE  QEQueue
N
N/*! QF idle callback (customized in BSPs for QF) */
N/**
N* \description
N* QF_onIdle() is called by the non-preemptive "Vanilla" scheduler
N* (from QF_run()) when the scheduler detects that no events are available
N* for active objects (the idle condition). This callback gives the
N* application an opportunity to enter a power-saving CPU mode, or perform
N* some other idle processing (such as Q-Spy output).
N*
N* \note QF_onIdle() is invoked with interrupts DISABLED because the idle
N* condition can be asynchronously changed at any time by an interrupt.
N* QF_onIdle() MUST enable the interrupts internally, but not before
N* putting the CPU into the low-power mode. (Ideally, enabling interrupts and
N* low-power mode should happen atomically). At the very least, the function
N* MUST enable interrupts, otherwise interrupts will remain disabled
N* permanently.
N*
N* \note QF_onIdle() is only used by the non-preemptive "Vanilla" scheduler
N* in the "bare metal" QF port, and is NOT used in any other QF ports. When
N* QF is combined with QK, the QK idle loop calls a different function
N* QK_onIdle(), with different semantics than QF_onIdle(). When QF is
N* combined with a 3rd-party RTOS or kernel, the idle processing mechanism
N* of the RTOS or kernel is used instead of QF_onIdle().
N*/
Nvoid QF_onIdle(void);
N
N/****************************************************************************/
N/* interface used only inside QP implementation, but not in applications */
N#ifdef QP_IMPL
N
N    /* native QF event queue operations */
N    #define QACTIVE_EQUEUE_WAIT_(me_) \
N        Q_ASSERT_ID(0, (me_)->eQueue.frontEvt != (QEvt *)0)
X    #define QACTIVE_EQUEUE_WAIT_(me_)         Q_ASSERT_ID(0, (me_)->eQueue.frontEvt != (QEvt *)0)
N
N    #if (QF_MAX_ACTIVE <= 8)
X    #if (8 <= 8)
N        #define QACTIVE_EQUEUE_SIGNAL_(me_) \
N            QPSet8_insert(&QF_readySet_, (me_)->prio)
X        #define QACTIVE_EQUEUE_SIGNAL_(me_)             QPSet8_insert(&QF_readySet_, (me_)->prio)
N        #define QACTIVE_EQUEUE_ONEMPTY_(me_) \
N            QPSet8_remove(&QF_readySet_, (me_)->prio)
X        #define QACTIVE_EQUEUE_ONEMPTY_(me_)             QPSet8_remove(&QF_readySet_, (me_)->prio)
N    #else
S        #define QACTIVE_EQUEUE_SIGNAL_(me_) \
S            QPSet64_insert(&QF_readySet_, (me_)->prio)
X        #define QACTIVE_EQUEUE_SIGNAL_(me_)             QPSet64_insert(&QF_readySet_, (me_)->prio)
S        #define QACTIVE_EQUEUE_ONEMPTY_(me_) \
S            QPSet64_remove(&QF_readySet_, (me_)->prio)
X        #define QACTIVE_EQUEUE_ONEMPTY_(me_)             QPSet64_remove(&QF_readySet_, (me_)->prio)
N    #endif
N
N    /* native QF event pool operations */
N    #define QF_EPOOL_TYPE_            QMPool
N    #define QF_EPOOL_INIT_(p_, poolSto_, poolSize_, evtSize_) \
N        (QMPool_init(&(p_), (poolSto_), (poolSize_), (evtSize_)))
X    #define QF_EPOOL_INIT_(p_, poolSto_, poolSize_, evtSize_)         (QMPool_init(&(p_), (poolSto_), (poolSize_), (evtSize_)))
N    #define QF_EPOOL_EVENT_SIZE_(p_)  ((uint_fast16_t)(p_).blockSize)
N    #define QF_EPOOL_GET_(p_, e_, m_) ((e_) = (QEvt *)QMPool_get(&(p_), (m_)))
N    #define QF_EPOOL_PUT_(p_, e_)     (QMPool_put(&(p_), (e_)))
N
N    #if (QF_MAX_ACTIVE <= 8)
X    #if (8 <= 8)
N        extern QPSet8 QF_readySet_;  /*!< QF-ready set of AOs */
N    #else
S        extern QPSet64 QF_readySet_; /*!< QF-ready set of AOs */
N    #endif
N
N#endif /* QP_IMPL */
N
N#endif /* qvanilla_h */
L 52 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil\qf_port.h" 2
N#endif
N
N#include "qf.h"                 /* QF platform-independent public interface */
L 1 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qf.h" 1
N/**
N* \file
N* \brief QF/C platform-independent public interface.
N* \ingroup qf
N* \cond
N******************************************************************************
N* Product: QF/C
N* Last updated for version 5.3.0
N* Last updated on  2014-02-24
N*
N*                    Q u a n t u m     L e a P s
N*                    ---------------------------
N*                    innovating embedded systems
N*
N* Copyright (C) Quantum Leaps, www.state-machine.com.
N*
N* This program is open source software: you can redistribute it and/or
N* modify it under the terms of the GNU General Public License as published
N* by the Free Software Foundation, either version 3 of the License, or
N* (at your option) any later version.
N*
N* Alternatively, this program may be distributed and modified under the
N* terms of Quantum Leaps commercial licenses, which expressly supersede
N* the GNU General Public License and are specifically designed for
N* licensees interested in retaining the proprietary status of their code.
N*
N* This program is distributed in the hope that it will be useful,
N* but WITHOUT ANY WARRANTY; without even the implied warranty of
N* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
N* GNU General Public License for more details.
N*
N* You should have received a copy of the GNU General Public License
N* along with this program. If not, see <http://www.gnu.org/licenses/>.
N*
N* Contact information:
N* Web:   www.state-machine.com
N* Email: info@state-machine.com
N******************************************************************************
N* \endcond
N*/
N#ifndef qf_h
N#define qf_h
N
N/****************************************************************************/
N#if (QF_MAX_ACTIVE < 1) || (63 < QF_MAX_ACTIVE)
X#if (8 < 1) || (63 < 8)
S    #error "QF_MAX_ACTIVE not defined or out of range. Valid range is 1..63"
N#endif
N
N#ifndef QF_EVENT_SIZ_SIZE
N    /*! Default value of the macro configurable value in qf_port.h */
N    #define QF_EVENT_SIZ_SIZE 2
N#endif
N#if (QF_EVENT_SIZ_SIZE == 1)
X#if (2 == 1)
S    typedef uint8_t QEvtSize;
N#elif (QF_EVENT_SIZ_SIZE == 2)
X#elif (2 == 2)
N    /*! The data type to store the block-size defined based on
N    * the macro #QF_EVENT_SIZ_SIZE. */
N    /**
N    * The dynamic range of this data type determines the maximum block
N    * size that can be managed by the pool.
N    */
N    typedef uint16_t QEvtSize;
N#elif (QF_EVENT_SIZ_SIZE == 4)
S    typedef uint32_t QEvtSize;
S#else
S    #error "QF_EVENT_SIZ_SIZE defined incorrectly, expected 1, 2, or 4"
N#endif
N
N#ifndef QF_MAX_EPOOL
N    /*! Default value of the macro configurable value in qf_port.h */
N    #define QF_MAX_EPOOL         3
N#endif
N
N#ifndef QF_MAX_TICK_RATE
S    /*! Default value of the macro configurable value in qf_port.h     */
S    #define QF_MAX_TICK_RATE     1
N#endif
N
N#ifndef QF_TIMEEVT_CTR_SIZE
N    /*! macro to override the default ::QTimeEvtCtr size. Valid values:
N    * 1, 2, or 4; default 2
N    */
N    #define QF_TIMEEVT_CTR_SIZE  2
N#endif
N
N/****************************************************************************/
Nstruct QEQueue; /* forward declaration */
N
N/*! QActive is the base structure for derivation of active objects */
N/**
N* \description
N* Active objects in QP are encapsulated state machines (each embedding an
N* event queue and a thread) that communicate with one another asynchronously
N* by sending and receiving events. Within an active object, events are
N* processed sequentially in a run-to-completion (RTC) fashion, while QF
N* encapsulates all the details of thread-safe event exchange and queuing.
N*
N* \note ::QActive is not intended to be instantiated directly, but rather
N* serves as the base structure for derivation of active objects in the
N* application code.
N*
N* \usage
N* The following example illustrates how to derive an active object from
N* QActive. Please note that the QActive member \c super is defined as the
N* __first__ member of the derived struct (see \ref derivation).
N* \include qf_qactive.c
N*
N* \sa ::QMActive
N*/
Ntypedef struct {
N    QHsm super; /*!< inherits ::QHsm */
N
N#ifdef QF_EQUEUE_TYPE
N    /*! OS-dependent event-queue type. */
N    /**
N    * \description
N    * The type of the queue depends on the underlying operating system or
N    * a kernel. Many kernels support "message queues" that can be adapted
N    * to deliver QF events to the active object. Alternatively, QF provides
N    * a native event queue implementation that can be used as well.
N    *
N    * \note The native QF event queue is configured by defining the macro
N    * #QF_EQUEUE_TYPE as ::QEQueue.
N    */
N    QF_EQUEUE_TYPE eQueue;
X    QEQueue eQueue;
N#endif
N
N#ifdef QF_OS_OBJECT_TYPE
S    /*! OS-dependent per-thread object. */
S    /**
S    * \description
S    * This data might be used in various ways, depending on the QF port.
S    * In some ports osObject is used to block the calling thread when
S    * the native QF queue is empty. In other QF ports the OS-dependent
S    * object might be used differently.
S    */
S    QF_OS_OBJECT_TYPE osObject;
N#endif
N
N#ifdef QF_THREAD_TYPE
S    /*! OS-dependent representation of the thread of the active object. */
S    /**
S    * \description
S    * This data might be used in various ways, depending on the QF port.
S    * In some ports thread is used to store the thread handle. In other
S    * ports thread can be the pointer to the Thread-Local-Storage (TLS).
S    */
S    QF_THREAD_TYPE thread;
N#endif
N
N    /*! QF priority associated with the active object. */
N    uint_fast8_t prio;
N
N} QActive;
N
N/*! Virtual table for the ::QActiveVtbl class */
Ntypedef struct {
N    QMsmVtbl super; /*!< inherits QMsmVtbl */
N
N    /*! virtual function to start the active object (thread) */
N    /** \sa QACTIVE_START() */
N    void (*start)(QActive * const me, uint_fast8_t prio,
N                  QEvt const *qSto[], uint_fast16_t qLen,
N                  void *stkSto, uint_fast16_t stkSize,
N                  QEvt const *ie);
N
N#ifdef Q_SPY
S    /*! virtual function to asynchronously post (FIFO) an event to an AO */
S    /** \sa QACTIVE_POST() and QACTIVE_POST_X() */
S    bool (*post)(QActive * const me, QEvt const * const e,
S                 uint_fast16_t const margin, void const * const sender);
N#else
N    bool (*post)(QActive * const me, QEvt const * const e,
X    _Bool (*post)(QActive * const me, QEvt const * const e,
N                 uint_fast16_t const margin);
N#endif
N
N    /*! virtual function to asynchronously post (LIFO) an event to an AO */
N    /** \sa QACTIVE_POST_LIFO() */
N    void (*postLIFO)(QActive * const me, QEvt const * const e);
N
N} QActiveVtbl;
N
N/* public functions */
N/*! Implementation of the active object start operation. */
Nvoid QActive_start_(QActive * const me, uint_fast8_t prio,
N                    QEvt const *qSto[], uint_fast16_t qLen,
N                    void *stkSto, uint_fast16_t stkSize,
N                    QEvt const *ie);
N
N/*! Polymorphically start an active object. */
N/**
N* \description
N* Performs the first step of FSM initialization by assigning the initial
N* pseudostate to the currently active state of the state machine.
N*
N* \arguments
N* \arg[in,out] \c me_      pointer (see \ref derivation)
N* \arg[in]     \c prio_    priority at which to start the active object
N* \arg[in]     \c qSto_    pointer to the storage for the ring buffer of the
N*                          event queue (used only with the built-in ::QEQueue)
N* \arg[in]     \c qLen_    length of the event queue (in events)
N* \arg[in]     \c stkSto_  pointer to the stack storage (used only when
N*                          per-AO stack is needed)
N* \arg[in]     \c stkSize_ stack size (in bytes)
N* \arg[in]     \c ie_      pointer to the optional initialization event
N*                          (might be NULL).
N*/
N#define QACTIVE_START(me_, prio_, qSto_, qLen_, stkSto_, stkLen_, ie_) \
N    ((*((QActiveVtbl const *)((me_)->super.vptr))->start)( \
N        (me_), (prio_), (qSto_), (qLen_), (stkSto_), (stkLen_), (ie_)))
X#define QACTIVE_START(me_, prio_, qSto_, qLen_, stkSto_, stkLen_, ie_)     ((*((QActiveVtbl const *)((me_)->super.vptr))->start)(         (me_), (prio_), (qSto_), (qLen_), (stkSto_), (stkLen_), (ie_)))
N
N#ifdef Q_SPY
S    /*! Implementation of the active object post (FIFO) operation */
S    bool QActive_post_(QActive * const me, QEvt const * const e,
S                         uint_fast16_t const margin,
S                         void const * const sender);
S
S    /*! Polymorphically posts an event to an active object (FIFO)
S    * with delivery guarantee. */
S    /**
S    * \description
S    * This macro asserts if the queue overflows and cannot accept the event.
S    *
S    * \arguments
S    * \arg[in,out] \c me_   pointer (see \ref derivation)
S    * \arg[in]     \c e_    pointer to the event to post
S    * \arg[in]     \c sender_ pointer to the sender object.
S    *
S    * \note The \c sendedr_ argument is actually only used when QS tracing
S    * is enabled (macro #Q_SPY is defined). When QS software tracing is
S    * disenabled, the QACTIVE_POST() macro does not pass the \c sender_
S    * argument, so the overhead of passing this extra argument is entirely
S    * avoided.
S    *
S    * \note the pointer to the sender object is not necessarily a pointer
S    * to an active object. In fact, if QACTIVE_POST() is called from an
S    * interrupt or other context, you can create a unique object just to
S    * unambiguously identify the sender of the event.
S    *
S    * \sa #QACTIVE_POST_X, QActive_post_().
S    */
S    #define QACTIVE_POST(me_, e_, sender_) \
S        ((void)(*((QActiveVtbl const *)((me_)->super.vptr))->post)((me_), \
S         (e_), (uint_fast16_t)0, (sender_)))
X    #define QACTIVE_POST(me_, e_, sender_)         ((void)(*((QActiveVtbl const *)((me_)->super.vptr))->post)((me_),          (e_), (uint_fast16_t)0, (sender_)))
S
S    /*! Polymorphically posts an event to an active object (FIFO)
S    * without delivery guarantee. */
S    /**
S    * \description
S    * This macro does not assert if the queue overflows and cannot accept
S    * the event with the specified margin of free slots remaining.
S    *
S    * \arguments
S    * \arg[in,out] \c me_   pointer (see \ref derivation)
S    * \arg[in]     \c e_    pointer to the event to post
S    * \arg[in]     \c margin_ the minimum free slots in the queue, which
S    *                         must still be available after posting the event
S    * \arg[in]     \c sender_ pointer to the sender object.
S    *
S    * \returns 'true' if the posting succeeded, and 'false' if the posting
S    * failed due to insufficient margin of free slots available in the queue.
S    *
S    * \note The \c sender_ argument is actually only used when QS tracing
S    * is enabled (macro #Q_SPY is defined). When QS software tracing is
S    * disabled, the QACTIVE_POST() macro does not pass the \c sender_
S    * argument, so the overhead of passing this extra argument is entirely
S    * avoided.
S    *
S    * \note the pointer to the sender object is not necessarily a pointer
S    * to an active object. In fact, if QACTIVE_POST() is called from an
S    * interrupt or other context, you can create a unique object just to
S    * unambiguously identify the sender of the event.
S    *
S    * \usage
S    * \include qf_postx.c
S    */
S    #define QACTIVE_POST_X(me_, e_, margin_, sender_) \
S        ((*((QActiveVtbl const *)((me_)->super.vptr))->post)((me_), \
S         (e_), (margin_), (sender_)))
X    #define QACTIVE_POST_X(me_, e_, margin_, sender_)         ((*((QActiveVtbl const *)((me_)->super.vptr))->post)((me_),          (e_), (margin_), (sender_)))
N#else
N
N    bool QActive_post_(QActive * const me, QEvt const * const e,
X    _Bool QActive_post_(QActive * const me, QEvt const * const e,
N                         uint_fast16_t const margin);
N
N    #define QACTIVE_POST(me_, e_, sender_) \
N        ((void)(*((QActiveVtbl const *)((me_)->super.vptr))->post)((me_), \
N                  (e_), (uint_fast16_t)0))
X    #define QACTIVE_POST(me_, e_, sender_)         ((void)(*((QActiveVtbl const *)((me_)->super.vptr))->post)((me_),                   (e_), (uint_fast16_t)0))
N
N    #define QACTIVE_POST_X(me_, e_, margin_, sender_) \
N        ((*((QActiveVtbl const *)((me_)->super.vptr))->post)((me_), \
N                  (e_), (margin_)))
X    #define QACTIVE_POST_X(me_, e_, margin_, sender_)         ((*((QActiveVtbl const *)((me_)->super.vptr))->post)((me_),                   (e_), (margin_)))
N
N#endif
N
N/*! Implementation of the active object post LIFO operation */
Nvoid QActive_postLIFO_(QActive * const me, QEvt const * const e);
N
N/*! Polymorphically posts an event to an active object using the
N* Last-In-First-Out (LIFO) policy. */
N/**
N* \arguments
N* \arg[in,out] \c me_   pointer (see \ref derivation)
N* \arg[in]     \c e_    pointer to the event to post
N*/
N#define QACTIVE_POST_LIFO(me_, e_) \
N    ((*((QActiveVtbl const *)((me_)->super.vptr))->postLIFO)((me_), (e_)))
X#define QACTIVE_POST_LIFO(me_, e_)     ((*((QActiveVtbl const *)((me_)->super.vptr))->postLIFO)((me_), (e_)))
N
N
N/* protected functions ...*/
N
N/*! protected "constructor" of an active object. */
Nvoid QActive_ctor(QActive * const me, QStateHandler initial);
N
N/*! Stops execution of an active object and removes it from the
N* framework's supervision. */
Nvoid QActive_stop(QActive * const me);
N
N/*! Subscribes for delivery of signal \a sig to the active object \a me. */
Nvoid QActive_subscribe(QActive const * const me, enum_t const sig);
N
N/*! Un-subscribes from the delivery of signal \a sig to the AO \a me. */
Nvoid QActive_unsubscribe(QActive const * const me, enum_t const sig);
N
N/*! Un-subscribes from the delivery of all signals to the AO \a me. */
Nvoid QActive_unsubscribeAll(QActive const * const me);
N
N
N/*! Defer an event to a given separate event queue. */
Nbool QActive_defer(QActive * const me,
X_Bool QActive_defer(QActive * const me,
N                   QEQueue * const eq, QEvt const * const e);
N
N/*! Recall a deferred event from a given event queue. */
Nbool QActive_recall(QActive * const me, QEQueue * const eq);
X_Bool QActive_recall(QActive * const me, QEQueue * const eq);
N
N/*! Get an event from the event queue of an active object. */
NQEvt const *QActive_get_(QActive *const me);
N
N/****************************************************************************/
N/*! QM Active Object */
N/**
N* \description
N* QMActive represents an active object version based on the ::QMsm state
N* machine. The application-level active object derived from QMActive
N* typically require the use of QM, but are the fastest and need the least
N* run-time support (the smallest event-processor taking up the least code
N* space). QMActive inherits QActive "as is" without adding new attributes,
N* so it is typedef'ed as ::QActive.
N*/
Ntypedef QActive QMActive;
N
N/*! protected "constructor" of an QMActive active object. */
Nvoid QMActive_ctor(QMActive * const me, QStateHandler initial);
N
N/****************************************************************************/
N#if (QF_TIMEEVT_CTR_SIZE == 1)
X#if (2 == 1)
S    typedef uint8_t QTimeEvtCtr;
N#elif (QF_TIMEEVT_CTR_SIZE == 2)
X#elif (2 == 2)
N
N    /*! type of the Time Event counter, which determines the dynamic
N    * range of the time delays measured in clock ticks. */
N    /**
N    * \description
N    * This typedef is configurable via the preprocessor switch
N    * #QF_TIMEEVT_CTR_SIZE. The other possible values of this type are
N    * as follows: \n
N    * uint8_t when (QF_TIMEEVT_CTR_SIZE == 1), and \n
N    * uint32_t when (QF_TIMEEVT_CTR_SIZE == 4).
N    */
N    typedef uint16_t QTimeEvtCtr;
N#elif (QF_TIMEEVT_CTR_SIZE == 4)
S    typedef uint32_t QTimeEvtCtr;
S#else
S    #error "QF_TIMEEVT_CTR_SIZE defined incorrectly, expected 1, 2, or 4"
N#endif
N
N/*! Time Event structure */
N/**
N* \description
N* Time events are special QF events equipped with the notion of time passage.
N* The basic usage model of the time events is as follows. An active object
N* allocates one or more QTimeEvt objects (provides the storage for them).
N* When the active object needs to arrange for a timeout, it arms one of its
N* time events to fire either just once (one-shot) or periodically. Each time
N* event times out independently from the others, so a QF application can make
N* multiple parallel timeout requests (from the same or different active
N* objects). When QF detects that the appropriate moment has arrived, it
N* inserts the time event directly into the recipient's event queue. The
N* recipient then processes the time event just like any other event.
N*
N* Time events, as any other QF events derive from the ::QEvt base structure.
N* Typically, you will use a time event as-is, but you can also further
N* derive more specialized time events from it by adding some more data
N* members and/or specialized functions that operate on the specialized
N* time events.
N*
N* Internally, the armed time events are organized into linked lists--one list
N* for every supported ticking rate. These linked lists are scanned in every
N* invocation of the QF_tickX_() function. Only armed (timing out) time events
N* are in the list, so only armed time events consume CPU cycles.
N*
N* \sa ::QTimeEvt for the description of the data members \n \ref derivation
N*
N* \note QF manages the time events in the function QF_tickX_(), which
N* must be called periodically, preferably from the clock tick ISR.
N*
N* \note In this version of QF QTimeEvt objects should be allocated statically
N* rather than dynamically from event pools. Currently, QF will not correctly
N* recycle the dynamically allocated Time Events.
N*/
Ntypedef struct QTimeEvt {
N    /*! base structure from which QTimeEvt derives */
N    QEvt super;
N
N    /*! link to the next time event in the list */
N    struct QTimeEvt * volatile next;
N
N    /*! the active object that receives the time events */
N    void * volatile act;
N
N    /*! the internal down-counter of the time event. */
N    /**
N    * \description
N    * The down-counter is decremented by 1 in every QF_tickX_() invocation.
N    * The time event fires (gets posted or published) when the down-counter
N    * reaches zero.
N    */
N    QTimeEvtCtr volatile ctr;
N
N    /*! the interval for periodic time event (zero for one-shot time event) */
N    /**
N    * \description
N    * The value of the interval is re-loaded to the internal down-counter
N    * when the time event expires, so that the time event keeps timing out
N    * periodically.
N    */
N    QTimeEvtCtr interval;
N} QTimeEvt;
N
N/* public functions */
N
N/*! The extended "constructor" to initialize a Time Event. */
Nvoid QTimeEvt_ctorX(QTimeEvt * const me, QActive * const act,
N                    enum_t const sig, uint_fast8_t tickRate);
N
N/*! Arm a time event (one shot or periodic) for direct event posting. */
Nvoid QTimeEvt_armX(QTimeEvt * const me,
N                   QTimeEvtCtr const nTicks, QTimeEvtCtr const interval);
N
N/*! Rearm a time event. */
Nbool QTimeEvt_rearm(QTimeEvt * const me, QTimeEvtCtr const nTicks);
X_Bool QTimeEvt_rearm(QTimeEvt * const me, QTimeEvtCtr const nTicks);
N
N/*! Disarm a time event. */
Nbool QTimeEvt_disarm(QTimeEvt * const me);
X_Bool QTimeEvt_disarm(QTimeEvt * const me);
N
N/*! Get the current value of the down-counter of a time event. */
NQTimeEvtCtr QTimeEvt_ctr(QTimeEvt const * const me);
N
N/****************************************************************************/
N/* QF facilities */
N
N/*! Subscriber-List structure */
N/**
N* \description
N* This data type represents a set of active objects that subscribe to
N* a given signal. The set is represented as an array of bits, where each
N* bit corresponds to the unique priority of an active object.
N*
N* \sa ::QSubscrList for the description of the data members
N*/
Ntypedef struct {
N
N    /*! An array of bits representing subscriber active objects. */
N    /**
N    * \description
N    * Each bit in the array corresponds to the unique priority of the AO.
N    * The size of the array is determined of the maximum number of AOs
N    * in the application configured by the #QF_MAX_ACTIVE macro.
N    * For example, an active object of priority p is a subscriber if the
N    * following is true: ((bits[QF_div8Lkup[p]] & QF_pwr2Lkup[p]) != 0)
N    *
N    * \sa QF_psInit(), ::QF_div8Lkup, ::QF_pwr2Lkup, #QF_MAX_ACTIVE
N    */
N    uint8_t bits[((QF_MAX_ACTIVE - 1) / 8) + 1];
X    uint8_t bits[((8 - 1) / 8) + 1];
N} QSubscrList;
N
N/* public functions */
N
N/*! QF initialization. */
Nvoid QF_init(void);
N
N/*! Publish-subscribe initialization. */
Nvoid QF_psInit(QSubscrList * const subscrSto, enum_t const maxSignal);
N
N/*! Event pool initialization for dynamic allocation of events. */
Nvoid QF_poolInit(void * const poolSto, uint_fast16_t const poolSize,
N                 uint_fast16_t const evtSize);
N
N/*! Transfers control to QF to run the application. */
Nint_t QF_run(void);
N
N/*! Function invoked by the application layer to stop the QF
N* application and return control to the OS/Kernel. */
Nvoid QF_stop(void);
N
N/*! Startup QF callback. */
N/**
N* \description
N* The timeline for calling QF_onStartup() depends on the particular
N* QF port. In most cases, QF_onStartup() is called from QF_run(), right
N* before starting any multitasking kernel or the background loop.
N*/
Nvoid QF_onStartup(void);
N
N/*! Cleanup QF callback. */
N/**
N* \description
N* QF_onCleanup() is called in some QF ports before QF returns to the
N* underlying operating system or RTOS.
N*
N* This function is strongly platform-specific and is not implemented in
N* the QF, but either in the QF port or in the Board Support Package (BSP)
N* for the given application. Some QF ports might not require implementing
N* QF_onCleanup() at all, because many embedded applications don't have
N* anything to exit to.
N*
N* \sa QF_stop()
N*/
Nvoid QF_onCleanup(void);
N
N#ifdef Q_SPY
S
S    /*! Publish event to the framework. */
S    void QF_publish_(QEvt const * const e, void const * const sender);
S
S    /*! Invoke the event publishing facility QF_publish_(). */
S    /**
S    * \description
S    * This macro is the recommended way of publishing events, because it
S    * provides the vital information for software tracing and avoids any
S    * overhead when the tracing is disabled.
S    *
S    * \arguments
S    * \arg[in] \c e_      pointer to the posted event
S    * \arg[in] \c sender_ pointer to the sender object. This argument is
S    *          actually only used when QS software tracing is enabled
S    *          (macro #Q_SPY is defined). When QS software tracing is
S    *          disabled, the macro calls QF_publish_() without the
S    *          \c sender_ argument, so the overhead of passing this
S    *          extra argument is entirely avoided.
S    *
S    * \note the pointer to the sender object is not necessarily a pointer
S    * to an active object. In fact, if QF_PUBLISH() is called from an
S    * interrupt or other context, you can create a unique object just to
S    * unambiguously identify the publisher of the event.
S    *
S    * \sa QF_publish_().
S    */
S    #define QF_PUBLISH(e_, sender_) \
S        (QF_publish_((e_), (void const *)(sender_)))
X    #define QF_PUBLISH(e_, sender_)         (QF_publish_((e_), (void const *)(sender_)))
N#else
N
N    void QF_publish_(QEvt const * const e);
N    #define QF_PUBLISH(e_, dummy_)   (QF_publish_(e_))
N
N#endif
N
N#ifdef Q_SPY
S
S    /*! Processes all armed time events at every clock tick. */
S    void QF_tickX_(uint_fast8_t const tickRate, void const * const sender);
S
S    /*! Invoke the system clock tick processing QF_tickX_(). */
S    /**
S    * \description
S    * This macro is the recommended way of invoking clock tick processing,
S    * because it provides the vital information for software tracing and
S    * avoids any overhead when the tracing is disabled.
S    *
S    * \arguments
S    * \arg[in] \c tickRate clock tick rate to be serviced through this call
S    * \arg[in] \c sender   pointer to the sender object. This argument
S    *            is actually only used when QS software tracing is enabled
S    *            (macro #Q_SPY is defined)
S    * \note
S    * When QS software tracing is disabled, the macro calls QF_tickX_()
S    * without the \c sender argument, so the overhead of passing this
S    * extra argument is entirely avoided.
S    *
S    * \note
S    * The pointer to the sender object is not necessarily a pointer
S    * to an active object. In fact, when #QF_TICK_X() is called from
S    * an interrupt, you would create a unique object just to unambiguously
S    * identify the ISR as the sender of the time events.
S    *
S    * \sa QF_tickX_().
S    */
S    #define QF_TICK_X(tickRate_, sender_) (QF_tickX_((tickRate_), (sender_)))
S
N#else
N
N    void QF_tickX_(uint_fast8_t const tickRate);
N    #define QF_TICK_X(tickRate_, dummy)   (QF_tickX_(tickRate_))
N
N#endif
N
N/*! Invoke the system clock tick processing for rate 0 */
N#define QF_TICK(sender_)   QF_TICK_X((uint_fast8_t)0, (sender_))
N
N/*! Returns 'true' if there are no armed time events at a given tick rate */
Nbool QF_noTimeEvtsActiveX(uint_fast8_t const tickRate);
X_Bool QF_noTimeEvtsActiveX(uint_fast8_t const tickRate);
N
N/*! Register an active object to be managed by the framework */
Nvoid QF_add_(QActive * const a);
N
N/*! Remove the active object from the framework. */
Nvoid QF_remove_(QActive const * const a);
N
N/*! Obtain the minimum of free entries of the given event pool. */
Nuint_fast16_t QF_getPoolMin(uint_fast8_t const poolId);
N
N/*! This function returns the minimum of free entries of
N* the given event queue. */
Nuint_fast16_t QF_getQueueMin(uint_fast8_t const prio);
N
N/*! Internal QP implementation of the dynamic event allocator. */
NQEvt *QF_newX_(uint_fast16_t const evtSize,
N               uint_fast16_t const margin, enum_t const sig);
N
N#ifdef Q_EVT_CTOR /* Shall the constructor for the QEvt class be provided? */
S
S    #define Q_NEW(evtT_, sig_, ...) \
S        (evtT_##_ctor((evtT_ *)QF_newX_((uint_fast16_t)sizeof(evtT_), \
S                      (uint_fast16_t)0, (enum_t)0), (sig_), ##__VA_ARGS__))
X    #define Q_NEW(evtT_, sig_, ...)         (evtT_##_ctor((evtT_ *)QF_newX_((uint_fast16_t)sizeof(evtT_),                       (uint_fast16_t)0, (enum_t)0), (sig_), ##__VA_ARGS__))
S
S    #define Q_NEW_X(e_, evtT_, margin_, sig_, ...) do { \
S        (e_) = (evtT_ *)QF_newX_((uint_fast16_t)sizeof(evtT_), \
S                                 (margin_), (enum_t)0); \
S        if ((e_) != (evtT_ *)0) { \
S            evtT_##_ctor((e_), (sig_), ##__VA_ARGS__); \
S        } \
S     } while (0)
X    #define Q_NEW_X(e_, evtT_, margin_, sig_, ...) do {         (e_) = (evtT_ *)QF_newX_((uint_fast16_t)sizeof(evtT_),                                  (margin_), (enum_t)0);         if ((e_) != (evtT_ *)0) {             evtT_##_ctor((e_), (sig_), ##__VA_ARGS__);         }      } while (0)
S
N#else
N
N    /*! Allocate a dynamic event. */
N    /**
N    * \description
N    * The macro calls the internal QF function QF::newX_() with
N    * margin == 0, which causes an assertion when the event cannot be
N    * successfully allocated.
N    *
N    * \arguments
N    * \arg[in] \c evtT_ event type (class name) of the event to allocate
N    * \arg[in] \c sig_  signal to assign to the newly allocated event
N    *
N    * \returns a valid event pointer cast to the type \a evtT_.
N    *
N    * \note
N    * If #Q_EVT_CTOR is defined, the Q_NEW() macro becomes variadic and
N    * takes all the arguments needed by the constructor of the event
N    * class being allocated. The constructor is then called by means
N    * of the placement-new operator.
N    *
N    * \usage
N    * The following example illustrates dynamic allocation of an event:
N    * \include qf_post.c
N    */
N    #define Q_NEW(evtT_, sig_) \
N        ((evtT_ *)QF_newX_((uint_fast16_t)sizeof(evtT_), \
N                           (uint_fast16_t)0, (sig_)))
X    #define Q_NEW(evtT_, sig_)         ((evtT_ *)QF_newX_((uint_fast16_t)sizeof(evtT_),                            (uint_fast16_t)0, (sig_)))
N
N    /*! Allocate a dynamic event (non-asserting version). */
N    /**
N    * \description
N    * \description
N    * This macro allocates a new event and sets the pointer \a e_, while
N    * leaving at least \a margin_ of events still available in the pool
N    *
N    * \arguments
N    * \arg[in] \c evtT_   event type (class name) of the event to allocate
N    * \arg[in] \c margin_ number of events that must remain available
N    *                     in the given pool after this allocation
N    * \arg[in] \c sig_    signal to assign to the newly allocated event
N    *
N    * \returns an event pointer cast to the type \a evtT_ or NULL if the
N    * event cannot be allocated with the specified \a margin.
N    *
N    * \note
N    * If #Q_EVT_CTOR is defined, the Q_NEW_X() macro becomes variadic and
N    * takes all the arguments needed by the constructor of the event
N    * class being allocated. The constructor is then called and all the
N    * extra arguments are passed to it.
N    *
N    * \usage
N    * The following example illustrates dynamic allocation of an event:
N    * \include qf_postx.c
N    */
N    #define Q_NEW_X(e_, evtT_, margin_, sig_) ((e_) = \
N        (evtT_ *)QF_newX_((uint_fast16_t)sizeof(evtT_), (margin_), (sig_)))
X    #define Q_NEW_X(e_, evtT_, margin_, sig_) ((e_) =         (evtT_ *)QF_newX_((uint_fast16_t)sizeof(evtT_), (margin_), (sig_)))
N
N#endif /* Q_EVT_CTOR */
N
N
N/*! Recycle a dynamic event. */
Nvoid QF_gc(QEvt const * const e);
N
N/*! Clear a specified region of memory to zero. */
Nvoid QF_bzero(void * const start, uint_fast16_t len);
N
N#ifndef QF_CRIT_EXIT_NOP
N    /*! No-operation for exiting a critical section */
N    /**
N    * \description
N    * In some QF ports the critical section exit takes effect only on the
N    * next machine instruction. If this next instruction is another entry
N    * to a critical section, the critical section won't be really exited,
N    * but rather the two adjacent critical sections would be merged.
N    * The #QF_CRIT_EXIT_NOP() macro contains minimal code required to
N    * prevent such merging of critical sections in QF ports, in which it
N    * can occur.
N    */
N    #define QF_CRIT_EXIT_NOP()   ((void)0)
N#endif
N
N/****************************************************************************/
N/* Useful lookup tables ...*/
N/*! Lookup table for \c (1 << ((n-1) % 8)), where n is the index into
N* the table. */
N/**
N* \note Index range n = 0..64. The first index (n == 0) should never be used.
N*/
Nextern uint8_t const Q_ROM QF_pwr2Lkup[65];
Xextern uint8_t const  QF_pwr2Lkup[65];
N
N/*! Lookup table for \c ~(1 << ((n-1) % 8)), where n is the index
N* into the table. */
N/**
N* \note Index range n = 0..64. The first index (n == 0) should never be used.
N*/
Nextern uint8_t const Q_ROM QF_invPwr2Lkup[65];
Xextern uint8_t const  QF_invPwr2Lkup[65];
N
N/*! Lookup table for \c (n-1)/8 , where n is the index into the table. */
N/**
N* \note Index range n = 0..64. The first index (n == 0) should never be used.
N*/
Nextern uint8_t const Q_ROM QF_div8Lkup[65];
Xextern uint8_t const  QF_div8Lkup[65];
N
N/* Log-base-2 calculations ...*/
N#ifndef QF_LOG2
N
N    /*! Macro to return (log2(n_) + 1), where \a n_ = 0..255. */
N    /**
N    * \description
N    * This macro delivers the 1-based number of the most significant 1-bit
N    * of a byte. This macro can be re-implemented in the QP ports, if the CPU
N    * supports special instructions, such as CLZ (count leading zeros).
N    *
N    * If the macro is not defined in the port, the default implementation
N    * uses a lookup table.
N    */
N    #define QF_LOG2(n_) (Q_ROM_BYTE(QF_log2Lkup[(n_)]))
N
N    /*! Lookup table for (log2(n) + 1), where n is the index into the table */
N    /**
N    * \description
N    * This lookup delivers the 1-based number of the most significant 1-bit
N    * of a byte.
N    */
N    extern uint8_t const Q_ROM QF_log2Lkup[256];
X    extern uint8_t const  QF_log2Lkup[256];
N
N    #define QF_LOG2LKUP 1
N
N#endif /* QF_LOG2 */
N
N/*! array of registered active objects */
N/**
N* \note Not to be used by Clients directly, only in ports of QF
N*/
Nextern QActive *QF_active_[QF_MAX_ACTIVE + 1];
Xextern QActive *QF_active_[8 + 1];
N
N/****************************************************************************/
N/*! Returns the QF version. */
N/**
N* \description
N* version of QF as a constant 5-character string of the form X.Y.Z,
N* where X is a 1-digit major version number, Y is a 1-digit minor
N* version number, and Z is a 1-digit release number.
N*/
N#define QF_getVersion() (QP_VERSION_STR)
N
N#endif /* qf_h */
N
N
L 55 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil\qf_port.h" 2
N
N#endif                                                         /* qf_port_h */
L 43 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\qf\source\qf_log2.c" 2
N
N#ifdef QF_LOG2LKUP
N
N/* Global objects ***********************************************************/
Nuint8_t const Q_ROM QF_log2Lkup[256] = {
Xuint8_t const  QF_log2Lkup[256] = {
N    (uint8_t)0, (uint8_t)1, (uint8_t)2, (uint8_t)2,
N    (uint8_t)3, (uint8_t)3, (uint8_t)3, (uint8_t)3,
N    (uint8_t)4, (uint8_t)4, (uint8_t)4, (uint8_t)4,
N    (uint8_t)4, (uint8_t)4, (uint8_t)4, (uint8_t)4,
N    (uint8_t)5, (uint8_t)5, (uint8_t)5, (uint8_t)5,
N    (uint8_t)5, (uint8_t)5, (uint8_t)5, (uint8_t)5,
N    (uint8_t)5, (uint8_t)5, (uint8_t)5, (uint8_t)5,
N    (uint8_t)5, (uint8_t)5, (uint8_t)5, (uint8_t)5,
N    (uint8_t)6, (uint8_t)6, (uint8_t)6, (uint8_t)6,
N    (uint8_t)6, (uint8_t)6, (uint8_t)6, (uint8_t)6,
N    (uint8_t)6, (uint8_t)6, (uint8_t)6, (uint8_t)6,
N    (uint8_t)6, (uint8_t)6, (uint8_t)6, (uint8_t)6,
N    (uint8_t)6, (uint8_t)6, (uint8_t)6, (uint8_t)6,
N    (uint8_t)6, (uint8_t)6, (uint8_t)6, (uint8_t)6,
N    (uint8_t)6, (uint8_t)6, (uint8_t)6, (uint8_t)6,
N    (uint8_t)6, (uint8_t)6, (uint8_t)6, (uint8_t)6,
N    (uint8_t)7, (uint8_t)7, (uint8_t)7, (uint8_t)7,
N    (uint8_t)7, (uint8_t)7, (uint8_t)7, (uint8_t)7,
N    (uint8_t)7, (uint8_t)7, (uint8_t)7, (uint8_t)7,
N    (uint8_t)7, (uint8_t)7, (uint8_t)7, (uint8_t)7,
N    (uint8_t)7, (uint8_t)7, (uint8_t)7, (uint8_t)7,
N    (uint8_t)7, (uint8_t)7, (uint8_t)7, (uint8_t)7,
N    (uint8_t)7, (uint8_t)7, (uint8_t)7, (uint8_t)7,
N    (uint8_t)7, (uint8_t)7, (uint8_t)7, (uint8_t)7,
N    (uint8_t)7, (uint8_t)7, (uint8_t)7, (uint8_t)7,
N    (uint8_t)7, (uint8_t)7, (uint8_t)7, (uint8_t)7,
N    (uint8_t)7, (uint8_t)7, (uint8_t)7, (uint8_t)7,
N    (uint8_t)7, (uint8_t)7, (uint8_t)7, (uint8_t)7,
N    (uint8_t)7, (uint8_t)7, (uint8_t)7, (uint8_t)7,
N    (uint8_t)7, (uint8_t)7, (uint8_t)7, (uint8_t)7,
N    (uint8_t)7, (uint8_t)7, (uint8_t)7, (uint8_t)7,
N    (uint8_t)7, (uint8_t)7, (uint8_t)7, (uint8_t)7,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8,
N    (uint8_t)8, (uint8_t)8, (uint8_t)8, (uint8_t)8
N};
N
N#endif /* #ifdef QF_LOG2LKUP */
N
