; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\qa_get_.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\qa_get_.d --apcs=interwork -O0 --diag_suppress=9931 -I.\bombqmbsp -I..\..\..\..\..\..\..\CPU_Platforms\ARM\ARM7\MCB2300\include -I..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil -I..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include -I.\src -I.\src\coffee -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\Philips -D__MICROLIB -DQM_TICK -DQM_ActiveObject --omf_browse=.\obj\qa_get_.crf ..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\qf\source\qa_get_.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  QActive_get_ PROC
;;;71     */
;;;72     QEvt const *QActive_get_(QActive * const me) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
;;;73         QEQueueCtr nFree;
;;;74         QEvt const *e;
;;;75         QF_CRIT_STAT_
;;;76         QF_CRIT_ENTRY_();
000008  ef0000fe          SVC      #0xfe
;;;77     
;;;78         QACTIVE_EQUEUE_WAIT_(me);  /* wait for event to arrive directly */
00000c  e594000c          LDR      r0,[r4,#0xc]
000010  e3500000          CMP      r0,#0
000014  0a000000          BEQ      |L1.28|
000018  ea000002          B        |L1.40|
                  |L1.28|
00001c  e3a01000          MOV      r1,#0
000020  e59f00f8          LDR      r0,|L1.288|
000024  ebfffffe          BL       Q_onAssert
                  |L1.40|
;;;79     
;;;80         e = me->eQueue.frontEvt; /* always remove event from the front location */
000028  e594600c          LDR      r6,[r4,#0xc]
;;;81         nFree= me->eQueue.nFree + (QEQueueCtr)1; /* get volatile into tmp */
00002c  e5940020          LDR      r0,[r4,#0x20]
000030  e2805001          ADD      r5,r0,#1
;;;82         me->eQueue.nFree = nFree; /* update the number of free */
000034  e5845020          STR      r5,[r4,#0x20]
;;;83     
;;;84         /* any events in the ring buffer? */
;;;85         if (nFree <= me->eQueue.end) {
000038  e5940014          LDR      r0,[r4,#0x14]
00003c  e1500005          CMP      r0,r5
000040  3a00000c          BCC      |L1.120|
;;;86     
;;;87             /* remove event from the tail */
;;;88             me->eQueue.frontEvt = QF_PTR_AT_(me->eQueue.ring, me->eQueue.tail);
000044  e5940010          LDR      r0,[r4,#0x10]
000048  e594101c          LDR      r1,[r4,#0x1c]
00004c  e7900101          LDR      r0,[r0,r1,LSL #2]
000050  e584000c          STR      r0,[r4,#0xc]
;;;89             if (me->eQueue.tail == (QEQueueCtr)0) { /* need to wrap the tail? */
000054  e594001c          LDR      r0,[r4,#0x1c]
000058  e3500000          CMP      r0,#0
00005c  1a000001          BNE      |L1.104|
;;;90                 me->eQueue.tail = me->eQueue.end;   /* wrap around */
000060  e5940014          LDR      r0,[r4,#0x14]
000064  e584001c          STR      r0,[r4,#0x1c]
                  |L1.104|
;;;91             }
;;;92             --me->eQueue.tail;
000068  e594001c          LDR      r0,[r4,#0x1c]
00006c  e2400001          SUB      r0,r0,#1
000070  e584001c          STR      r0,[r4,#0x1c]
000074  ea000011          B        |L1.192|
                  |L1.120|
;;;93     
;;;94             QS_BEGIN_NOCRIT_(QS_QF_ACTIVE_GET, QS_priv_.aoObjFilter, me)
;;;95                 QS_TIME_();                   /* timestamp */
;;;96                 QS_SIG_(e->sig);              /* the signal of this event */
;;;97                 QS_OBJ_(me);                  /* this active object */
;;;98                 QS_2U8_(e->poolId_, e->refCtr_); /* pool Id & ref Count */
;;;99                 QS_EQC_(nFree);               /* number of free entries */
;;;100            QS_END_NOCRIT_()
;;;101        }
;;;102        else {
;;;103            me->eQueue.frontEvt = (QEvt const *)0; /* queue becomes empty */
000078  e3a00000          MOV      r0,#0
00007c  e584000c          STR      r0,[r4,#0xc]
;;;104    
;;;105            /* all entries in the queue must be free (+1 for fronEvt) */
;;;106            Q_ASSERT_ID(110, nFree == (me->eQueue.end + (QEQueueCtr)1));
000080  e5940014          LDR      r0,[r4,#0x14]
000084  e2800001          ADD      r0,r0,#1
000088  e1500005          CMP      r0,r5
00008c  1a000000          BNE      |L1.148|
000090  ea000002          B        |L1.160|
                  |L1.148|
000094  e3a0106e          MOV      r1,#0x6e
000098  e59f0080          LDR      r0,|L1.288|
00009c  ebfffffe          BL       Q_onAssert
                  |L1.160|
;;;107    
;;;108            QACTIVE_EQUEUE_ONEMPTY_(me);
0000a0  e59f007c          LDR      r0,|L1.292|
0000a4  e5900000          LDR      r0,[r0,#0]  ; QF_readySet_
0000a8  e59f2078          LDR      r2,|L1.296|
0000ac  e5941028          LDR      r1,[r4,#0x28]
0000b0  e7d21001          LDRB     r1,[r2,r1]
0000b4  e0000001          AND      r0,r0,r1
0000b8  e59f1064          LDR      r1,|L1.292|
0000bc  e5810000          STR      r0,[r1,#0]  ; QF_readySet_
                  |L1.192|
;;;109    
;;;110            QS_BEGIN_NOCRIT_(QS_QF_ACTIVE_GET_LAST, QS_priv_.aoObjFilter, me)
;;;111                QS_TIME_();                   /* timestamp */
;;;112                QS_SIG_(e->sig);              /* the signal of this event */
;;;113                QS_OBJ_(me);                  /* this active object */
;;;114                QS_2U8_(e->poolId_, e->refCtr_); /* pool Id & ref Count */
;;;115            QS_END_NOCRIT_()
;;;116        }
;;;117        QF_CRIT_EXIT_();
0000c0  ef0000ff          SVC      #0xff
;;;118        return e;
0000c4  e1a00006          MOV      r0,r6
0000c8  e8bd4070          POP      {r4-r6,lr}
;;;119    }
0000cc  e12fff1e          BX       lr
;;;120    
                          ENDP

                  QF_getQueueMin PROC
;;;139    */
;;;140    uint_fast16_t QF_getQueueMin(uint_fast8_t const prio) {
0000d0  e92d4070          PUSH     {r4-r6,lr}
0000d4  e1a04000          MOV      r4,r0
;;;141        uint_fast16_t min;
;;;142        QF_CRIT_STAT_
;;;143    
;;;144        Q_REQUIRE_ID(200, (prio <= (uint_fast8_t)QF_MAX_ACTIVE)
0000d8  e3540008          CMP      r4,#8
0000dc  8a000004          BHI      |L1.244|
0000e0  e59f0044          LDR      r0,|L1.300|
0000e4  e7900104          LDR      r0,[r0,r4,LSL #2]
0000e8  e3500000          CMP      r0,#0
0000ec  0a000000          BEQ      |L1.244|
0000f0  ea000002          B        |L1.256|
                  |L1.244|
0000f4  e3a010c8          MOV      r1,#0xc8
0000f8  e59f0020          LDR      r0,|L1.288|
0000fc  ebfffffe          BL       Q_onAssert
                  |L1.256|
;;;145                          && (QF_active_[prio] != (QActive *)0));
;;;146    
;;;147        QF_CRIT_ENTRY_();
000100  ef0000fe          SVC      #0xfe
;;;148        min = (uint_fast16_t)QF_active_[prio]->eQueue.nMin;
000104  e59f0020          LDR      r0,|L1.300|
000108  e7900104          LDR      r0,[r0,r4,LSL #2]
00010c  e5905024          LDR      r5,[r0,#0x24]
;;;149        QF_CRIT_EXIT_();
000110  ef0000ff          SVC      #0xff
;;;150    
;;;151        return min;
000114  e1a00005          MOV      r0,r5
000118  e8bd4070          POP      {r4-r6,lr}
;;;152    }
00011c  e12fff1e          BX       lr
                          ENDP

                  |L1.288|
                          DCD      Q_this_module_
                  |L1.292|
                          DCD      QF_readySet_
                  |L1.296|
                          DCD      QF_invPwr2Lkup
                  |L1.300|
                          DCD      QF_active_

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  Q_this_module_
000000  71615f67          DCB      0x71,0x61,0x5f,0x67
000004  65745f00          DCB      0x65,0x74,0x5f,0x00
