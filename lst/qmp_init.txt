; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\qmp_init.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\qmp_init.d --apcs=interwork -O0 --diag_suppress=9931 -I.\bombqmbsp -I..\..\..\..\..\..\..\CPU_Platforms\ARM\ARM7\MCB2300\include -I..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil -I..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include -I.\src -I.\src\coffee -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\Philips -D__MICROLIB -DQM_TICK -DQM_ActiveObject --omf_browse=.\obj\qmp_init.crf ..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\qf\source\qmp_init.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  QMPool_init PROC
;;;82     */
;;;83     void QMPool_init(QMPool * const me, void * const poolSto,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;84                      uint_fast16_t poolSize, uint_fast16_t blockSize)
;;;85     {
000004  e1a04000          MOV      r4,r0
000008  e1a08001          MOV      r8,r1
00000c  e1a06002          MOV      r6,r2
000010  e1a05003          MOV      r5,r3
;;;86         QFreeBlock *fb;
;;;87         uint_fast16_t nblocks;
;;;88         QS_CRIT_STAT_
;;;89     
;;;90         /** \pre The memory block must be valid
;;;91         * and the poolSize must fit at least one free block
;;;92         * and the blockSize must not be too close to the top of the dynamic range
;;;93         */
;;;94         Q_REQUIRE_ID(100, (poolSto != (void *)0)
000014  e3580000          CMP      r8,#0
000018  0a000005          BEQ      |L1.52|
00001c  e3560004          CMP      r6,#4
000020  3a000003          BCC      |L1.52|
000024  e2850004          ADD      r0,r5,#4
000028  e1500005          CMP      r0,r5
00002c  9a000000          BLS      |L1.52|
000030  ea000002          B        |L1.64|
                  |L1.52|
000034  e3a01064          MOV      r1,#0x64
000038  e59f00bc          LDR      r0,|L1.252|
00003c  ebfffffe          BL       Q_onAssert
                  |L1.64|
;;;95                   && (poolSize >= (uint_fast16_t)sizeof(QFreeBlock))
;;;96                   && ((uint_fast16_t)(blockSize
;;;97                        + (uint_fast16_t)sizeof(QFreeBlock)) > blockSize));
;;;98     
;;;99         me->free_head = poolSto;
000040  e5848000          STR      r8,[r4,#0]
;;;100    
;;;101        /* round up the blockSize to fit an integer # free blocks, no division */
;;;102        me->blockSize = (QMPoolSize)sizeof(QFreeBlock);  /* start with just one */
000044  e3a00004          MOV      r0,#4
000048  e1c400bc          STRH     r0,[r4,#0xc]
;;;103        nblocks = (uint_fast16_t)1;/* #free blocks that fit in one memory block */
00004c  e3a09001          MOV      r9,#1
;;;104        while (me->blockSize < (QMPoolSize)blockSize) {
000050  ea000004          B        |L1.104|
                  |L1.84|
;;;105            me->blockSize += (QMPoolSize)sizeof(QFreeBlock);
000054  e1d400bc          LDRH     r0,[r4,#0xc]
000058  e2800004          ADD      r0,r0,#4
00005c  e3c00801          BIC      r0,r0,#0x10000
000060  e1c400bc          STRH     r0,[r4,#0xc]
;;;106            ++nblocks;
000064  e2899001          ADD      r9,r9,#1
                  |L1.104|
000068  e1d400bc          LDRH     r0,[r4,#0xc]          ;104
00006c  e1a01805          LSL      r1,r5,#16             ;104
000070  e1a01821          LSR      r1,r1,#16             ;104
000074  e1500001          CMP      r0,r1                 ;104
000078  bafffff5          BLT      |L1.84|
;;;107        }
;;;108        blockSize = (uint_fast16_t)me->blockSize; /* round-up to nearest block */
00007c  e1d450bc          LDRH     r5,[r4,#0xc]
;;;109    
;;;110        /* the pool buffer must fit at least one rounded-up block */
;;;111        Q_ASSERT_ID(110, poolSize >= blockSize);
000080  e1560005          CMP      r6,r5
000084  3a000000          BCC      |L1.140|
000088  ea000002          B        |L1.152|
                  |L1.140|
00008c  e3a0106e          MOV      r1,#0x6e
000090  e59f0064          LDR      r0,|L1.252|
000094  ebfffffe          BL       Q_onAssert
                  |L1.152|
;;;112    
;;;113        /* chain all blocks together in a free-list... */
;;;114        poolSize -= blockSize;       /* don't count the last block */
000098  e0466005          SUB      r6,r6,r5
;;;115        me->nTot  = (QMPoolCtr)1;    /* the last block already in the pool */
00009c  e3a00001          MOV      r0,#1
0000a0  e1c400be          STRH     r0,[r4,#0xe]
;;;116        fb = (QFreeBlock *)me->free_head; /* start at the head of the free list */
0000a4  e5947000          LDR      r7,[r4,#0]
;;;117    
;;;118        /* chain all blocks together in a free-list... */
;;;119        while (poolSize >= blockSize) {
0000a8  ea000007          B        |L1.204|
                  |L1.172|
;;;120            fb->next = &QF_PTR_AT_(fb, nblocks);/*point next link to next block */
0000ac  e0870109          ADD      r0,r7,r9,LSL #2
0000b0  e5870000          STR      r0,[r7,#0]
;;;121            fb = fb->next;           /* advance to the next block */
0000b4  e5977000          LDR      r7,[r7,#0]
;;;122            poolSize -= blockSize;   /* reduce the available pool size */
0000b8  e0466005          SUB      r6,r6,r5
;;;123            ++me->nTot;              /* increment the number of blocks so far */
0000bc  e1d400be          LDRH     r0,[r4,#0xe]
0000c0  e2800001          ADD      r0,r0,#1
0000c4  e3c00801          BIC      r0,r0,#0x10000
0000c8  e1c400be          STRH     r0,[r4,#0xe]
                  |L1.204|
0000cc  e1560005          CMP      r6,r5                 ;119
0000d0  2afffff5          BCS      |L1.172|
;;;124        }
;;;125    
;;;126        fb->next  = (QFreeBlock *)0; /* the last link points to NULL */
0000d4  e3a00000          MOV      r0,#0
0000d8  e5870000          STR      r0,[r7,#0]
;;;127        me->nFree = me->nTot;        /* all blocks are free */
0000dc  e1d400be          LDRH     r0,[r4,#0xe]
0000e0  e1c401b0          STRH     r0,[r4,#0x10]
;;;128        me->nMin  = me->nTot;        /* the minimum number of free blocks */
0000e4  e1d400be          LDRH     r0,[r4,#0xe]
0000e8  e1c401b2          STRH     r0,[r4,#0x12]
;;;129        me->start = poolSto;         /* the original start this pool buffer */
0000ec  e5848004          STR      r8,[r4,#4]
;;;130        me->end   = fb;              /* the last block in this pool */
0000f0  e5847008          STR      r7,[r4,#8]
;;;131    
;;;132        QS_BEGIN_(QS_QF_MPOOL_INIT, QS_priv_.mpObjFilter, me->start)
;;;133            QS_OBJ_(me->start);      /* the memory managed by this pool */
;;;134            QS_MPC_(me->nTot);       /* the total number of blocks */
;;;135        QS_END_()
;;;136    }
0000f4  e8bd47f0          POP      {r4-r10,lr}
0000f8  e12fff1e          BX       lr
;;;137    
                          ENDP

                  |L1.252|
                          DCD      Q_this_module_

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  Q_this_module_
000000  716d705f          DCB      0x71,0x6d,0x70,0x5f
000004  696e6974          DCB      0x69,0x6e,0x69,0x74
000008  00                DCB      0x00
