; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\qmp_get.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\qmp_get.d --apcs=interwork -O0 --diag_suppress=9931 -I.\bombqmbsp -I..\..\..\..\..\..\..\CPU_Platforms\ARM\ARM7\MCB2300\include -I..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil -I..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include -I.\src -I.\src\coffee -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\Philips -D__MICROLIB -DQM_TICK -DQM_ActiveObject --omf_browse=.\obj\qmp_get.crf ..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\qf\source\qmp_get.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  QMPool_get PROC
;;;76     */
;;;77     void *QMPool_get(QMPool * const me, uint_fast16_t const margin) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a07001          MOV      r7,r1
;;;78         QFreeBlock *fb;
;;;79         QF_CRIT_STAT_
;;;80     
;;;81         QF_CRIT_ENTRY_();
00000c  ef0000fe          SVC      #0xfe
;;;82     
;;;83         /* have more free blocks than the requested margin? */
;;;84         if (me->nFree > (QMPoolCtr)margin) {
000010  e1d401b0          LDRH     r0,[r4,#0x10]
000014  e1a01807          LSL      r1,r7,#16
000018  e1a01821          LSR      r1,r1,#16
00001c  e1500001          CMP      r0,r1
000020  da000028          BLE      |L1.200|
;;;85             void *fb_next;
;;;86             fb = (QFreeBlock *)me->free_head; /* get a free block */
000024  e5945000          LDR      r5,[r4,#0]
;;;87     
;;;88             /* the pool has some free blocks, so a free block must be available */
;;;89             Q_ASSERT_ID(110, fb != (QFreeBlock *)0);
000028  e3550000          CMP      r5,#0
00002c  0a000000          BEQ      |L1.52|
000030  ea000002          B        |L1.64|
                  |L1.52|
000034  e3a0106e          MOV      r1,#0x6e
000038  e59f00f4          LDR      r0,|L1.308|
00003c  ebfffffe          BL       Q_onAssert
                  |L1.64|
;;;90     
;;;91             fb_next = fb->next; /* put volatile to a temporary to avoid UB */
000040  e5956000          LDR      r6,[r5,#0]
;;;92     
;;;93             /* is the pool becoming empty? */
;;;94             --me->nFree; /* one less free block */
000044  e1d401b0          LDRH     r0,[r4,#0x10]
000048  e2400001          SUB      r0,r0,#1
00004c  e1c401b0          STRH     r0,[r4,#0x10]
;;;95             if (me->nFree == (QMPoolCtr)0) {
000050  e1d401b0          LDRH     r0,[r4,#0x10]
000054  e3500000          CMP      r0,#0
000058  1a000008          BNE      |L1.128|
;;;96                 /* pool is becoming empty, so the next free block must be NULL */
;;;97                 Q_ASSERT_ID(120, fb_next == (QFreeBlock *)0);
00005c  e3560000          CMP      r6,#0
000060  1a000000          BNE      |L1.104|
000064  ea000002          B        |L1.116|
                  |L1.104|
000068  e3a01078          MOV      r1,#0x78
00006c  e59f00c0          LDR      r0,|L1.308|
000070  ebfffffe          BL       Q_onAssert
                  |L1.116|
;;;98     
;;;99                 me->nMin = (QMPoolCtr)0; /* remember that the pool got empty */
000074  e3a00000          MOV      r0,#0
000078  e1c401b2          STRH     r0,[r4,#0x12]
00007c  ea00000f          B        |L1.192|
                  |L1.128|
;;;100            }
;;;101            else {
;;;102                /* pool is not empty, so the next free block must be in range
;;;103                *
;;;104                * NOTE: the next free block pointer can fall out of range
;;;105                * when the client code writes past the memory block, thus
;;;106                * corrupting the next block.
;;;107                */
;;;108                Q_ASSERT_ID(130, QF_PTR_RANGE_(fb_next, me->start, me->end));
000080  e5940004          LDR      r0,[r4,#4]
000084  e1500006          CMP      r0,r6
000088  8a000003          BHI      |L1.156|
00008c  e5940008          LDR      r0,[r4,#8]
000090  e1500006          CMP      r0,r6
000094  3a000000          BCC      |L1.156|
000098  ea000002          B        |L1.168|
                  |L1.156|
00009c  e3a01082          MOV      r1,#0x82
0000a0  e59f008c          LDR      r0,|L1.308|
0000a4  ebfffffe          BL       Q_onAssert
                  |L1.168|
;;;109    
;;;110                /* is the number of free blocks the new minimum so far? */
;;;111                if (me->nMin > me->nFree) {
0000a8  e1d401b2          LDRH     r0,[r4,#0x12]
0000ac  e1d411b0          LDRH     r1,[r4,#0x10]
0000b0  e1500001          CMP      r0,r1
0000b4  da000001          BLE      |L1.192|
;;;112                    me->nMin = me->nFree; /* remember the new minimum */
0000b8  e1d401b0          LDRH     r0,[r4,#0x10]
0000bc  e1c401b2          STRH     r0,[r4,#0x12]
                  |L1.192|
;;;113                }
;;;114            }
;;;115    
;;;116            me->free_head = fb_next; /* set the head to the next free block */
0000c0  e5846000          STR      r6,[r4,#0]
;;;117    
;;;118            QS_BEGIN_NOCRIT_(QS_QF_MPOOL_GET, QS_priv_.mpObjFilter, me->start)
;;;119                QS_TIME_();         /* timestamp */
;;;120                QS_OBJ_(me->start); /* the memory managed by this pool */
;;;121                QS_MPC_(me->nFree); /* # of free blocks in the pool */
;;;122                QS_MPC_(me->nMin);  /* min # free blocks ever in the pool */
;;;123            QS_END_NOCRIT_()
;;;124    
;;;125        }
0000c4  ea000000          B        |L1.204|
                  |L1.200|
;;;126        /* don't have enough free blocks at this point */
;;;127        else {
;;;128            fb = (QFreeBlock *)0;
0000c8  e3a05000          MOV      r5,#0
                  |L1.204|
;;;129    
;;;130            QS_BEGIN_NOCRIT_(QS_QF_MPOOL_GET_ATTEMPT,
;;;131                             QS_priv_.mpObjFilter, me->start)
;;;132                QS_TIME_();         /* timestamp */
;;;133                QS_OBJ_(me->start); /* the memory managed by this pool */
;;;134                QS_MPC_(me->nFree); /* the number of free blocks in the pool */
;;;135                QS_MPC_(margin);    /* the requested margin */
;;;136            QS_END_NOCRIT_()
;;;137        }
;;;138        QF_CRIT_EXIT_();
0000cc  ef0000ff          SVC      #0xff
;;;139    
;;;140        return fb;  /* return the pointer to memory block or NULL to the caller */
0000d0  e1a00005          MOV      r0,r5
0000d4  e8bd41f0          POP      {r4-r8,lr}
;;;141    }
0000d8  e12fff1e          BX       lr
;;;142    
                          ENDP

                  QF_getPoolMin PROC
;;;155    */
;;;156    uint_fast16_t QF_getPoolMin(uint_fast8_t const poolId) {
0000dc  e92d4070          PUSH     {r4-r6,lr}
0000e0  e1a04000          MOV      r4,r0
;;;157        uint_fast16_t min;
;;;158        QF_CRIT_STAT_
;;;159    
;;;160        /** \pre the poolId must be in range */
;;;161        Q_REQUIRE_ID(200, ((uint_fast8_t)1 <= poolId)
0000e4  e3540001          CMP      r4,#1
0000e8  3a000004          BCC      |L1.256|
0000ec  e59f0044          LDR      r0,|L1.312|
0000f0  e5900000          LDR      r0,[r0,#0]  ; QF_maxPool_
0000f4  e1540000          CMP      r4,r0
0000f8  8a000000          BHI      |L1.256|
0000fc  ea000002          B        |L1.268|
                  |L1.256|
000100  e3a010c8          MOV      r1,#0xc8
000104  e59f0028          LDR      r0,|L1.308|
000108  ebfffffe          BL       Q_onAssert
                  |L1.268|
;;;162                          && (poolId <= QF_maxPool_));
;;;163    
;;;164        QF_CRIT_ENTRY_();
00010c  ef0000fe          SVC      #0xfe
;;;165        min = (uint_fast16_t)QF_pool_[poolId - (uint_fast8_t)1].nMin;
000110  e2440001          SUB      r0,r4,#1
000114  e0800100          ADD      r0,r0,r0,LSL #2
000118  e59f101c          LDR      r1,|L1.316|
00011c  e0810100          ADD      r0,r1,r0,LSL #2
000120  e1d051b2          LDRH     r5,[r0,#0x12]
;;;166        QF_CRIT_EXIT_();
000124  ef0000ff          SVC      #0xff
;;;167    
;;;168        return min;
000128  e1a00005          MOV      r0,r5
00012c  e8bd4070          POP      {r4-r6,lr}
;;;169    }
000130  e12fff1e          BX       lr
                          ENDP

                  |L1.308|
                          DCD      Q_this_module_
                  |L1.312|
                          DCD      QF_maxPool_
                  |L1.316|
                          DCD      QF_pool_

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  Q_this_module_
000000  716d705f          DCB      0x71,0x6d,0x70,0x5f
000004  67657400          DCB      0x67,0x65,0x74,0x00
