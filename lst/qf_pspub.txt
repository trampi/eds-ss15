; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\qf_pspub.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\qf_pspub.d --apcs=interwork -O0 --diag_suppress=9931 -I.\bombqmbsp -I..\..\..\..\..\..\..\CPU_Platforms\ARM\ARM7\MCB2300\include -I..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil -I..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include -I.\src -I.\src\coffee -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\Philips -D__MICROLIB -DQM_TICK -DQM_ActiveObject --omf_browse=.\obj\qf_pspub.crf ..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\qf\source\qf_pspub.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  QF_publish_ PROC
;;;69     #ifndef Q_SPY
;;;70     void QF_publish_(QEvt const * const e)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;71     #else
;;;72     void QF_publish_(QEvt const * const e, void const * const sender)
;;;73     #endif
;;;74     {
000004  e1a04000          MOV      r4,r0
;;;75         QF_CRIT_STAT_
;;;76     
;;;77         /** \pre the published signal must be within the configured range */
;;;78         Q_REQUIRE_ID(100, e->sig < (QSignal)QF_maxSignal_);
000008  e1d400b0          LDRH     r0,[r4,#0]
00000c  e59f10c8          LDR      r1,|L1.220|
000010  e1d110b0          LDRH     r1,[r1,#0]  ; QF_maxSignal_
000014  e1a01801          LSL      r1,r1,#16
000018  e1a01821          LSR      r1,r1,#16
00001c  e1500001          CMP      r0,r1
000020  aa000000          BGE      |L1.40|
000024  ea000002          B        |L1.52|
                  |L1.40|
000028  e3a01064          MOV      r1,#0x64
00002c  e59f00ac          LDR      r0,|L1.224|
000030  ebfffffe          BL       Q_onAssert
                  |L1.52|
;;;79     
;;;80         QF_CRIT_ENTRY_();
000034  ef0000fe          SVC      #0xfe
;;;81     
;;;82         QS_BEGIN_NOCRIT_(QS_QF_PUBLISH, (void *)0, (void *)0)
;;;83             QS_TIME_();          /* the timestamp */
;;;84             QS_OBJ_(sender);     /* the sender object */
;;;85             QS_SIG_(e->sig);     /* the signal of the event */
;;;86             QS_2U8_(e->poolId_, e->refCtr_);/* pool Id & ref Count of the event */
;;;87         QS_END_NOCRIT_()
;;;88     
;;;89         /* is it a dynamic event? */
;;;90         if (e->poolId_ != (uint8_t)0) {
000038  e5d40002          LDRB     r0,[r4,#2]
00003c  e3500000          CMP      r0,#0
000040  0a000002          BEQ      |L1.80|
;;;91             QF_EVT_REF_CTR_INC_(e); /* increment reference counter, NOTE01 */
000044  e5d40003          LDRB     r0,[r4,#3]
000048  e2800001          ADD      r0,r0,#1
00004c  e5c40003          STRB     r0,[r4,#3]
                  |L1.80|
;;;92         }
;;;93         QF_CRIT_EXIT_();
000050  ef0000ff          SVC      #0xff
;;;94     
;;;95     #if (QF_MAX_ACTIVE <= 8)
;;;96         {
;;;97             uint8_t tmp = QF_subscrList_[e->sig].bits[0];
000054  e1d400b0          LDRH     r0,[r4,#0]
000058  e59f1084          LDR      r1,|L1.228|
00005c  e5911000          LDR      r1,[r1,#0]  ; QF_subscrList_
000060  e7d16000          LDRB     r6,[r1,r0]
;;;98             while (tmp != (uint8_t)0) {
000064  ea000016          B        |L1.196|
                  |L1.104|
;;;99                 uint8_t p = QF_LOG2(tmp);
000068  e59f0078          LDR      r0,|L1.232|
00006c  e7d05006          LDRB     r5,[r0,r6]
;;;100                tmp &= Q_ROM_BYTE(QF_invPwr2Lkup[p]); /* clear subscriber bit */
000070  e59f0074          LDR      r0,|L1.236|
000074  e7d00005          LDRB     r0,[r0,r5]
000078  e0066000          AND      r6,r6,r0
;;;101                /* the priority of the AO must be registered with the framework */
;;;102                Q_ASSERT_ID(110, QF_active_[p] != (QActive *)0);
00007c  e59f006c          LDR      r0,|L1.240|
000080  e7900105          LDR      r0,[r0,r5,LSL #2]
000084  e3500000          CMP      r0,#0
000088  0a000000          BEQ      |L1.144|
00008c  ea000002          B        |L1.156|
                  |L1.144|
000090  e3a0106e          MOV      r1,#0x6e
000094  e59f0044          LDR      r0,|L1.224|
000098  ebfffffe          BL       Q_onAssert
                  |L1.156|
;;;103    
;;;104                /* QACTIVE_POST() asserts internally if the queue overflows */
;;;105                QACTIVE_POST(QF_active_[p], e, sender);
00009c  e59f104c          LDR      r1,|L1.240|
0000a0  e7910105          LDR      r0,[r1,r5,LSL #2]
0000a4  e7911105          LDR      r1,[r1,r5,LSL #2]
0000a8  e5911000          LDR      r1,[r1,#0]
0000ac  e3a02000          MOV      r2,#0
0000b0  e591300c          LDR      r3,[r1,#0xc]
0000b4  e1a01004          MOV      r1,r4
0000b8  e1a0e00f          MOV      lr,pc
0000bc  e12fff13          BX       r3
;;;106            }
0000c0  e1a00000          MOV      r0,r0
                  |L1.196|
0000c4  e3560000          CMP      r6,#0                 ;98
0000c8  1affffe6          BNE      |L1.104|
;;;107        }
;;;108    #else
;;;109        {
;;;110            uint_fast8_t i = (uint_fast8_t)Q_DIM(QF_subscrList_[0].bits);
;;;111            /* go through all bytes in the subscription list */
;;;112            do {
;;;113                uint_fast8_t tmp;
;;;114                --i;
;;;115                tmp = (uint_fast8_t)QF_PTR_AT_(QF_subscrList_, e->sig).bits[i];
;;;116                while (tmp != (uint_fast8_t)0) {
;;;117                    uint_fast8_t p = (uint_fast8_t)QF_LOG2(tmp);
;;;118    
;;;119                    /* clear the subscriber bit */
;;;120                    tmp &= (uint_fast8_t)Q_ROM_BYTE(QF_invPwr2Lkup[p]);
;;;121                    p = (uint_fast8_t)p + (uint_fast8_t)(i << 3);/*adj priority */
;;;122    
;;;123                    /* the priority level be registered with the framework */
;;;124                    Q_ASSERT_ID(120, QF_active_[p] != (QActive *)0);
;;;125    
;;;126                    /* QACTIVE_POST() asserts internally if the queue overflows */
;;;127                    QACTIVE_POST(QF_active_[p], e, sender);
;;;128                }
;;;129            } while (i != (uint_fast8_t)0);
;;;130        }
;;;131    #endif
;;;132    
;;;133        /* run the garbage collector */
;;;134        QF_gc(e);
0000cc  e1a00004          MOV      r0,r4
0000d0  ebfffffe          BL       QF_gc
;;;135    
;;;136        /* NOTE: QF_publish_() increments the reference counter to prevent
;;;137        * premature recycling of the event while the multicasting is still
;;;138        * in progress. At the end of the function, the garbage collector step
;;;139        * decrements the reference counter and recycles the event if the
;;;140        * counter drops to zero. This covers the case when the event was
;;;141        * published without any subscribers.
;;;142        */
;;;143    }
0000d4  e8bd4070          POP      {r4-r6,lr}
0000d8  e12fff1e          BX       lr
                          ENDP

                  |L1.220|
                          DCD      QF_maxSignal_
                  |L1.224|
                          DCD      Q_this_module_
                  |L1.228|
                          DCD      QF_subscrList_
                  |L1.232|
                          DCD      QF_log2Lkup
                  |L1.236|
                          DCD      QF_invPwr2Lkup
                  |L1.240|
                          DCD      QF_active_

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  Q_this_module_
000000  71665f70          DCB      0x71,0x66,0x5f,0x70
000004  73707562          DCB      0x73,0x70,0x75,0x62
000008  00                DCB      0x00
