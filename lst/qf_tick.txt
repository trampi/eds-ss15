; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\qf_tick.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\qf_tick.d --apcs=interwork -O0 --diag_suppress=9931 -I.\bombqmbsp -I..\..\..\..\..\..\..\CPU_Platforms\ARM\ARM7\MCB2300\include -I..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil -I..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include -I.\src -I.\src\coffee -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\Philips -D__MICROLIB -DQM_TICK -DQM_ActiveObject --omf_browse=.\obj\qf_tick.crf ..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\qf\source\qf_tick.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  QF_tickX_ PROC
;;;75     #ifndef Q_SPY
;;;76     void QF_tickX_(uint_fast8_t const tickRate)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;77     #else
;;;78     void QF_tickX_(uint_fast8_t const tickRate, void const * const sender)
;;;79     #endif
;;;80     {
000004  e1a06000          MOV      r6,r0
;;;81         QTimeEvt *prev = &QF_timeEvtHead_[tickRate];
000008  e59f0190          LDR      r0,|L1.416|
00000c  e0805206          ADD      r5,r0,r6,LSL #4
;;;82         QF_CRIT_STAT_
;;;83     
;;;84         QF_CRIT_ENTRY_();
000010  ef0000fe          SVC      #0xfe
;;;85     
;;;86         QS_BEGIN_NOCRIT_(QS_QF_TICK, (void *)0, (void *)0)
;;;87             QS_TEC_((QTimeEvtCtr)(++prev->ctr)); /* tick ctr */
;;;88             QS_U8_((uint8_t)tickRate);           /* tick rate */
;;;89         QS_END_NOCRIT_()
;;;90     
;;;91         /* scan the linked-list of time events at this rate... */
;;;92         for (;;) {
000014  e1a00000          MOV      r0,r0
                  |L1.24|
;;;93             QTimeEvt *t = prev->next;  /* advance down the time evt. list */
000018  e5954004          LDR      r4,[r5,#4]
;;;94     
;;;95             /* end of the list? */
;;;96             if (t == (QTimeEvt *)0) {
00001c  e3540000          CMP      r4,#0
000020  1a000015          BNE      |L1.124|
;;;97     
;;;98                 /* ny newly armed time events? */
;;;99                 if (QF_timeEvtHead_[tickRate].act != (void *)0) {
000024  e59f0174          LDR      r0,|L1.416|
000028  e0800206          ADD      r0,r0,r6,LSL #4
00002c  e5900008          LDR      r0,[r0,#8]
000030  e3500000          CMP      r0,#0
000034  0a00000f          BEQ      |L1.120|
;;;100    
;;;101                    /* sanity check */
;;;102                    Q_ASSERT_ID(110, prev != (QTimeEvt *)0);
000038  e3550000          CMP      r5,#0
00003c  0a000000          BEQ      |L1.68|
000040  ea000002          B        |L1.80|
                  |L1.68|
000044  e3a0106e          MOV      r1,#0x6e
000048  e59f0154          LDR      r0,|L1.420|
00004c  ebfffffe          BL       Q_onAssert
                  |L1.80|
;;;103                    prev->next = (QTimeEvt *)QF_timeEvtHead_[tickRate].act;
000050  e59f0148          LDR      r0,|L1.416|
000054  e0800206          ADD      r0,r0,r6,LSL #4
000058  e5900008          LDR      r0,[r0,#8]
00005c  e5850004          STR      r0,[r5,#4]
;;;104                    QF_timeEvtHead_[tickRate].act = (void *)0;
000060  e3a00000          MOV      r0,#0
000064  e59f1134          LDR      r1,|L1.416|
000068  e0811206          ADD      r1,r1,r6,LSL #4
00006c  e5810008          STR      r0,[r1,#8]
;;;105                    t = prev->next;  /* switch to the new list */
000070  e5954004          LDR      r4,[r5,#4]
000074  ea000000          B        |L1.124|
                  |L1.120|
;;;106                }
;;;107                else {
;;;108                    break; /* all currently armed time evts. processed */
000078  ea00002a          B        |L1.296|
                  |L1.124|
;;;109                }
;;;110            }
;;;111    
;;;112            /* time evt. scheduled for removal? */
;;;113            if (t->ctr == (QTimeEvtCtr)0) {
00007c  e1d400bc          LDRH     r0,[r4,#0xc]
000080  e3500000          CMP      r0,#0
000084  1a000006          BNE      |L1.164|
;;;114                prev->next = t->next;
000088  e5940004          LDR      r0,[r4,#4]
00008c  e5850004          STR      r0,[r5,#4]
;;;115                t->super.refCtr_ &= (uint8_t)0x7F; /* mark as unlinked */
000090  e5d40003          LDRB     r0,[r4,#3]
000094  e200007f          AND      r0,r0,#0x7f
000098  e5c40003          STRB     r0,[r4,#3]
;;;116                /* do NOT advance the prev pointer */
;;;117                QF_CRIT_EXIT_(); /* exit crit. section to reduce latency */
00009c  ef0000ff          SVC      #0xff
;;;118    
;;;119                /* prevent merging critical sections, see NOTE1 below  */
;;;120                QF_CRIT_EXIT_NOP();
0000a0  ea00001e          B        |L1.288|
                  |L1.164|
;;;121            }
;;;122            else {
;;;123                --t->ctr;
0000a4  e1d400bc          LDRH     r0,[r4,#0xc]
0000a8  e2400001          SUB      r0,r0,#1
0000ac  e1c400bc          STRH     r0,[r4,#0xc]
;;;124    
;;;125                /* is time event about to expire? */
;;;126                if (t->ctr == (QTimeEvtCtr)0) {
0000b0  e1d400bc          LDRH     r0,[r4,#0xc]
0000b4  e3500000          CMP      r0,#0
0000b8  1a000015          BNE      |L1.276|
;;;127                    QActive *act = (QActive *)t->act; /* temporary for volatile */
0000bc  e5947008          LDR      r7,[r4,#8]
;;;128    
;;;129                    /* periodic time evt? */
;;;130                    if (t->interval != (QTimeEvtCtr)0) {
0000c0  e1d400be          LDRH     r0,[r4,#0xe]
0000c4  e3500000          CMP      r0,#0
0000c8  0a000003          BEQ      |L1.220|
;;;131                        t->ctr = t->interval; /* rearm the time event */
0000cc  e1d400be          LDRH     r0,[r4,#0xe]
0000d0  e1c400bc          STRH     r0,[r4,#0xc]
;;;132                        prev = t; /* advance to this time event */
0000d4  e1a05004          MOV      r5,r4
0000d8  ea000004          B        |L1.240|
                  |L1.220|
;;;133                    }
;;;134                    /* one-shot time event: automatically disarm */
;;;135                    else {
;;;136                        prev->next = t->next;
0000dc  e5940004          LDR      r0,[r4,#4]
0000e0  e5850004          STR      r0,[r5,#4]
;;;137                        t->super.refCtr_ &= (uint8_t)0x7F; /* mark as unlinked */
0000e4  e5d40003          LDRB     r0,[r4,#3]
0000e8  e200007f          AND      r0,r0,#0x7f
0000ec  e5c40003          STRB     r0,[r4,#3]
                  |L1.240|
;;;138                        /* do NOT advance the prev pointer */
;;;139    
;;;140                        QS_BEGIN_NOCRIT_(QS_QF_TIMEEVT_AUTO_DISARM,
;;;141                                         QS_priv_.teObjFilter, t)
;;;142                            QS_OBJ_(t);            /* this time event object */
;;;143                            QS_OBJ_(act);          /* the target AO */
;;;144                            QS_U8_((uint8_t)tickRate); /* tick rate */
;;;145                        QS_END_NOCRIT_()
;;;146                    }
;;;147    
;;;148                    QS_BEGIN_NOCRIT_(QS_QF_TIMEEVT_POST, QS_priv_.teObjFilter, t)
;;;149                        QS_TIME_();                /* timestamp */
;;;150                        QS_OBJ_(t);                /* the time event object */
;;;151                        QS_SIG_(t->super.sig);     /* signal of this time event */
;;;152                        QS_OBJ_(act);              /* the target AO */
;;;153                        QS_U8_((uint8_t)tickRate); /* tick rate */
;;;154                    QS_END_NOCRIT_()
;;;155    
;;;156                    QF_CRIT_EXIT_(); /* exit critical section before posting */
0000f0  ef0000ff          SVC      #0xff
;;;157    
;;;158                    /* QACTIVE_POST() asserts internally if the queue overflows */
;;;159                    QACTIVE_POST(act, &t->super, sender);
0000f4  e5970000          LDR      r0,[r7,#0]
0000f8  e3a02000          MOV      r2,#0
0000fc  e1a01004          MOV      r1,r4
000100  e590300c          LDR      r3,[r0,#0xc]
000104  e1a00007          MOV      r0,r7
000108  e1a0e00f          MOV      lr,pc
00010c  e12fff13          BX       r3
;;;160                }
000110  ea000002          B        |L1.288|
                  |L1.276|
;;;161                else {
;;;162                    prev = t;         /* advance to this time event */
000114  e1a05004          MOV      r5,r4
;;;163                    QF_CRIT_EXIT_();  /* exit crit. section to reduce latency */
000118  ef0000ff          SVC      #0xff
;;;164    
;;;165                    /* prevent merging critical sections, see NOTE1 below  */
;;;166                    QF_CRIT_EXIT_NOP();
00011c  e1a00000          MOV      r0,r0
                  |L1.288|
;;;167                }
;;;168            }
;;;169            QF_CRIT_ENTRY_(); /* re-enter crit. section to continue */
000120  ef0000fe          SVC      #0xfe
;;;170        }
000124  eaffffbb          B        |L1.24|
                  |L1.296|
000128  e1a00000          MOV      r0,r0                 ;108
;;;171        QF_CRIT_EXIT_();
00012c  ef0000ff          SVC      #0xff
;;;172    }
000130  e8bd41f0          POP      {r4-r8,lr}
000134  e12fff1e          BX       lr
;;;173    
                          ENDP

                  QF_noTimeEvtsActiveX PROC
;;;199    */
;;;200    bool QF_noTimeEvtsActiveX(uint_fast8_t const tickRate) {
000138  e92d4070          PUSH     {r4-r6,lr}
00013c  e1a05000          MOV      r5,r0
;;;201        bool inactive;
;;;202    
;;;203        /** \pre the tick rate must be in range */
;;;204        Q_REQUIRE_ID(200, tickRate < (uint_fast8_t)QF_MAX_TICK_RATE);
000140  e3550002          CMP      r5,#2
000144  2a000000          BCS      |L1.332|
000148  ea000002          B        |L1.344|
                  |L1.332|
00014c  e3a010c8          MOV      r1,#0xc8
000150  e59f004c          LDR      r0,|L1.420|
000154  ebfffffe          BL       Q_onAssert
                  |L1.344|
;;;205    
;;;206        if (QF_timeEvtHead_[tickRate].next != (QTimeEvt *)0) {
000158  e59f0040          LDR      r0,|L1.416|
00015c  e0800205          ADD      r0,r0,r5,LSL #4
000160  e5900004          LDR      r0,[r0,#4]
000164  e3500000          CMP      r0,#0
000168  0a000001          BEQ      |L1.372|
;;;207            inactive = false;
00016c  e3a04000          MOV      r4,#0
000170  ea000007          B        |L1.404|
                  |L1.372|
;;;208        }
;;;209        else if ((QF_timeEvtHead_[tickRate].act != (void *)0)) {
000174  e59f0024          LDR      r0,|L1.416|
000178  e0800205          ADD      r0,r0,r5,LSL #4
00017c  e5900008          LDR      r0,[r0,#8]
000180  e3500000          CMP      r0,#0
000184  0a000001          BEQ      |L1.400|
;;;210            inactive = false;
000188  e3a04000          MOV      r4,#0
00018c  ea000000          B        |L1.404|
                  |L1.400|
;;;211        }
;;;212        else {
;;;213            inactive = true;
000190  e3a04001          MOV      r4,#1
                  |L1.404|
;;;214        }
;;;215        return inactive;
000194  e1a00004          MOV      r0,r4
000198  e8bd4070          POP      {r4-r6,lr}
;;;216    }
00019c  e12fff1e          BX       lr
;;;217    
                          ENDP

                  |L1.416|
                          DCD      QF_timeEvtHead_
                  |L1.420|
                          DCD      Q_this_module_

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  QF_timeEvtHead_
                          %        32

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  Q_this_module_
000000  71665f74          DCB      0x71,0x66,0x5f,0x74
000004  69636b00          DCB      0x69,0x63,0x6b,0x00
