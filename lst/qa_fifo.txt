; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\qa_fifo.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\qa_fifo.d --apcs=interwork -O0 --diag_suppress=9931 -I.\bombqmbsp -I..\..\..\..\..\..\..\CPU_Platforms\ARM\ARM7\MCB2300\include -I..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil -I..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include -I.\src -I.\src\coffee -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\Philips -D__MICROLIB -DQM_TICK -DQM_ActiveObject --omf_browse=.\obj\qa_fifo.crf ..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\qf\source\qa_fifo.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  QActive_post_ PROC
;;;100    #ifndef Q_SPY
;;;101    bool QActive_post_(QActive * const me, QEvt const * const e,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;102                       uint_fast16_t const margin)
;;;103    #else
;;;104    bool QActive_post_(QActive * const me, QEvt const * const e,
;;;105                       uint_fast16_t const margin, void const * const sender)
;;;106    #endif
;;;107    {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
00000c  e1a07002          MOV      r7,r2
;;;108        QEQueueCtr nFree; /* temporary to avoid UB for volatile access */
;;;109        bool status;
;;;110        QF_CRIT_STAT_
;;;111    
;;;112        /** \pre event pointer must be valid */
;;;113        Q_REQUIRE_ID(100, e != (QEvt const *)0);
000010  e3550000          CMP      r5,#0
000014  0a000000          BEQ      |L1.28|
000018  ea000002          B        |L1.40|
                  |L1.28|
00001c  e3a01064          MOV      r1,#0x64
000020  e59f00dc          LDR      r0,|L1.260|
000024  ebfffffe          BL       Q_onAssert
                  |L1.40|
;;;114    
;;;115        QF_CRIT_ENTRY_();
000028  ef0000fe          SVC      #0xfe
;;;116        nFree = me->eQueue.nFree; /* get volatile into the temporary */
00002c  e5946020          LDR      r6,[r4,#0x20]
;;;117    
;;;118        /* margin available? */
;;;119        if (nFree > (QEQueueCtr)margin) {
000030  e1560007          CMP      r6,r7
000034  9a000025          BLS      |L1.208|
;;;120    
;;;121            QS_BEGIN_NOCRIT_(QS_QF_ACTIVE_POST_FIFO, QS_priv_.aoObjFilter, me)
;;;122                QS_TIME_();               /* timestamp */
;;;123                QS_OBJ_(sender);          /* the sender object */
;;;124                QS_SIG_(e->sig);          /* the signal of the event */
;;;125                QS_OBJ_(me);              /* this active object (recipient) */
;;;126                QS_2U8_(e->poolId_, e->refCtr_); /* pool Id & ref Count */
;;;127                QS_EQC_(nFree);           /* number of free entries */
;;;128                QS_EQC_(me->eQueue.nMin); /* min number of free entries */
;;;129            QS_END_NOCRIT_()
;;;130    
;;;131            /* is it a pool event? */
;;;132            if (e->poolId_ != (uint8_t)0) {
000038  e5d50002          LDRB     r0,[r5,#2]
00003c  e3500000          CMP      r0,#0
000040  0a000002          BEQ      |L1.80|
;;;133                QF_EVT_REF_CTR_INC_(e); /* increment the reference counter */
000044  e5d50003          LDRB     r0,[r5,#3]
000048  e2800001          ADD      r0,r0,#1
00004c  e5c50003          STRB     r0,[r5,#3]
                  |L1.80|
;;;134            }
;;;135    
;;;136            --nFree; /* one free entry just used up */
000050  e2466001          SUB      r6,r6,#1
;;;137            me->eQueue.nFree = nFree;       /* update the volatile */
000054  e5846020          STR      r6,[r4,#0x20]
;;;138            if (me->eQueue.nMin > nFree) {
000058  e5940024          LDR      r0,[r4,#0x24]
00005c  e1500006          CMP      r0,r6
000060  9a000000          BLS      |L1.104|
;;;139                me->eQueue.nMin = nFree;    /* update minimum so far */
000064  e5846024          STR      r6,[r4,#0x24]
                  |L1.104|
;;;140            }
;;;141    
;;;142            /* empty queue? */
;;;143            if (me->eQueue.frontEvt == (QEvt const *)0) {
000068  e594000c          LDR      r0,[r4,#0xc]
00006c  e3500000          CMP      r0,#0
000070  1a000009          BNE      |L1.156|
;;;144                me->eQueue.frontEvt = e;    /* deliver event directly */
000074  e584500c          STR      r5,[r4,#0xc]
;;;145                QACTIVE_EQUEUE_SIGNAL_(me); /* signal the event queue */
000078  e59f0088          LDR      r0,|L1.264|
00007c  e5900000          LDR      r0,[r0,#0]  ; QF_readySet_
000080  e59f2084          LDR      r2,|L1.268|
000084  e5941028          LDR      r1,[r4,#0x28]
000088  e7d21001          LDRB     r1,[r2,r1]
00008c  e1800001          ORR      r0,r0,r1
000090  e59f1070          LDR      r1,|L1.264|
000094  e5810000          STR      r0,[r1,#0]  ; QF_readySet_
000098  ea00000a          B        |L1.200|
                  |L1.156|
;;;146            }
;;;147            /* queue is not empty, insert event into the ring-buffer */
;;;148            else {
;;;149                /* insert event into the ring buffer (FIFO) */
;;;150                QF_PTR_AT_(me->eQueue.ring, me->eQueue.head) = e;
00009c  e5940010          LDR      r0,[r4,#0x10]
0000a0  e5941018          LDR      r1,[r4,#0x18]
0000a4  e7805101          STR      r5,[r0,r1,LSL #2]
;;;151                if (me->eQueue.head == (QEQueueCtr)0) { /* need to wrap head? */
0000a8  e5940018          LDR      r0,[r4,#0x18]
0000ac  e3500000          CMP      r0,#0
0000b0  1a000001          BNE      |L1.188|
;;;152                    me->eQueue.head = me->eQueue.end;   /* wrap around */
0000b4  e5940014          LDR      r0,[r4,#0x14]
0000b8  e5840018          STR      r0,[r4,#0x18]
                  |L1.188|
;;;153                }
;;;154                --me->eQueue.head; /* advance the head (counter clockwise) */
0000bc  e5940018          LDR      r0,[r4,#0x18]
0000c0  e2400001          SUB      r0,r0,#1
0000c4  e5840018          STR      r0,[r4,#0x18]
                  |L1.200|
;;;155            }
;;;156            status = true; /* event posted successfully */
0000c8  e3a08001          MOV      r8,#1
0000cc  ea000008          B        |L1.244|
                  |L1.208|
;;;157        }
;;;158        else {
;;;159            /** \note assert if event cannot be posted and dropping events is
;;;160            * not acceptable
;;;161            */
;;;162            Q_ASSERT_ID(110, margin != (uint_fast16_t)0);
0000d0  e3570000          CMP      r7,#0
0000d4  0a000000          BEQ      |L1.220|
0000d8  ea000002          B        |L1.232|
                  |L1.220|
0000dc  e3a0106e          MOV      r1,#0x6e
0000e0  e59f001c          LDR      r0,|L1.260|
0000e4  ebfffffe          BL       Q_onAssert
                  |L1.232|
;;;163    
;;;164            QS_BEGIN_NOCRIT_(QS_QF_ACTIVE_POST_ATTEMPT, QS_priv_.aoObjFilter, me)
;;;165                QS_TIME_();           /* timestamp */
;;;166                QS_OBJ_(sender);      /* the sender object */
;;;167                QS_SIG_(e->sig);      /* the signal of the event */
;;;168                QS_OBJ_(me);          /* this active object (recipient) */
;;;169                QS_2U8_(e->poolId_, e->refCtr_); /* pool Id & ref Count */
;;;170                QS_EQC_(nFree);       /* number of free entries */
;;;171                QS_EQC_(margin);      /* margin requested */
;;;172            QS_END_NOCRIT_()
;;;173    
;;;174            QF_gc(e); /* recycle the event to avoid a leak */
0000e8  e1a00005          MOV      r0,r5
0000ec  ebfffffe          BL       QF_gc
;;;175            status = false; /* event not posted */
0000f0  e3a08000          MOV      r8,#0
                  |L1.244|
;;;176        }
;;;177        QF_CRIT_EXIT_();
0000f4  ef0000ff          SVC      #0xff
;;;178    
;;;179        return status;
0000f8  e1a00008          MOV      r0,r8
0000fc  e8bd41f0          POP      {r4-r8,lr}
;;;180    }
000100  e12fff1e          BX       lr
;;;181    
                          ENDP

                  |L1.260|
                          DCD      Q_this_module_
                  |L1.264|
                          DCD      QF_readySet_
                  |L1.268|
                          DCD      QF_pwr2Lkup

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  Q_this_module_
000000  71615f66          DCB      0x71,0x61,0x5f,0x66
000004  69666f00          DCB      0x69,0x66,0x6f,0x00
