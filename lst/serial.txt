; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\serial.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\serial.d --apcs=interwork -O0 --diag_suppress=9931 -I.\bombqmbsp -I..\..\..\..\..\..\..\CPU_Platforms\ARM\ARM7\MCB2300\include -I..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil -I..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include -I.\src -I.\src\coffee -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\Philips -D__MICROLIB -DQM_TICK -DQM_ActiveObject --omf_browse=.\obj\serial.crf bsp\Serial.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  init_serial PROC
;;;39     /* Use serial 1  for polling  - serial 0 for interrupt*/
;;;40     void init_serial (void)  {               /* Initialize Serial Interface       */
000000  e59f019c          LDR      r0,|L1.420|
;;;41       #ifdef UART0
;;;42         PINSEL0 |= 0x00000050;               /* Enable TxD0 and RxD0              */
000004  e5900000          LDR      r0,[r0,#0]
000008  e3800050          ORR      r0,r0,#0x50
00000c  e59f1190          LDR      r1,|L1.420|
000010  e5810000          STR      r0,[r1,#0]
;;;43       #elif defined (UART1)
;;;44         PINSEL0 |= 0x40000000;               /* Enable TxD1                       */
;;;45         PINSEL1 |= 0x00000001;               /* Enable RxD1                       */
;;;46       #endif
;;;47       UxFDR    = 0;                          /* Fractional divider not used       */
000014  e3a00000          MOV      r0,#0
000018  e2411802          SUB      r1,r1,#0x20000
00001c  e5810028          STR      r0,[r1,#0x28]
;;;48       UxLCR    = 0x83;                       /* 8 bits, no Parity, 1 Stop bit     */
000020  e3a00083          MOV      r0,#0x83
000024  e581000c          STR      r0,[r1,#0xc]
;;;49       UxDLL    = 78;                         /* 9600 Baud Rate @ 12.0 MHZ PCLK    */
000028  e3a0004e          MOV      r0,#0x4e
00002c  e5810000          STR      r0,[r1,#0]
;;;50       UxDLM    = 0;                          /* High divisor latch = 0            */
000030  e3a00000          MOV      r0,#0
000034  e5810004          STR      r0,[r1,#4]
;;;51       UxLCR    = 0x03;                       /* DLAB = 0                          */
000038  e3a00003          MOV      r0,#3
00003c  e581000c          STR      r0,[r1,#0xc]
;;;52     }
000040  e12fff1e          BX       lr
;;;53     
                          ENDP

                  send_char PROC
;;;55     /* Implementation of putchar (also used by printf function to output data)    */
;;;56     int send_char (int ch)  {                 /* Write character to Serial Port    */
000044  e1a00000          MOV      r0,r0
                  |L1.72|
;;;57     
;;;58       while (!(UxLSR & 0x20));
000048  e59f1158          LDR      r1,|L1.424|
00004c  e5911014          LDR      r1,[r1,#0x14]
000050  e2011020          AND      r1,r1,#0x20
000054  e3510000          CMP      r1,#0
000058  0afffffa          BEQ      |L1.72|
;;;59     
;;;60       return (UxTHR = ch);
00005c  e59f1144          LDR      r1,|L1.424|
000060  e5810000          STR      r0,[r1,#0]
;;;61     }
000064  e12fff1e          BX       lr
;;;62     
                          ENDP

                  kbhit PROC
;;;67     static int buf;
;;;68     int kbhit(void) {
000068  e59f013c          LDR      r0,|L1.428|
;;;69     
;;;70     	if (keystroke )	{
00006c  e5900000          LDR      r0,[r0,#0]  ; keystroke
000070  e3500000          CMP      r0,#0
000074  0a000004          BEQ      |L1.140|
;;;71     		keystroke=0;
000078  e3a00000          MOV      r0,#0
00007c  e59f1128          LDR      r1,|L1.428|
000080  e5810000          STR      r0,[r1,#0]  ; keystroke
;;;72     		return(1);
000084  e3a00001          MOV      r0,#1
                  |L1.136|
;;;73     		}
;;;74     	else
;;;75     		return(0);
;;;76     }
000088  e12fff1e          BX       lr
                  |L1.140|
00008c  e3a00000          MOV      r0,#0                 ;75
000090  eafffffc          B        |L1.136|
;;;77     		
                          ENDP

                  getkey PROC
;;;78     
;;;79     int getkey (void)  {                     /* Read character from Serial Port   */
000094  e1a00000          MOV      r0,r0
                  |L1.152|
;;;80     
;;;81       while (!(UxLSR & 0x01));
000098  e59f0108          LDR      r0,|L1.424|
00009c  e5900014          LDR      r0,[r0,#0x14]
0000a0  e2000001          AND      r0,r0,#1
0000a4  e3500000          CMP      r0,#0
0000a8  0afffffa          BEQ      |L1.152|
;;;82     
;;;83       return (UxRBR);
0000ac  e59f00f4          LDR      r0,|L1.424|
0000b0  e5900000          LDR      r0,[r0,#0]
;;;84     }
0000b4  e12fff1e          BX       lr
;;;85     
                          ENDP

                  getkey0 PROC
;;;87     
;;;88     int getkey0 ( void ) {
0000b8  e59f10f0          LDR      r1,|L1.432|
;;;89     	int tmp;
;;;90     	tmp = buf;
0000bc  e5910000          LDR      r0,[r1,#0]  ; buf
;;;91     	buf=0;
0000c0  e3a01000          MOV      r1,#0
0000c4  e59f20e4          LDR      r2,|L1.432|
0000c8  e5821000          STR      r1,[r2,#0]  ; buf
;;;92     	return( tmp );
;;;93     
;;;94     }
0000cc  e12fff1e          BX       lr
;;;95     
                          ENDP

                  get_char PROC
;;;96     int get_char(){
0000d0  e1a00000          MOV      r0,r0
                  |L1.212|
;;;97     
;;;98     	 while (!(U0LSR & 0x01));
0000d4  e59f00cc          LDR      r0,|L1.424|
0000d8  e5900014          LDR      r0,[r0,#0x14]
0000dc  e2000001          AND      r0,r0,#1
0000e0  e3500000          CMP      r0,#0
0000e4  0afffffa          BEQ      |L1.212|
;;;99     	 return (U0RBR);
0000e8  e59f00b8          LDR      r0,|L1.424|
0000ec  e5900000          LDR      r0,[r0,#0]
;;;100     }
0000f0  e12fff1e          BX       lr
;;;101    
                          ENDP

                  uart_isr0 PROC
                  |L1.244|
;;;103    
;;;104    __irq  void uart_isr0(void ){
0000f4  e92d503f          PUSH     {r0-r5,r12,lr}
;;;105    	
;;;106     	
;;;107    	int ch;
;;;108    
;;;109    
;;;110    	
;;;111    	ch=get_char();	
0000f8  ebfffffe          BL       get_char
0000fc  e1a04000          MOV      r4,r0
;;;112    	buf = ch;
000100  e59f00a8          LDR      r0,|L1.432|
000104  e5804000          STR      r4,[r0,#0]  ; buf
;;;113    	keystroke =ch;
000108  e59f009c          LDR      r0,|L1.428|
00010c  e5804000          STR      r4,[r0,#0]  ; keystroke
;;;114    
;;;115    
;;;116    #ifdef QM_ActiveObject
;;;117    
;;;118    	BSP_onKeyboardInput(buf);
000110  e59f0098          LDR      r0,|L1.432|
000114  e5900000          LDR      r0,[r0,#0]  ; buf
000118  ebfffffe          BL       BSP_onKeyboardInput
;;;119    #endif
;;;120    
;;;121    
;;;122    
;;;123    	VICVectAddr = 0;                      /* Acknowledge Interrupt              */
00011c  e3a00000          MOV      r0,#0
000120  e5000100          STR      r0,[r0,#-0x100]
;;;124    
;;;125    }
000124  e8bd503f          POP      {r0-r5,r12,lr}
000128  e25ef004          SUBS     pc,lr,#4
;;;126    
                          ENDP

                  uart_init_0 PROC
;;;127    
;;;128    void uart_init_0 ( void ) {
00012c  e59f0070          LDR      r0,|L1.420|
;;;129    
;;;130    
;;;131    	    PINSEL0 |= 0x00000050;               /* Enable TxD0 and RxD0              */
000130  e5900000          LDR      r0,[r0,#0]
000134  e3800050          ORR      r0,r0,#0x50
000138  e59f1064          LDR      r1,|L1.420|
00013c  e5810000          STR      r0,[r1,#0]
;;;132    #ifdef BAUD15
;;;133    	U0LCR = 0x83; /* 8 bits, no Parity, 1 Stop bit*/ 
000140  e3a00083          MOV      r0,#0x83
000144  e1c11500          BIC      r1,r1,r0,LSL #10
000148  e581000c          STR      r0,[r1,#0xc]
;;;134    	U0DLL = 3; /* for 12MHz PCLK Clock 115200 */ 
00014c  e3a00003          MOV      r0,#3
000150  e5810000          STR      r0,[r1,#0]
;;;135    	U0FDR = 0x67; /* Fractional Divider */ 
000154  e3a00067          MOV      r0,#0x67
000158  e5810028          STR      r0,[r1,#0x28]
;;;136    	U0LCR = 0x03; /* DLAB = 0 */
00015c  e3a00003          MOV      r0,#3
000160  e581000c          STR      r0,[r1,#0xc]
;;;137    	U0DLM    = 0;
000164  e3a00000          MOV      r0,#0
000168  e5810004          STR      r0,[r1,#4]
;;;138    #else
;;;139    
;;;140    			U0FDR    = 0;                          /* Fractional divider not used       */
;;;141      		U0LCR    = 0x83;  // 0x83;                       /* 8 bits, no Parity, 1 Stop bit     */
;;;142      		U0DLL    = 78;                         /* 9600 Baud Rate @ 12.0 MHZ PCLK    */
;;;143     	    U0DLM    = 0;                          /* High divisor latch = 0            */
;;;144      		U0LCR    = 0x03;                       /* DLAB = 0                          */
;;;145    #endif
;;;146    			U0IER    = 0x01;
00016c  e3a00001          MOV      r0,#1
000170  e5810004          STR      r0,[r1,#4]
;;;147    			U0FCR    = 0x02;
000174  e3a00002          MOV      r0,#2
000178  e5810008          STR      r0,[r1,#8]
;;;148    			U0FCR    = 0x81;	 
00017c  e3a00081          MOV      r0,#0x81
000180  e5810008          STR      r0,[r1,#8]
;;;149    	
;;;150    	
;;;151    	
;;;152    
;;;153    
;;;154    	
;;;155    	
;;;156    			VICVectAddr6  = (unsigned long)uart_isr0;			/* Set Interrupt Vector        */
000184  e24f0098          ADR      r0,|L1.244|
000188  e3a01000          MOV      r1,#0
00018c  e5010ee8          STR      r0,[r1,#-0xee8]
;;;157      		VICVectCntl6  = 12;                           /* use it for UART Priority  */
000190  e3a0000c          MOV      r0,#0xc
000194  e5010de8          STR      r0,[r1,#-0xde8]
;;;158      		VICIntEnable  = (1  << 6);                   /* Enable UART= Interrupt     */
000198  e3a00040          MOV      r0,#0x40
00019c  e5010ff0          STR      r0,[r1,#-0xff0]
;;;159    
;;;160    }
0001a0  e12fff1e          BX       lr
                          ENDP

                  |L1.420|
                          DCD      0xe002c000
                  |L1.424|
                          DCD      0xe000c000
                  |L1.428|
                          DCD      keystroke
                  |L1.432|
                          DCD      buf

                          AREA ||.data||, DATA, ALIGN=2

                  keystroke
                          DCD      0x00000000
                  buf
                          DCD      0x00000000
