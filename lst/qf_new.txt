; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\qf_new.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\qf_new.d --apcs=interwork -O0 --diag_suppress=9931 -I.\bombqmbsp -I..\..\..\..\..\..\..\CPU_Platforms\ARM\ARM7\MCB2300\include -I..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil -I..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include -I.\src -I.\src\coffee -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\Philips -D__MICROLIB -DQM_TICK -DQM_ActiveObject --omf_browse=.\obj\qf_new.crf ..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\qf\source\qf_new.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  QF_newX_ PROC
;;;75     */
;;;76     QEvt *QF_newX_(uint_fast16_t const evtSize,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;77                    uint_fast16_t const margin, enum_t const sig)
;;;78     {
000004  e1a06000          MOV      r6,r0
000008  e1a07001          MOV      r7,r1
00000c  e1a08002          MOV      r8,r2
;;;79         QEvt *e;
;;;80         uint_fast8_t idx;
;;;81         QS_CRIT_STAT_
;;;82     
;;;83         /* find the pool index that fits the requested event size ... */
;;;84         for (idx = (uint_fast8_t)0; idx < QF_maxPool_; ++idx) {
000010  e3a05000          MOV      r5,#0
000014  ea000007          B        |L1.56|
                  |L1.24|
;;;85             if (evtSize <= QF_EPOOL_EVENT_SIZE_(QF_pool_[idx])) {
000018  e0850105          ADD      r0,r5,r5,LSL #2
00001c  e59f10a4          LDR      r1,|L1.200|
000020  e0810100          ADD      r0,r1,r0,LSL #2
000024  e1d000bc          LDRH     r0,[r0,#0xc]
000028  e1500006          CMP      r0,r6
00002c  3a000000          BCC      |L1.52|
;;;86                 break;
000030  ea000004          B        |L1.72|
                  |L1.52|
000034  e2855001          ADD      r5,r5,#1              ;84
                  |L1.56|
000038  e59f008c          LDR      r0,|L1.204|
00003c  e5900000          LDR      r0,[r0,#0]            ;84  ; QF_maxPool_
000040  e1550000          CMP      r5,r0                 ;84
000044  3afffff3          BCC      |L1.24|
                  |L1.72|
000048  e1a00000          MOV      r0,r0
;;;87             }
;;;88         }
;;;89         /* cannot run out of registered pools */
;;;90         Q_ASSERT_ID(110, idx < QF_maxPool_);
00004c  e59f0078          LDR      r0,|L1.204|
000050  e5900000          LDR      r0,[r0,#0]  ; QF_maxPool_
000054  e1550000          CMP      r5,r0
000058  2a000000          BCS      |L1.96|
00005c  ea000002          B        |L1.108|
                  |L1.96|
000060  e3a0106e          MOV      r1,#0x6e
000064  e59f0064          LDR      r0,|L1.208|
000068  ebfffffe          BL       Q_onAssert
                  |L1.108|
;;;91     
;;;92         QS_BEGIN_(QS_QF_NEW, (void *)0, (void *)0)
;;;93             QS_TIME_();             /* timestamp */
;;;94             QS_EVS_(evtSize);       /* the size of the event */
;;;95             QS_SIG_((QSignal)sig);  /* the signal of the event */
;;;96         QS_END_()
;;;97     
;;;98         QF_EPOOL_GET_(QF_pool_[idx], e, margin); /* get e -- platform-dependent */
00006c  e0851105          ADD      r1,r5,r5,LSL #2
000070  e59f2050          LDR      r2,|L1.200|
000074  e0820101          ADD      r0,r2,r1,LSL #2
000078  e1a01007          MOV      r1,r7
00007c  ebfffffe          BL       QMPool_get
000080  e1a04000          MOV      r4,r0
;;;99     
;;;100        /* was e allocated correctly? */
;;;101        if (e != (QEvt *)0) {
000084  e3540000          CMP      r4,#0
000088  0a000005          BEQ      |L1.164|
;;;102            e->sig = (QSignal)sig;      /* set signal for this event */
00008c  e1c480b0          STRH     r8,[r4,#0]
;;;103            e->poolId_ = (uint8_t)(idx + (uint_fast8_t)1); /* store the pool ID */
000090  e2850001          ADD      r0,r5,#1
000094  e5c40002          STRB     r0,[r4,#2]
;;;104            e->refCtr_ = (uint8_t)0;    /* set the reference counter to 0 */
000098  e3a00000          MOV      r0,#0
00009c  e5c40003          STRB     r0,[r4,#3]
0000a0  ea000005          B        |L1.188|
                  |L1.164|
;;;105        }
;;;106        /* event cannot be allocated */
;;;107        else {
;;;108            /* must tolerate bad alloc. */
;;;109            Q_ASSERT_ID(120, margin != (uint_fast16_t)0);
0000a4  e3570000          CMP      r7,#0
0000a8  0a000000          BEQ      |L1.176|
0000ac  ea000002          B        |L1.188|
                  |L1.176|
0000b0  e3a01078          MOV      r1,#0x78
0000b4  e59f0014          LDR      r0,|L1.208|
0000b8  ebfffffe          BL       Q_onAssert
                  |L1.188|
;;;110        }
;;;111        return e; /* can't be NULL if we can't tolerate bad allocation */
0000bc  e1a00004          MOV      r0,r4
0000c0  e8bd41f0          POP      {r4-r8,lr}
;;;112    }
0000c4  e12fff1e          BX       lr
;;;113    
                          ENDP

                  |L1.200|
                          DCD      QF_pool_
                  |L1.204|
                          DCD      QF_maxPool_
                  |L1.208|
                          DCD      Q_this_module_

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  Q_this_module_
000000  71665f6e          DCB      0x71,0x66,0x5f,0x6e
000004  657700            DCB      0x65,0x77,0x00
