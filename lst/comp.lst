L 1 "src\comp.c"
N/*****************************************************************************
N* Product: Orthogonal Component state pattern example
N* Date of the Last Update:  Oct 21, 2011
N* Ported to Keil MCB 2300 - NXP 2378 Arm/TDMI STANDALONE
N*
N*                    Q u a n t u m     L e a P s
N*                    ---------------------------
N*                    innovating embedded systems
N*
N* Copyright (C) 2002-2009 Quantum Leaps, LLC. All rights reserved.
N*
N* This software may be distributed and modified under the terms of the GNU
N* General Public License version 2 (GPL) as published by the Free Software
N* Foundation and appearing in the file GPL.TXT included in the packaging of
N* this file. Please note that GPL Section 2[b] requires that all works based
N* on this software must also be made publicly available under the terms of
N* the GPL ("Copyleft").
N*
N* Alternatively, this software may be distributed and modified under the
N* terms of Quantum Leaps commercial licenses, which expressly supersede
N* the GPL and are specifically designed for licensees interested in
N* retaining the proprietary status of their code.
N*
N* Contact information:
N* Quantum Leaps Web site:  http://www.quantum-leaps.com
N* e-mail:                  info@quantum-leaps.com
N*****************************************************************************/
N#include "qp_port.h"
L 1 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qp_port.h" 1
N/**
N* \file
N* \brief QP/C public interface.
N* \cond
N******************************************************************************
N* Product: QP/C
N* Last updated for version 5.3.0
N* Last updated on  2014-03-25
N*
N*                    Q u a n t u m     L e a P s
N*                    ---------------------------
N*                    innovating embedded systems
N*
N* Copyright (C) Quantum Leaps, www.state-machine.com.
N*
N* This program is open source software: you can redistribute it and/or
N* modify it under the terms of the GNU General Public License as published
N* by the Free Software Foundation, either version 3 of the License, or
N* (at your option) any later version.
N*
N* Alternatively, this program may be distributed and modified under the
N* terms of Quantum Leaps commercial licenses, which expressly supersede
N* the GNU General Public License and are specifically designed for
N* licensees interested in retaining the proprietary status of their code.
N*
N* This program is distributed in the hope that it will be useful,
N* but WITHOUT ANY WARRANTY; without even the implied warranty of
N* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
N* GNU General Public License for more details.
N*
N* You should have received a copy of the GNU General Public License
N* along with this program. If not, see <http://www.gnu.org/licenses/>.
N*
N* Contact information:
N* Web:   www.state-machine.com
N* Email: info@state-machine.com
N******************************************************************************
N* \endcond
N*/
N#ifndef qp_port_h
N#define qp_port_h
N
N/**
N* \description
N* This header file must be included directly or indirectly
N* in all application modules (*.c files) that use QP/C.
N*/
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/****************************************************************************/
N#include "qf_port.h"      /* QF/C port from the port directory */
L 1 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil\qf_port.h" 1
N/* Product: Product: QP/Cs
N* Last Updated for Version: 5.1.1
N* Date of the Last Update:  Nov 17, 2013
N* Ported to dresden elektronic deRFarm7 Gateway - Atmel AT91SAM7X-512 MCPU
N* Keil  ARM - µLink Environment */
N
N#ifndef qf_port_h
N#define qf_port_h
N
N                 /* The maximum number of active objects in the application */
N#define QF_MAX_ACTIVE               8
N
N#define QF_MAX_TICK_RATE            2
N
N
N
N
Nvoid __swi(0xFE)  disable_irq (void);
Nvoid __swi(0xFF)  enable_irq (void);
N
N#ifdef QK
S#define QF_INT_LOCK(dummy)        disable_irq();    	
S#define QF_INT_UNLOCK(dummy)      enable_irq();  
S
S
N#else
N#define QF_INT_LOCK(dummy)         	__disable_irq();
N#define QF_INT_UNLOCK(dummy)        __enable_irq();
N
N#endif                                            /* QF interrupt disable/enable */
N#define QF_INT_DISABLE()            (__disable_irq())
N#define QF_INT_ENABLE()             (__enable_irq())
N
N
N
N	
N
N
N                                          /* QF critical section entry/exit */
N/* QF_CRIT_STAT_TYPE not defined: unconditional interrupt unlocking" policy */
N#define QF_CRIT_ENTRY(dummy)       disable_irq();
N#define QF_CRIT_EXIT(dummy)        enable_irq(); 
N
N
N
N
N#include "qep_port.h"                                           /* QEP port */
L 1 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil\qep_port.h" 1
N/* Product: Product: QP/Cs
N* Last Updated for Version: 5.1.0
N* Date of the Last Update:  Nov 18, 2013
N* Ported to dresden elektronic deRFarm7 Gateway - Atmel AT91SAM7X-512 MCPU
N* Keil  ARM - µLink Environment */
N
N#ifndef qep_port_h
N#define qep_port_h
N
N#include <stdint.h>        /* exact-width integers, WG14/N843 C99, 7.18.1.1 */
L 1 "C:\Keil_v5\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 180721 $
N * Checkin $Date: 2013-06-24 09:41:57 +0100 (Mon, 24 Jun 2013) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5040049
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 11 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil\qep_port.h" 2
N#include <stdbool.h>
L 1 "C:\Keil_v5\ARM\ARMCC\bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision: 177844 $
N * Checkin $Date: 2012-11-21 11:51:12 +0000 (Wed, 21 Nov 2012) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5040049
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 12 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil\qep_port.h" 2
N
N#include "qep.h"               /* QEP platform-independent public interface */
L 1 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qep.h" 1
N/**
N* \file
N* \brief Public QEP/C interface.
N* \ingroup qep
N* \cond
N******************************************************************************
N* Product: QEP/C
N* Last updated for version 5.3.1
N* Last updated on  2014-09-18
N*
N*                    Q u a n t u m     L e a P s
N*                    ---------------------------
N*                    innovating embedded systems
N*
N* Copyright (C) Quantum Leaps, www.state-machine.com.
N*
N* This program is open source software: you can redistribute it and/or
N* modify it under the terms of the GNU General Public License as published
N* by the Free Software Foundation, either version 3 of the License, or
N* (at your option) any later version.
N*
N* Alternatively, this program may be distributed and modified under the
N* terms of Quantum Leaps commercial licenses, which expressly supersede
N* the GNU General Public License and are specifically designed for
N* licensees interested in retaining the proprietary status of their code.
N*
N* This program is distributed in the hope that it will be useful,
N* but WITHOUT ANY WARRANTY; without even the implied warranty of
N* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
N* GNU General Public License for more details.
N*
N* You should have received a copy of the GNU General Public License
N* along with this program. If not, see <http://www.gnu.org/licenses/>.
N*
N* Contact information:
N* Web:   www.state-machine.com
N* Email: info@state-machine.com
N******************************************************************************
N* \endcond
N*/
N#ifndef qep_h
N#define qep_h
N
N/****************************************************************************/
N/*! The current QP/C version number */
N/**
N* \description
N* version of the QP/C framework as a decimal constant XYZ, where X is a
N* 1-digit major version number, Y is a 1-digit minor version number, and Z
N* is a 1-digit release number.
N*/
N#define QP_VERSION      531
N
N/*! The current QP version string */
N#define QP_VERSION_STR  "5.3.1"
N
N/*! Tamperproof current QP release (5.3.1) and date (14-09-18) */
N#define QP_RELEASE      0xAC019C8CU
N
N/****************************************************************************/
N#ifndef Q_SIGNAL_SIZE
N
N    /*! The size (in bytes) of the signal of an event. Valid values:
N    * 1, 2, or 4; default 1 */
N    /**
N    * \description
N    * This macro can be defined in the QEP port file (qep_port.h) to
N    * configure the ::QSignal type. When the macro is not defined, the
N    * default of 2 bytes is applied.
N    */
N    #define Q_SIGNAL_SIZE 2
N#endif
N#if (Q_SIGNAL_SIZE == 1)
X#if (2 == 1)
S    typedef uint8_t QSignal;
N#elif (Q_SIGNAL_SIZE == 2)
X#elif (2 == 2)
N    /*! QSignal represents the signal of an event. */
N    /**
N    * \description
N    * The relationship between an event and a signal is as follows. A signal
N    * in UML is the specification of an asynchronous stimulus that triggers
N    * reactions, and as such is an essential part of an event.
N    * (The signal conveys the type of the occurrence-what happened?)
N    * However, an event can also contain additional quantitative information
N    * about the occurrence in form of event parameters.
N    */
N    typedef uint16_t QSignal;
N#elif (Q_SIGNAL_SIZE == 4)
S    typedef uint32_t QSignal;
S#else
S    #error "Q_SIGNAL_SIZE defined incorrectly, expected 1, 2, or 4"
N#endif
N
N/****************************************************************************/
N#ifndef Q_ROM
N    /*! Macro to specify compiler-specific directive for placing a
N    * constant object in ROM. */
N    /**
N    * \description
N    * Many compilers for 8-bit Harvard-architecture MCUs provide non-standard
N    * extensions to support placement of objects in different memories.
N    * In order to conserve the precious RAM, QP uses the Q_ROM macro for
N    * all constant objects that can be allocated in ROM.
N    *
N    * \note
N    * To override the empty definition of Q_ROM, you need to define the
N    * Q_ROM macro in the qep_port.h header file. Some examples of valid
N    * Q_ROM macro definitions are: __code (IAR 8051 compiler), code (Keil
N    * Cx51 compiler), PROGMEM (gcc for AVR), __flash (IAR for AVR).
N    */
N    #define Q_ROM
N#endif
N#ifndef Q_ROM_BYTE
N    /*! Macro to access a byte allocated in ROM */
N    /**
N    * \description
N    * Some compilers for Harvard-architecture MCUs, such as gcc for AVR, do
N    * not generate correct code for accessing data allocated in the program
N    * space (ROM). The workaround for such compilers is to explicitly add
N    * assembly code to access each data element allocated in the program
N    * space. The macro Q_ROM_BYTE() retrieves a byte from the given ROM
N    * address. If the macro is left undefined, the default definition simply
N    * returns the argument.
N    *
N    * \arguments
N    * \arg[in] \c rom_var_ address of the ROM-based byte variable
N    * \returns the byte value from ROM
N    *
N    * \note The Q_ROM_BYTE() macro should be re-defined for compilers that
N    * cannot handle correctly data placed in ROM (such as the gcc for AVR).
N    */
N    #define Q_ROM_BYTE(rom_var_)   (rom_var_)
N#endif
N
N/****************************************************************************/
N/* typedefs for basic numerical types; MISRA-C 2004 rule 6.3(req). */
N
N/*! typedef for character strings. */
N/**
N* \description
N* This typedef specifies character type for exclusive use in character
N* strings. Use of this type, rather than plain 'char', is in compliance
N* with the MISRA-C 2004 Rules 6.1(req), 6.3(adv).
N*/
Ntypedef char char_t;
N
N/*! typedef for line numbers in assertions and return from QF_run() */
Ntypedef int int_t;
N
N/*! typedef for enumerations used for event signals */
Ntypedef int enum_t;
N
N/*! IEEE 754 32-bit floating point number, MISRA-C 2004 rule 6.3(req) */
N/**
N* \note QP does not use floating-point types anywhere in the internal
N* implementation, except in QS software tracing, where utilities for
N* output of floating-point numbers are provided for application-level
N* trace records.
N*/
Ntypedef float float32_t;
N
N/*! IEEE 754 64-bit floating point number, MISRA-C 2004 rule 6.3(req) */
N/**
N* \note QP does not use floating-point types anywhere in the internal
N* implementation, except in QS software tracing, where utilities for
N* output of floating-point numbers are provided for application-level
N* trace records.
N*/
Ntypedef double float64_t;
N
N/****************************************************************************/
N/*! Event structure. */
N/**
N* \description
N* QEvt represents events without parameters and serves as the base structure
N* for derivation of events with parameters.
N*
N* \usage
N* The following example illustrates how to add an event parameter by
N* derivation of the QEvt structure. Please note that the QEvt member
N* super_ is defined as the FIRST member of the derived struct.
N* \include qep_qevt.c
N*
N* \sa \ref derivation
N*/
Ntypedef struct {
N    QSignal sig;              /*!< signal of the event instance */
N    uint8_t poolId_;          /*!< pool ID (0 for static event) */
N    uint8_t volatile refCtr_; /*!< reference counter */
N} QEvt;
N
N#ifdef Q_EVT_CTOR /* Shall the constructor for the QEvt class be provided? */
S
S/*! Custom event constructor. */
SQEvt *QEvt_ctor(QEvt * const me, enum_t const sig);
S
N#endif
N
N/****************************************************************************/
N/*! Perform upcast from a subclass of ::QMsm to the base class ::QMsm */
N/**
N* \description
N* Upcasting from a subclass to superclass is a very frequent and __safe__
N* operation in object-oriented programming and object-oriented languages
N* (such as C++) perform such upcasting automatically. However, OOP is
N* implemented in C just as a set of coding conventions (see \ref derivation),
N* and the C compiler does not "know" that certain types are related by
N* inheritance. Therefore for C, the upcast must be performed explicitly.
N* Unfortunately, pointer casting violates the advisory MISRA-C 2004 rule 11.4
N* "cast pointer to pointer". This macro encapsulates this deviation and
N* provides a descriptive name for the reason of this cast.
N*/
N#define Q_MSM_UPCAST(ptr_) ((QMsm *)(ptr_))
N
N/*! Perform downcast of an event onto a subclass of QEvt \a class_ */
N/**
N* \description
N* QEvt represents events without parameters and serves as the base structure
N* This macro encapsulates the downcast of QEvt pointers, which violates
N* MISRA-C 2004 rule 11.4(advisory). This macro helps to localize this
N* deviation.
N*/
N#define Q_EVT_CAST(class_) ((class_ const *)e)
N
N/*! Helper macro to calculate static dimension of a 1-dim \a array_ */
N#define Q_DIM(array_) (sizeof(array_) / sizeof((array_)[0]))
N
N/*! Perform cast from unsigned integer \a uint_ to pointer
N* of type \a type_. */
N/**
N* \description
N* This macro encapsulates the cast to (type_ *), which QP ports or
N* application might use to access embedded hardware registers.
N* Such uses can trigger PC-Lint "Note 923: cast from int to pointer" and
N* this macro helps to encapsulate this deviation.
N*/
N#define Q_UINT2PTR_CAST(type_, uint_)  ((type_ *)(uint_))
N
N/****************************************************************************/
N/*! typedef of the return type from a state/action-handler function. */
Ntypedef uint_fast8_t QState;
N
N/*! Pointer to a state-handler function. */
Ntypedef QState (*QStateHandler)(void * const me, QEvt const * const e);
N
N/*! Pointer to an action-handler function. */
Ntypedef QState (*QActionHandler)(void * const me);
N
N/*! Perform cast to ::QStateHandler. */
N/**
N* \description
N* This macro encapsulates the cast of a specific state handler function
N* pointer to QStateHandler, which violates MISRA-C 2004 rule 11.4(advisory).
N* This macro helps to localize this deviation.
N*
N* \usage
N* \include qep_qhsm_ctor.c
N*/
N#define Q_STATE_CAST(handler_)  ((QStateHandler)(handler_))
N
N/*! Perform cast to QActionHandler. */
N/**
N* \description
N* This macro encapsulates the cast of a specific action handler function
N* pointer to ::QActionHandler, which violates MISRA-C 2004 rule 11.4(adv).
N* This macro helps to localize this deviation.
N*/
N#define Q_ACTION_CAST(action_)  ((QActionHandler)(action_))
N
N/*! State object for the ::QMsm class (Meta State Machine). */
N/**
N* \description
N* This class groups together the attributes of a ::QMsm state, such as the
N* parent state (state nesting), the associated state handler function and
N* the exit action handler function. These attributes are used inside the
N* QMsm_dispatch() and QMsm_init() functions.
N*
N* \attention
N* The ::QMState class is only intended for the QM code generator and should
N* not be used in hand-crafted code.
N*/
Ntypedef struct QMState {
N    struct QMState const *superstate;   /*!< superstate of this state */
N    QStateHandler  const stateHandler;  /*!< state handler function */
N    QActionHandler const entryAction;   /*!< entry action handler function */
N    QActionHandler const exitAction;    /*!< exit action handler function */
N    QActionHandler const initAction;    /*!< init action handler function */
N} QMState;
N
N/*! Transition-Action Table for the Meta State Machine. */
Ntypedef struct {
N    QMState        const *target;
N    QActionHandler const act[1];
N} QMTranActTable;
N
N/*! Attribute of for the ::QMsm class (Meta State Machine). */
N/**
N* \description
N* This union represents possible values stored in the 'state' and 'temp'
N* attributes of the ::QMsm class.
N*/
Nunion QMAttr {
N    QMState        const *obj;   /*!< pointer to QMState object */
N    QMTranActTable const *tatbl; /*!< transition-action table */
N    QStateHandler  fun;          /*!< pointer to a state-handler function */
N    QActionHandler act;          /*!< pointer to an action-handler function */
N};
N
N
N/****************************************************************************/
N/*! virtual table for the ::QMsm class. */
Ntypedef struct QMsmVtbl QMsmVtbl;
N
N/*! Meta State Machine. */
N/**
N* \description
N* QMsm represents the most fundamental State Machine in QP. The application-
N* level state machines derived directly from QMsm typically require the use
N* of the QM modeling tool, but are the fastest and need the least run-time
N* support (the smallest event-processor taking up the least code space).\n
N* \n
N* QMsm is also the base class for the QFsm and QHsm state machines, which
N* can be coded and maintained by hand (as well as by QM), but aren't as fast
N* and require significantly more run-time code (0.5-1KB) to execute.
N*
N* \note QMsm is not intended to be instantiated directly, but rather serves
N* as the base structure for derivation of state machines in the application
N* code.
N*
N* \usage
N* The following example illustrates how to derive a state machine structure
N* from QMsm. Please note that the QMsm member 'super' is defined as the
N* _first_ member of the derived struct.
N* \include qep_qmsm.c
N*
N* \sa \ref derivation
N*/
Ntypedef struct {
N    QMsmVtbl const *vptr; /*!< virtual pointer */
N    union QMAttr state;   /*!< current active state (state-variable) */
N    union QMAttr temp;    /*!< temporary: tran. chain, target state, etc. */
N} QMsm;
N
N/*! Virtual table for the ::QMsm class. */
Nstruct QMsmVtbl {
N    /*! Triggers the top-most initial transition in a SM. */
N    void (*init)(QMsm * const me, QEvt const * const e);
N
N    /*! Dispatches an event to a SM. */
N    void (*dispatch)(QMsm * const me, QEvt const * const e);
N};
N
N/*! Protected "constructor" of a ::QMsm */
Nvoid QMsm_ctor(QMsm * const me, QStateHandler initial);
N
N/*! Obtain the current active state from a MSM (read only). */
N#define QMsm_stateObj(me_) (Q_MSM_UPCAST(me_)->state.obj)
N
N/*! Polymorphically executes the top-most initial transition in a SM. */
N/**
N* \arguments
N* \arg[in,out] \c me_ pointer (see \ref derivation)
N* \arg[in]     \c e_  constant pointer the ::QEvt or a class derived from
N*                     ::QEvt (see \ref derivation)
N* \note Must be called only ONCE after the SM "constructor".
N*
N* \usage
N* The following example illustrates how to initialize a SM, and dispatch
N* events to it:
N* \include qep_qmsm_use.c
N*/
N#define QMSM_INIT(me_, e_) ((*(me_)->vptr->init)((me_), (e_)))
N
N/*! Implementation of the top-most initial transition in ::QMsm. */
Nvoid QMsm_init_(QMsm * const me, QEvt const * const e);
N
N/*! Polymorphically dispatches an event to a SM. */
N/**
N* \description
N* Processes one event at a time in Run-to-Completion fashion.
N*
N* \arguments
N* \arg[in,out] \c me_ pointer (see \ref derivation)
N* \arg[in]     \c e_  constant pointer the ::QEvt or a structure derived from
N*                     ::QEvt (see \ref derivation)
N* \note Must be called after the "constructor" and after QMSM_INIT().
N*/
N#define QMSM_DISPATCH(me_, e_) ((*(me_)->vptr->dispatch)((me_), (e_)))
N
N/*! Implementation of disparching events to QMsm. */
Nvoid QMsm_dispatch_(QMsm * const me, QEvt const * const e);
N
N/*! Internal helper function to exectue a transition-action table. */
NQState QMsm_execTatbl_(QMsm * const me, QMTranActTable const *tatbl);
N
N/*! Tests if a given state is part of the current active state
N* configuration in a MSM.
N*/
Nbool QMsm_isInState(QMsm * const me, QMState const * const state);
X_Bool QMsm_isInState(QMsm * const me, QMState const * const state);
N
N/****************************************************************************/
N/*! Hierarchical State Machine. */
N/**
N* \description
N* QHsm represents a Hierarchical State Machine (HSM) with full support for
N* hierarchical nesting of states, entry/exit actions, and initial transitions
N* in any composite state. QHsm inherits QMsm "as is" without adding new
N* attributes, so it is typedef'ed as QMsm.
N*
N* \note QHsm is not intended to be instantiated directly, but rather serves
N* as the base structure for derivation of state machines in the application
N* code.
N*
N* \usage
N* The following example illustrates how to derive a state machine structure
N* from QHsm. Please note that the QHsm member super is defined as the FIRST
N* member of the derived struct.
N* \include qep_qhsm.c
N*/
Ntypedef QMsm QHsm;
N
N/* public methods */
N
N/*! protected "constructor" of a HSM. */
Nvoid QHsm_ctor(QHsm * const me, QStateHandler initial);
N
N/*! Obtain the current active state from a HSM (read only). */
N/**
N* \arguments
N* \arg[in] \c me_ pointer (see \ref derivation)
N* \returns the current active state of a HSM
N*/
N#define QHsm_state(me_) (Q_STATE_CAST(Q_MSM_UPCAST(me_)->state.fun))
N
N/*! Implementation of the top-most initial transition in QHsm.
N*/
Nvoid QHsm_init_(QHsm * const me, QEvt const * const e);
N
N/*! Implementation of dispatching events to QHsm.
N*/
Nvoid QHsm_dispatch_(QHsm * const me, QEvt const * const e);
N
N/*! Tests if a given state is part of the current active state
N* configuration in a HSM.
N*/
Nbool QHsm_isIn(QHsm * const me, QStateHandler const state);
X_Bool QHsm_isIn(QHsm * const me, QStateHandler const state);
N
N/* protected methods */
N
N/*! the top-state. */
NQState QHsm_top(void const * const me, QEvt const * const e);
N
N
N/****************************************************************************/
N/*! Non-hierarchical Finite State Machine */
N/**
N* \description
N* QFsm represents a traditional non-hierarchical Finite State Machine (FSM)
N* without state hierarchy, but with entry/exit actions. QFsm inherits QMsm
N* "as is" without adding new attributes, so it is typedef'ed as QMsm.
N*
N* \note QFsm is not intended to be instantiated directly, but rather serves
N* as the base structure for derivation of state machines in the application
N* code.
N*
N* \usage
N* The following example illustrates how to derive a state machine structure
N* from QFsm. Please note that the QFsm member super is defined as the FIRST
N* member of the derived struct.
N* \include qep_qfsm.c
N*/
Ntypedef QMsm QFsm;
N
N/*! Protected "constructor" of a FSM. */
Nvoid QFsm_ctor(QFsm * const me, QStateHandler initial);
N
N/*! Implementation of the top-most initial transition in QFsm. */
Nvoid QFsm_init_(QFsm * const me, QEvt const * const e);
N
N/*! Implementation of dispatching events to QFsm. */
Nvoid QFsm_dispatch_(QFsm * const me, QEvt const * const e);
N
N
N/****************************************************************************/
N/*! obtain the current QEP version number string */
N/**
N* \description
N* version of QEP as a constant 5-character string of the form X.Y.Z,
N* where X is a 1-digit major version number, Y is a 1-digit minor
N* version number, and Z is a 1-digit release number.
N*/
N#define QEP_getVersion() (QP_VERSION_STR)
N
N/****************************************************************************/
N/*! All possible values returned from state/action handlers */
N/**
N* \note The order matters for algorithmic correctness.
N*/
Nenum {
N    /* unhandled and need to "bubble up" */
N    Q_RET_SUPER,     /*!< event passed to superstate to handle */
N    Q_RET_SUPER_SUB, /*!< event passed to submachine superstate */
N    Q_RET_UNHANDLED, /*!< event unhandled due to a guard */
N
N    /* handled and do not need to "bubble up" */
N    Q_RET_HANDLED,   /*!< event handled (internal transition) */
N    Q_RET_IGNORED,   /*!< event silently ignored (bubbled up to top) */
N
N    /* entry/exit */
N    Q_RET_ENTRY,     /*!< state entry action executed */
N    Q_RET_EXIT,      /*!< state exit  action executed */
N
N    /* no side effects */
N    Q_RET_NULL,      /*!< return value without any effect */
N
N    /* transitions need to execute transition-action table in QMsm */
N    Q_RET_TRAN,      /*!< event handled (regular transition) */
N    Q_RET_TRAN_INIT, /*!< initial transition in a state or submachine */
N    Q_RET_TRAN_HIST, /*!< event handled (transition to history) */
N    Q_RET_TRAN_EP,   /*!< entry-point transition into a submachine */
N    Q_RET_TRAN_XP    /*!< exit-point transition out of a submachine */
N};
N
N#ifdef Q_SPY
S    /*! Macro to call in a QM action-handler when it executes
S    * an entry action. Applicable only to QMSMs.
S    */
S    #define QM_ENTRY(state_) \
S        ((Q_MSM_UPCAST(me))->temp.obj = (state_), (QState)Q_RET_ENTRY)
X    #define QM_ENTRY(state_)         ((Q_MSM_UPCAST(me))->temp.obj = (state_), (QState)Q_RET_ENTRY)
S
S    /*! Macro to call in a QM action-handler when it executes
S    * an exit action. Applicable only to QMSMs.
S    */
S    #define QM_EXIT(state_) \
S        ((Q_MSM_UPCAST(me))->temp.obj = (state_), (QState)Q_RET_EXIT)
X    #define QM_EXIT(state_)         ((Q_MSM_UPCAST(me))->temp.obj = (state_), (QState)Q_RET_EXIT)
S
N#else
N    #define QM_ENTRY(dummy) ((QState)Q_RET_ENTRY)
N
N    #define QM_EXIT(dummy)  ((QState)Q_RET_EXIT)
N
N#endif /* Q_SPY */
N
N/*! Macro to call in a QM state-handler when it executes a regular
N* transition. Applicable only to QMSMs.
N*/
N#define QM_TRAN(tatbl_) \
N    ((Q_MSM_UPCAST(me))->temp.tatbl = (QMTranActTable const *)(tatbl_), \
N        (QState)Q_RET_TRAN)
X#define QM_TRAN(tatbl_)     ((Q_MSM_UPCAST(me))->temp.tatbl = (QMTranActTable const *)(tatbl_),         (QState)Q_RET_TRAN)
N
N/*! Macro to call in a QM state-handler when it executes an initial
N* transition. Applicable only to QMSMs.
N*/
N#define QM_TRAN_INIT(tatbl_) \
N    ((Q_MSM_UPCAST(me))->temp.tatbl = (QMTranActTable const *)(tatbl_), \
N        (QState)Q_RET_TRAN_INIT)
X#define QM_TRAN_INIT(tatbl_)     ((Q_MSM_UPCAST(me))->temp.tatbl = (QMTranActTable const *)(tatbl_),         (QState)Q_RET_TRAN_INIT)
N
N/*! Macro to call in a QM state-handler when it executes a transition
N* to history. Applicable only to QMSMs.
N*/
N#define QM_TRAN_HIST(history_, tatbl_) \
N    ((((Q_MSM_UPCAST(me))->state.obj = (history_)), \
N      ((Q_MSM_UPCAST(me))->temp.tatbl = (QMTranActTable const *)(tatbl_))), \
N       (QState)Q_RET_TRAN_HIST)
X#define QM_TRAN_HIST(history_, tatbl_)     ((((Q_MSM_UPCAST(me))->state.obj = (history_)),       ((Q_MSM_UPCAST(me))->temp.tatbl = (QMTranActTable const *)(tatbl_))),        (QState)Q_RET_TRAN_HIST)
N
N/*! Macro to call in a QM state-handler when it executes a transition
N* to the submachine via an entry point.
N*/
N#define QM_TRAN_EP(tatbl_) \
N    ((Q_MSM_UPCAST(me))->temp.tatbl = (QMTranActTable const *)(tatbl_), \
N        (QState)Q_RET_TRAN_EP)
X#define QM_TRAN_EP(tatbl_)     ((Q_MSM_UPCAST(me))->temp.tatbl = (QMTranActTable const *)(tatbl_),         (QState)Q_RET_TRAN_EP)
N
N/*! Macro to call in a QM state-handler when it executes a transition
N* to exit point. Applicable only to QMSMs.
N*/
N#define QM_TRAN_XP(xp_, tatbl_) \
N    ((((Q_MSM_UPCAST(me))->state.act = (xp_)), \
N        ((Q_MSM_UPCAST(me))->temp.tatbl = (QMTranActTable const *)(tatbl_))),\
N        (QState)Q_RET_TRAN_XP)
X#define QM_TRAN_XP(xp_, tatbl_)     ((((Q_MSM_UPCAST(me))->state.act = (xp_)),         ((Q_MSM_UPCAST(me))->temp.tatbl = (QMTranActTable const *)(tatbl_))),        (QState)Q_RET_TRAN_XP)
N
N/*! Macro to call in a QM state-handler when it handled an event.
N* Applicable only to QMSMs.
N*/
N#define QM_HANDLED()     ((QState)Q_RET_HANDLED)
N
N/*! Macro to call in a QM state-handler when when it attempts to
N* handle an event but a guard condition evaluates to 'false' and there is
N* no other explicit way of handling the event. Applicable only to QMSMs.
N*/
N#define QM_UNHANDLED()   ((QState)Q_RET_UNHANDLED)
N
N/*! Macro to call in a QM state-handler when it designates the
N* superstate to handle an event. Applicable only to QMSMs.
N*/
N#define QM_SUPER()       ((QState)Q_RET_SUPER)
N
N/*! Macro to call in a QM submachine-handler when it designates the
N* host state to handle an event. Applicable only to QMSMs.
N*/
N#define QM_SUPER_SUB(host_) \
N    ((Q_MSM_UPCAST(me))->temp.obj = (host_), (QState)Q_RET_SUPER_SUB)
X#define QM_SUPER_SUB(host_)     ((Q_MSM_UPCAST(me))->temp.obj = (host_), (QState)Q_RET_SUPER_SUB)
N
N
N/*! Macro to call in a state-handler when it executes a regular
N* or and initial transition. Applicable to both HSMs and FSMs.
N* \include qep_qtran.c
N*/
N#define Q_TRAN(target_)  \
N    ((Q_MSM_UPCAST(me))->temp.fun = Q_STATE_CAST(target_), (QState)Q_RET_TRAN)
X#define Q_TRAN(target_)      ((Q_MSM_UPCAST(me))->temp.fun = Q_STATE_CAST(target_), (QState)Q_RET_TRAN)
N
N/*! Macro to call in a state-handler when it executes a transition
N* to history. Applicable only to HSMs.
N*
N* \usage
N* \include qep_qhist.c
N*/
N#define Q_TRAN_HIST(hist_)  \
N    ((Q_MSM_UPCAST(me))->temp.fun = (hist_), (QState)Q_RET_TRAN_HIST)
X#define Q_TRAN_HIST(hist_)      ((Q_MSM_UPCAST(me))->temp.fun = (hist_), (QState)Q_RET_TRAN_HIST)
N
N/*! Macro to call in a state-handler when it designates the
N* superstate of a given state. Applicable only to HSMs.
N*
N* \usage
N* \include qep_qtran.c
N*/
N#define Q_SUPER(super_)  \
N    ((Q_MSM_UPCAST(me))->temp.fun = Q_STATE_CAST(super_), (QState)Q_RET_SUPER)
X#define Q_SUPER(super_)      ((Q_MSM_UPCAST(me))->temp.fun = Q_STATE_CAST(super_), (QState)Q_RET_SUPER)
N
N/*! Macro to call in a state-handler when it handles an event.
N*  Applicable to both HSMs and FSMs.
N*/
N#define Q_HANDLED()      ((QState)Q_RET_HANDLED)
N
N/*! Macro to call in a state-handler when it attempts to handle
N* an event but a guard condition evaluates to 'false' and there is no other
N* explicit way of handling the event. Applicable only to HSMs.
N*/
N#define Q_UNHANDLED()    ((QState)Q_RET_UNHANDLED)
N
N/*! Macro to call in a non-hierarchical state-handler when it
N* ignores (does not handle) an event. Applicable only to FSMs.
N*/
N#define Q_IGNORED()      ((QState)Q_RET_IGNORED)
N
N
N/*! QEP reserved signals */
Nenum {
N    Q_ENTRY_SIG = 1,  /*!< signal for coding entry actions */
N    Q_EXIT_SIG,       /*!< signal for coding exit actions */
N    Q_INIT_SIG,       /*!< signal for coding initial transitions */
N    Q_USER_SIG        /*!< first signal that can be used for user signals */
N};
N
N#endif /* qep_h */
N
L 14 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil\qep_port.h" 2
N
N#endif                                                        /* qep_port_h */
L 48 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil\qf_port.h" 2
N#ifdef QK
S#include "qk.h"
N#else
N#include "qvanilla.h"                       /* "Vanilla" cooperative kernel */
L 1 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qvanilla.h" 1
N/**
N* \file
N* \brief platform-independent interface to the cooperative "vanilla" kernel.
N* \ingroup qf
N* \cond
N******************************************************************************
N* Product: QF/C
N* Last updated for version 5.3.0
N* Last updated on  2014-02-24
N*
N*                    Q u a n t u m     L e a P s
N*                    ---------------------------
N*                    innovating embedded systems
N*
N* Copyright (C) Quantum Leaps, www.state-machine.com.
N*
N* This program is open source software: you can redistribute it and/or
N* modify it under the terms of the GNU General Public License as published
N* by the Free Software Foundation, either version 3 of the License, or
N* (at your option) any later version.
N*
N* Alternatively, this program may be distributed and modified under the
N* terms of Quantum Leaps commercial licenses, which expressly supersede
N* the GNU General Public License and are specifically designed for
N* licensees interested in retaining the proprietary status of their code.
N*
N* This program is distributed in the hope that it will be useful,
N* but WITHOUT ANY WARRANTY; without even the implied warranty of
N* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
N* GNU General Public License for more details.
N*
N* You should have received a copy of the GNU General Public License
N* along with this program. If not, see <http://www.gnu.org/licenses/>.
N*
N* Contact information:
N* Web:   www.state-machine.com
N* Email: info@state-machine.com
N******************************************************************************
N* \endcond
N*/
N#ifndef qvanilla_h
N#define qvanilla_h
N
N#include "qequeue.h" /* "Vanilla" kernel uses the native QF event queue  */
L 1 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qequeue.h" 1
N/**
N* \file
N* \brief platform-independent "raw" event queue interface.
N* \ingroup qf
N* \cond
N******************************************************************************
N* Product: QF/C
N* Last updated for version 5.3.0
N* Last updated on  2014-02-17
N*
N*                    Q u a n t u m     L e a P s
N*                    ---------------------------
N*                    innovating embedded systems
N*
N* Copyright (C) Quantum Leaps, www.state-machine.com.
N*
N* This program is open source software: you can redistribute it and/or
N* modify it under the terms of the GNU General Public License as published
N* by the Free Software Foundation, either version 3 of the License, or
N* (at your option) any later version.
N*
N* Alternatively, this program may be distributed and modified under the
N* terms of Quantum Leaps commercial licenses, which expressly supersede
N* the GNU General Public License and are specifically designed for
N* licensees interested in retaining the proprietary status of their code.
N*
N* This program is distributed in the hope that it will be useful,
N* but WITHOUT ANY WARRANTY; without even the implied warranty of
N* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
N* GNU General Public License for more details.
N*
N* You should have received a copy of the GNU General Public License
N* along with this program. If not, see <http://www.gnu.org/licenses/>.
N*
N* Contact information:
N* Web:   www.state-machine.com
N* Email: info@state-machine.com
N******************************************************************************
N* \endcond
N*/
N#ifndef qequeue_h
N#define qequeue_h
N
N/**
N* \description
N* This header file must be included in all QF ports that use native QF
N* event queue for active objects. Also, this file needs to be included
N* in the QP/C library when the application uses QActive_defer()/
N* QActive_recall(). Finally, this file is also needed when the "raw"
N* thread-safe queues are used for communication between active objects
N* and non-framework entities, such as ISRs, device drivers, or legacy
N* code.
N*/
N
N#ifndef QF_EQUEUE_CTR_SIZE
N
N    /*! The size (in bytes) of the ring-buffer counters used in the
N    * native QF event queue implementation. Valid values: 1, 2, or 4;
N    * default 1. */
N    /**
N    * \description
N    * This macro can be defined in the QF port file (qf_port.h) to
N    * configure the ::QEQueueCtr type. Here the macro is not defined so the
N    * default of 1 byte is chosen.
N    */
N    #define QF_EQUEUE_CTR_SIZE 1
N#endif
N#if (QF_EQUEUE_CTR_SIZE == 1)
X#if (1 == 1)
N
N    /*! The data type to store the ring-buffer counters based on
N    * the macro #QF_EQUEUE_CTR_SIZE. */
N    /**
N    * \description
N    * The dynamic range of this data type determines the maximum length
N    * of the ring buffer managed by the native QF event queue.
N    */
N    typedef uint_fast8_t QEQueueCtr;
N#elif (QF_EQUEUE_CTR_SIZE == 2)
S    typedef uint_fast16_t QEQueueCtr;
S#elif (QF_EQUEUE_CTR_SIZE == 4)
S    typedef uint_fast32_t QEQueueCtr;
S#else
S    #error "QF_EQUEUE_CTR_SIZE defined incorrectly, expected 1, 2, or 4"
N#endif
N
N/****************************************************************************/
N/*! Native QF Event Queue */
N/**
N* \description
N* This class describes the native QF event queue, which can be used as
N* the event queue for active objects, or as a simple "raw" event queue for
N* thread-safe event passing among non-framework entities, such as ISRs,
N* device drivers, or other third-party components.\n
N* \n
N* The native QF event queue is configured by defining the macro
N* #QF_EQUEUE_TYPE as ::QEQueue in the specific QF port header file.\n
N* \n
N* The ::QEQueue structure contains only data members for managing an event
N* queue, but does not contain the storage for the queue buffer, which must
N* be provided externally during the queue initialization.\n
N* \n
N* The event queue can store only event pointers, not the whole events. The
N* internal implementation uses the standard ring-buffer plus one external
N* location that optimizes the queue operation for the most frequent case
N* of empty queue.\n
N* \n
N* The ::QEQueue structure is used with two sets of functions. One set is for
N* the active object event queue, which might need to block the active object
N* task when the event queue is empty and might need to unblock it when
N* events are posted to the queue. The interface for the native active object
N* event queue consists of the following functions: QActive_post(),
N* QActive_postLIFO(), and QActive_get_(). Additionally the function
N* QEQueue_init() is used to initialize the queue.\n
N* \n
N* The other set of functions, uses ::QEQueue as a simple "raw" event
N* queue to pass events between entities other than active objects, such as
N* ISRs. The "raw" event queue is not capable of blocking on the get()
N* operation, but is still thread-safe because it uses QF critical section
N* to protect its integrity. The interface for the "raw" thread-safe queue
N* consists of the following functions: QEQueue_post(),
N* QEQueue_postLIFO(), and QEQueue_get(). Additionally the function
N* QEQueue_init() is used to initialize the queue.
N*
N* \note Most event queue operations (both the active object queues and
N* the "raw" queues) internally use  the QF critical section. You should be
N* careful not to invoke those operations from other critical sections when
N* nesting of critical sections is not supported.
N*
N* \sa ::QEQueue for the description of the data members
N*/
Ntypedef struct QEQueue {
N    /*! pointer to event at the front of the queue. */
N    /**
N    * \description
N    * All incoming and outgoing events pass through the frontEvt location.
N    * When the queue is empty (which is most of the time), the extra
N    * frontEvt location allows to bypass the ring buffer altogether,
N    * greatly optimizing the performance of the queue. Only bursts of events
N    * engage the ring buffer.
N    *
N    * \note The additional role of this attribute is to indicate the empty
N    * status of the queue. The queue is empty when frontEvt is NULL.
N    */
N    QEvt const * volatile frontEvt;
N
N    /*! pointer to the start of the ring buffer. */
N    QEvt const **ring;
N
N    /*! offset of the end of the ring buffer from the start of the buffer. */
N    QEQueueCtr end;
N
N    /*! offset to where next event will be inserted into the buffer. */
N    QEQueueCtr volatile head;
N
N    /*! offset of where next event will be extracted from the buffer. */
N    QEQueueCtr volatile tail;
N
N    /*! number of free events in the ring buffer. */
N    QEQueueCtr volatile nFree;
N
N    /*! minimum number of free events ever in the ring buffer. */
N    /**
N    * \description
N    * this attribute remembers the low-watermark of the ring buffer,
N    * which provides a valuable information for sizing event queues.
N    * \sa QF_getQueueMargin().
N    */
N    QEQueueCtr nMin;
N} QEQueue;
N
N/* public class operations */
N
N/*! Initialize the native QF event queue */
Nvoid QEQueue_init(QEQueue * const me,
N                  QEvt const *qSto[], uint_fast16_t const qLen);
N
N/*! Post an event to the "raw" thread-safe event queue (FIFO). */
Nbool QEQueue_post(QEQueue * const me, QEvt const * const e,
X_Bool QEQueue_post(QEQueue * const me, QEvt const * const e,
N                  uint_fast16_t const margin);
N
N/*! Post an event to the "raw" thread-safe event queue (LIFO). */
Nvoid QEQueue_postLIFO(QEQueue * const me, QEvt const * const e);
N
N/*! Obtain an event from the "raw" thread-safe queue. */
NQEvt const *QEQueue_get(QEQueue * const me);
N
N/*! "raw" thread-safe QF event queue operation for obtaining the number
N* of free entries still available in the queue. */
N/**
N* \description
N* This operation needs to be used with caution because the number of free
N* entries can change unexpectedly. The main intent for using this operation
N* is in conjunction with event deferral. In this case the queue is accessed
N* only from a single thread (by a single AO),  so the number of free
N* entries cannot change unexpectedly.
N*
N* \arguments
N* \arg[in] \c me_ pointer (see \ref derivation)
N*
N* \returns the current number of free slots in the queue.
N*/
N#define QEQueue_getNFree(me_) ((me_)->nFree)
N
N/*! "raw" thread-safe QF event queue operation to find out if the queue
N* is empty. */
N/**
N* \description
N* This operation needs to be used with caution because the queue status
N* can change unexpectedly. The main intent for using this operation is in
N* conjunction with event deferral. In this case the queue is accessed only
N* from a single thread (by a single AO), so no other entity can post
N* events to the queue.
N*
N* \arguments
N* \arg[in] \c me_  pointer (see \ref derivation)
N*
N* \returns 'true' if the queue is current empty and 'false' otherwise.
N*/
N#define QEQueue_isEmpty(me_) ((me_)->frontEvt == (QEvt const *)0)
N
N#endif /* qequeue_h */
N
L 45 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qvanilla.h" 2
N#include "qmpool.h"  /* "Vanilla" kernel uses the native QF memory pool  */
L 1 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qmpool.h" 1
N/**
N* \file
N* \brief platform-independent memory pool ::QMPool interface.
N* \ingroup qf
N* \cond
N******************************************************************************
N* Product: QF/C
N* Last updated for version 5.3.0
N* Last updated on  2014-04-10
N*
N*                    Q u a n t u m     L e a P s
N*                    ---------------------------
N*                    innovating embedded systems
N*
N* Copyright (C) Quantum Leaps, www.state-machine.com.
N*
N* This program is open source software: you can redistribute it and/or
N* modify it under the terms of the GNU General Public License as published
N* by the Free Software Foundation, either version 3 of the License, or
N* (at your option) any later version.
N*
N* Alternatively, this program may be distributed and modified under the
N* terms of Quantum Leaps commercial licenses, which expressly supersede
N* the GNU General Public License and are specifically designed for
N* licensees interested in retaining the proprietary status of their code.
N*
N* This program is distributed in the hope that it will be useful,
N* but WITHOUT ANY WARRANTY; without even the implied warranty of
N* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
N* GNU General Public License for more details.
N*
N* You should have received a copy of the GNU General Public License
N* along with this program. If not, see <http://www.gnu.org/licenses/>.
N*
N* Contact information:
N* Web:   www.state-machine.com
N* Email: info@state-machine.com
N******************************************************************************
N* \endcond
N*/
N#ifndef qmpool_h
N#define qmpool_h
N
N/****************************************************************************/
N#ifndef QF_MPOOL_SIZ_SIZE
N    /*! macro to override the default ::QMPoolSize size.
N    * Valid values 1, 2, or 4; default 2
N    */
N    #define QF_MPOOL_SIZ_SIZE 2
N#endif
N#if (QF_MPOOL_SIZ_SIZE == 1)
X#if (2 == 1)
S
S    /*! The data type to store the block-size based on the macro
S    * #QF_MPOOL_SIZ_SIZE.
S    */
S    /**
S    * \description
S    * The dynamic range of this data type determines the maximum size
S    * of blocks that can be managed by the native QF event pool.
S    */
S    typedef uint8_t QMPoolSize;
N#elif (QF_MPOOL_SIZ_SIZE == 2)
X#elif (2 == 2)
N
N    typedef uint16_t QMPoolSize;
N#elif (QF_MPOOL_SIZ_SIZE == 4)
S    typedef uint32_t QMPoolSize;
S#else
S    #error "QF_MPOOL_SIZ_SIZE defined incorrectly, expected 1, 2, or 4"
N#endif
N
N/****************************************************************************/
N#ifndef QF_MPOOL_CTR_SIZE
N    /*! macro to override the default ::QMPoolCtr size.
N    * Valid values 1, 2, or 4; default 2
N    */
N    #define QF_MPOOL_CTR_SIZE 2
N#endif
N#if (QF_MPOOL_CTR_SIZE == 1)
X#if (2 == 1)
S
S    /*! The data type to store the block-counter based on the macro
S    * #QF_MPOOL_CTR_SIZE.
S    */
S    /**
S    * \description
S    * The dynamic range of this data type determines the maximum number
S    * of blocks that can be stored in the pool.
S    */
S    typedef uint8_t QMPoolCtr;
N#elif (QF_MPOOL_CTR_SIZE == 2)
X#elif (2 == 2)
N    typedef uint16_t QMPoolCtr;
N#elif (QF_MPOOL_CTR_SIZE == 4)
S    typedef uint32_t QMPoolCtr;
S#else
S    #error "QF_MPOOL_CTR_SIZE defined incorrectly, expected 1, 2, or 4"
N#endif
N
N/****************************************************************************/
N/*! Native QF Memory Pool */
N/**
N* \description
N* A fixed block-size memory pool is a very fast and efficient data
N* structure for dynamic allocation of fixed block-size chunks of memory.
N* A memory pool offers fast and deterministic allocation and recycling of
N* memory blocks and is not subject to fragmenation.\n
N* \n
N* The ::QMPool class describes the native QF memory pool, which can be used as
N* the event pool for dynamic event allocation, or as a fast, deterministic
N* fixed block-size heap for any other objects in your application.
N*
N* \note
N* ::QMPool contains only data members for managing a memory pool, but
N* does not contain the pool storage, which must be provided externally
N* during the pool initialization.
N*
N* \note
N* The native QF event pool is configured by defining the macro
N* #QF_EPOOL_TYPE_ as ::QMPool in the specific QF port header file.
N*/
Ntypedef struct {
N    /*! The head of the linked list of free blocks */
N    void * volatile free_head;
N
N    /*! the original start this pool */
N    void *start;
N
N    /*! the last memory block managed by this memory pool */
N    void *end;
N
N    /*!  maximum block size (in bytes) */
N    QMPoolSize blockSize;
N
N    /*! total number of blocks */
N    QMPoolCtr nTot;
N
N    /*! number of free blocks remaining */
N    QMPoolCtr volatile nFree;
N
N    /*! minimum number of free blocks ever present in this pool */
N    /**
N    * \description
N    * this attribute remembers the low watermark of the pool, which
N    * provides a valuable information for sizing event pools.
N    * \sa QF_getPoolMin().
N    */
N    QMPoolCtr nMin;
N} QMPool;
N
N/* public functions: */
N
N/*! Initializes the native QF memory pool */
Nvoid QMPool_init(QMPool * const me, void * const poolSto,
N                 uint_fast16_t poolSize, uint_fast16_t blockSize);
N
N/*! Obtains a memory block from a memory pool. */
Nvoid *QMPool_get(QMPool * const me, uint_fast16_t const margin);
N
N/*! Recycles a memory block back to a memory pool. */
Nvoid QMPool_put(QMPool * const me, void *b);
N
N/*! Memory pool element to allocate correctly aligned storage
N* for QMPool class.
N*/
N/**
N* \arguments
N* \arg[in] \c evType_ event type (name of the subclass of QEvt)
N*/
N#define QF_MPOOL_EL(evType_) \
N    struct { void *sto_[((sizeof(evType_) - 1U)/sizeof(void*)) + 1U]; }
X#define QF_MPOOL_EL(evType_)     struct { void *sto_[((sizeof(evType_) - 1U)/sizeof(void*)) + 1U]; }
N
N#endif /* qmpool_h */
N
L 46 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qvanilla.h" 2
N#include "qpset.h"   /* "Vanilla" kernel uses the native QF priority set */
L 1 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qpset.h" 1
N/**
N* \file
N* \brief platform-independent priority sets of 8 or 64 elements.
N* \ingroup qf
N* \cond
N******************************************************************************
N* Product: QF/C
N* Last updated for version 5.3.0
N* Last updated on  2014-02-24
N*
N*                    Q u a n t u m     L e a P s
N*                    ---------------------------
N*                    innovating embedded systems
N*
N* Copyright (C) Quantum Leaps, www.state-machine.com.
N*
N* This program is open source software: you can redistribute it and/or
N* modify it under the terms of the GNU General Public License as published
N* by the Free Software Foundation, either version 3 of the License, or
N* (at your option) any later version.
N*
N* Alternatively, this program may be distributed and modified under the
N* terms of Quantum Leaps commercial licenses, which expressly supersede
N* the GNU General Public License and are specifically designed for
N* licensees interested in retaining the proprietary status of their code.
N*
N* This program is distributed in the hope that it will be useful,
N* but WITHOUT ANY WARRANTY; without even the implied warranty of
N* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
N* GNU General Public License for more details.
N*
N* You should have received a copy of the GNU General Public License
N* along with this program. If not, see <http://www.gnu.org/licenses/>.
N*
N* Contact information:
N* Web:   www.state-machine.com
N* Email: info@state-machine.com
N******************************************************************************
N* \endcond
N*/
N#ifndef qpset_h
N#define qpset_h
N
N/****************************************************************************/
N/*! Priority Set of up to 8 elements for building various schedulers */
N/**
N* The priority set represents the set of active objects that are ready to
N* run and need to be considered by the scheduling algorithm. The set is
N* capable of storing up to 8 priority levels.
N*
N* The priority set allows to build cooperative multitasking schedulers
N* to manage up to 8 tasks.
N*/
Ntypedef struct {
N    uint_fast8_t volatile bits;  /*!< bitmask with a bit for each element */
N} QPSet8;
N
N/*! Evaluates to TRUE if the priority set \c me_ has elements */
N#define QPSet8_isEmpty(me_) ((me_)->bits == (uint_fast8_t)0)
N
N/*! Evaluates to TRUE if the priority set \c me_ is empty */
N#define QPSet8_notEmpty(me_) ((me_)->bits != (uint_fast8_t)0)
N
N/*! Evaluates to TRUE if the priority set \c me_ has element \c n_ */
N#define QPSet8_hasElement(me_, n_) \
N    (((me_)->bits & (uint_fast8_t)Q_ROM_BYTE(QF_pwr2Lkup[(n_)])) \
N    != (uint_fast8_t)0)
X#define QPSet8_hasElement(me_, n_)     (((me_)->bits & (uint_fast8_t)Q_ROM_BYTE(QF_pwr2Lkup[(n_)]))     != (uint_fast8_t)0)
N
N/*! Insert element \c n_ into the set \c me_, n_= 1..8 */
N#define QPSet8_insert(me_, n_) \
N    ((me_)->bits |= (uint_fast8_t)Q_ROM_BYTE(QF_pwr2Lkup[(n_)]))
X#define QPSet8_insert(me_, n_)     ((me_)->bits |= (uint_fast8_t)Q_ROM_BYTE(QF_pwr2Lkup[(n_)]))
N
N/*! Remove element n_ from the set \c me_, n_= 1..8 */
N#define QPSet8_remove(me_, n_) \
N    ((me_)->bits &= (uint_fast8_t)Q_ROM_BYTE(QF_invPwr2Lkup[(n_)]))
X#define QPSet8_remove(me_, n_)     ((me_)->bits &= (uint_fast8_t)Q_ROM_BYTE(QF_invPwr2Lkup[(n_)]))
N
N/*! Find the maximum element in the set, and assign it to n_ */
N/** \note if the set \c me_ is empty, \c n_ is set to zero.
N*/
N#define QPSet8_findMax(me_, n_) \
N    ((n_) = (uint_fast8_t)QF_LOG2((me_)->bits))
X#define QPSet8_findMax(me_, n_)     ((n_) = (uint_fast8_t)QF_LOG2((me_)->bits))
N
N
N/****************************************************************************/
N/*! Priority Set of up to 64 elements for building various schedulers */
N/**
N* The priority set represents the set of active objects that are ready to
N* run and need to be considered by the scheduling algorithm. The set is
N* capable of storing up to 64 priority levels.
N*
N* The priority set allows to build cooperative multitasking schedulers
N* to manage up to 64 tasks. It is also used in the Quantum Kernel (QK)
N* preemptive scheduler.
N*/
Ntypedef struct {
N
N    /** \brief bimask representing 8-element subsets of the set
N    *
N    * Each bit in the bytes set represents a subset (8-elements)
N    * as follows: \n
N    * bit 0 in bytes is 1 when bits[0] is not empty \n
N    * bit 1 in bytes is 1 when bits[1] is not empty \n
N    * bit 2 in bytes is 1 when bits[2] is not empty \n
N    * bit 3 in bytes is 1 when bits[3] is not empty \n
N    * bit 4 in bytes is 1 when bits[4] is not empty \n
N    * bit 5 in bytes is 1 when bits[5] is not empty \n
N    * bit 6 in bytes is 1 when bits[6] is not empty \n
N    * bit 7 in bytes is 1 when bits[7] is not empty \n
N    */
N    uint_fast8_t volatile bytes;
N
N    /** \brief bits representing elements in the set as follows: \n
N    * bits[0] represent elements  1..8  \n
N    * bits[1] represent elements  9..16 \n
N    * bits[2] represent elements 17..24 \n
N    * bits[3] represent elements 25..32 \n
N    * bits[4] represent elements 33..40 \n
N    * bits[5] represent elements 41..48 \n
N    * bits[6] represent elements 49..56 \n
N    * bits[7] represent elements 57..64 \n
N    */
N    uint_fast8_t volatile bits[8];
N} QPSet64;
N
N/*! Evaluates to TRUE if the priority set \c me_ has elements */
N#define QPSet64_isEmpty(me_)    ((me_)->bytes == (uint_fast8_t)0)
N
N/*! Evaluates to TRUE if the priority set \c me is empty */
N#define QPSet64_notEmpty(me_)   ((me_)->bytes != (uint_fast8_t)0)
N
N/*! Evaluates to TRUE if the priority set \c me_ has element \c n_. */
N#define QPSet64_hasElement(me_, n_) \
N    (((me_)->bits[Q_ROM_BYTE(QF_div8Lkup[(n_)])] \
N      & (uint_fast8_t)Q_ROM_BYTE(QF_pwr2Lkup[(n_)])) != ((uint_fast8_t)0)
X#define QPSet64_hasElement(me_, n_)     (((me_)->bits[Q_ROM_BYTE(QF_div8Lkup[(n_)])]       & (uint_fast8_t)Q_ROM_BYTE(QF_pwr2Lkup[(n_)])) != ((uint_fast8_t)0)
N
N/*! insert element \c n_ into the set \c me_, n_= 1..64 */
N#define QPSet64_insert(me_, n_) do { \
N    uint_fast8_t m_  = (uint_fast8_t)Q_ROM_BYTE(QF_div8Lkup[(n_)]); \
N    (me_)->bits[m_] |= (uint_fast8_t)Q_ROM_BYTE(QF_pwr2Lkup[(n_)]); \
N    (me_)->bytes    |= (uint_fast8_t)Q_ROM_BYTE(QF_pwr2Lkup[m_ \
N                                               + (uint_fast8_t)1]); \
N} while (0)
X#define QPSet64_insert(me_, n_) do {     uint_fast8_t m_  = (uint_fast8_t)Q_ROM_BYTE(QF_div8Lkup[(n_)]);     (me_)->bits[m_] |= (uint_fast8_t)Q_ROM_BYTE(QF_pwr2Lkup[(n_)]);     (me_)->bytes    |= (uint_fast8_t)Q_ROM_BYTE(QF_pwr2Lkup[m_                                                + (uint_fast8_t)1]); } while (0)
N
N/*! Remove element n_ from the set \c me_, n_= 1..64 */
N#define QPSet64_remove(me_, n_) do { \
N    uint_fast8_t m_ = (uint_fast8_t)Q_ROM_BYTE(QF_div8Lkup[(n_)]); \
N    if (((me_)->bits[m_] &= (uint_fast8_t)Q_ROM_BYTE( \
N                            QF_invPwr2Lkup[(n_)])) == (uint_fast8_t)0) { \
N        (me_)->bytes &= (uint_fast8_t)Q_ROM_BYTE( \
N                                      QF_invPwr2Lkup[m_ + (uint_fast8_t)1]); \
N    } \
N} while (0)
X#define QPSet64_remove(me_, n_) do {     uint_fast8_t m_ = (uint_fast8_t)Q_ROM_BYTE(QF_div8Lkup[(n_)]);     if (((me_)->bits[m_] &= (uint_fast8_t)Q_ROM_BYTE(                             QF_invPwr2Lkup[(n_)])) == (uint_fast8_t)0) {         (me_)->bytes &= (uint_fast8_t)Q_ROM_BYTE(                                       QF_invPwr2Lkup[m_ + (uint_fast8_t)1]);     } } while (0)
N
N/*! Find the maximum element in the set, and assign it to \c n_ */
N/** \note if the set \c me_ is empty, \c n_ is set to zero.
N*/
N#define QPSet64_findMax(me_, n_) do { \
N    if ((me_)->bytes != (uint_fast8_t)0) { \
N        (n_) = (uint_fast8_t)QF_LOG2((me_)->bytes) - (uint_fast8_t)1; \
N        (n_) = (uint_fast8_t)QF_LOG2((me_)->bits[(n_)]) \
N                              + (uint_fast8_t)((n_) << 3); \
N    } \
N    else { \
N       (n_) = (uint_fast8_t)0; \
N    } \
N} while (0)
X#define QPSet64_findMax(me_, n_) do {     if ((me_)->bytes != (uint_fast8_t)0) {         (n_) = (uint_fast8_t)QF_LOG2((me_)->bytes) - (uint_fast8_t)1;         (n_) = (uint_fast8_t)QF_LOG2((me_)->bits[(n_)])                               + (uint_fast8_t)((n_) << 3);     }     else {        (n_) = (uint_fast8_t)0;     } } while (0)
N
N#endif /* qpset_h */
N
L 47 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qvanilla.h" 2
N
N/*! This macro defines the type of the event queue used for the
N* active objects. For the built-in Vanilla kernel, this is ::QEqueue.
N*/
N#define QF_EQUEUE_TYPE  QEQueue
N
N/*! QF idle callback (customized in BSPs for QF) */
N/**
N* \description
N* QF_onIdle() is called by the non-preemptive "Vanilla" scheduler
N* (from QF_run()) when the scheduler detects that no events are available
N* for active objects (the idle condition). This callback gives the
N* application an opportunity to enter a power-saving CPU mode, or perform
N* some other idle processing (such as Q-Spy output).
N*
N* \note QF_onIdle() is invoked with interrupts DISABLED because the idle
N* condition can be asynchronously changed at any time by an interrupt.
N* QF_onIdle() MUST enable the interrupts internally, but not before
N* putting the CPU into the low-power mode. (Ideally, enabling interrupts and
N* low-power mode should happen atomically). At the very least, the function
N* MUST enable interrupts, otherwise interrupts will remain disabled
N* permanently.
N*
N* \note QF_onIdle() is only used by the non-preemptive "Vanilla" scheduler
N* in the "bare metal" QF port, and is NOT used in any other QF ports. When
N* QF is combined with QK, the QK idle loop calls a different function
N* QK_onIdle(), with different semantics than QF_onIdle(). When QF is
N* combined with a 3rd-party RTOS or kernel, the idle processing mechanism
N* of the RTOS or kernel is used instead of QF_onIdle().
N*/
Nvoid QF_onIdle(void);
N
N/****************************************************************************/
N/* interface used only inside QP implementation, but not in applications */
N#ifdef QP_IMPL
S
S    /* native QF event queue operations */
S    #define QACTIVE_EQUEUE_WAIT_(me_) \
S        Q_ASSERT_ID(0, (me_)->eQueue.frontEvt != (QEvt *)0)
X    #define QACTIVE_EQUEUE_WAIT_(me_)         Q_ASSERT_ID(0, (me_)->eQueue.frontEvt != (QEvt *)0)
S
S    #if (QF_MAX_ACTIVE <= 8)
S        #define QACTIVE_EQUEUE_SIGNAL_(me_) \
S            QPSet8_insert(&QF_readySet_, (me_)->prio)
X        #define QACTIVE_EQUEUE_SIGNAL_(me_)             QPSet8_insert(&QF_readySet_, (me_)->prio)
S        #define QACTIVE_EQUEUE_ONEMPTY_(me_) \
S            QPSet8_remove(&QF_readySet_, (me_)->prio)
X        #define QACTIVE_EQUEUE_ONEMPTY_(me_)             QPSet8_remove(&QF_readySet_, (me_)->prio)
S    #else
S        #define QACTIVE_EQUEUE_SIGNAL_(me_) \
S            QPSet64_insert(&QF_readySet_, (me_)->prio)
X        #define QACTIVE_EQUEUE_SIGNAL_(me_)             QPSet64_insert(&QF_readySet_, (me_)->prio)
S        #define QACTIVE_EQUEUE_ONEMPTY_(me_) \
S            QPSet64_remove(&QF_readySet_, (me_)->prio)
X        #define QACTIVE_EQUEUE_ONEMPTY_(me_)             QPSet64_remove(&QF_readySet_, (me_)->prio)
S    #endif
S
S    /* native QF event pool operations */
S    #define QF_EPOOL_TYPE_            QMPool
S    #define QF_EPOOL_INIT_(p_, poolSto_, poolSize_, evtSize_) \
S        (QMPool_init(&(p_), (poolSto_), (poolSize_), (evtSize_)))
X    #define QF_EPOOL_INIT_(p_, poolSto_, poolSize_, evtSize_)         (QMPool_init(&(p_), (poolSto_), (poolSize_), (evtSize_)))
S    #define QF_EPOOL_EVENT_SIZE_(p_)  ((uint_fast16_t)(p_).blockSize)
S    #define QF_EPOOL_GET_(p_, e_, m_) ((e_) = (QEvt *)QMPool_get(&(p_), (m_)))
S    #define QF_EPOOL_PUT_(p_, e_)     (QMPool_put(&(p_), (e_)))
S
S    #if (QF_MAX_ACTIVE <= 8)
S        extern QPSet8 QF_readySet_;  /*!< QF-ready set of AOs */
S    #else
S        extern QPSet64 QF_readySet_; /*!< QF-ready set of AOs */
S    #endif
S
N#endif /* QP_IMPL */
N
N#endif /* qvanilla_h */
L 52 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil\qf_port.h" 2
N#endif
N
N#include "qf.h"                 /* QF platform-independent public interface */
L 1 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qf.h" 1
N/**
N* \file
N* \brief QF/C platform-independent public interface.
N* \ingroup qf
N* \cond
N******************************************************************************
N* Product: QF/C
N* Last updated for version 5.3.0
N* Last updated on  2014-02-24
N*
N*                    Q u a n t u m     L e a P s
N*                    ---------------------------
N*                    innovating embedded systems
N*
N* Copyright (C) Quantum Leaps, www.state-machine.com.
N*
N* This program is open source software: you can redistribute it and/or
N* modify it under the terms of the GNU General Public License as published
N* by the Free Software Foundation, either version 3 of the License, or
N* (at your option) any later version.
N*
N* Alternatively, this program may be distributed and modified under the
N* terms of Quantum Leaps commercial licenses, which expressly supersede
N* the GNU General Public License and are specifically designed for
N* licensees interested in retaining the proprietary status of their code.
N*
N* This program is distributed in the hope that it will be useful,
N* but WITHOUT ANY WARRANTY; without even the implied warranty of
N* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
N* GNU General Public License for more details.
N*
N* You should have received a copy of the GNU General Public License
N* along with this program. If not, see <http://www.gnu.org/licenses/>.
N*
N* Contact information:
N* Web:   www.state-machine.com
N* Email: info@state-machine.com
N******************************************************************************
N* \endcond
N*/
N#ifndef qf_h
N#define qf_h
N
N/****************************************************************************/
N#if (QF_MAX_ACTIVE < 1) || (63 < QF_MAX_ACTIVE)
X#if (8 < 1) || (63 < 8)
S    #error "QF_MAX_ACTIVE not defined or out of range. Valid range is 1..63"
N#endif
N
N#ifndef QF_EVENT_SIZ_SIZE
N    /*! Default value of the macro configurable value in qf_port.h */
N    #define QF_EVENT_SIZ_SIZE 2
N#endif
N#if (QF_EVENT_SIZ_SIZE == 1)
X#if (2 == 1)
S    typedef uint8_t QEvtSize;
N#elif (QF_EVENT_SIZ_SIZE == 2)
X#elif (2 == 2)
N    /*! The data type to store the block-size defined based on
N    * the macro #QF_EVENT_SIZ_SIZE. */
N    /**
N    * The dynamic range of this data type determines the maximum block
N    * size that can be managed by the pool.
N    */
N    typedef uint16_t QEvtSize;
N#elif (QF_EVENT_SIZ_SIZE == 4)
S    typedef uint32_t QEvtSize;
S#else
S    #error "QF_EVENT_SIZ_SIZE defined incorrectly, expected 1, 2, or 4"
N#endif
N
N#ifndef QF_MAX_EPOOL
N    /*! Default value of the macro configurable value in qf_port.h */
N    #define QF_MAX_EPOOL         3
N#endif
N
N#ifndef QF_MAX_TICK_RATE
S    /*! Default value of the macro configurable value in qf_port.h     */
S    #define QF_MAX_TICK_RATE     1
N#endif
N
N#ifndef QF_TIMEEVT_CTR_SIZE
N    /*! macro to override the default ::QTimeEvtCtr size. Valid values:
N    * 1, 2, or 4; default 2
N    */
N    #define QF_TIMEEVT_CTR_SIZE  2
N#endif
N
N/****************************************************************************/
Nstruct QEQueue; /* forward declaration */
N
N/*! QActive is the base structure for derivation of active objects */
N/**
N* \description
N* Active objects in QP are encapsulated state machines (each embedding an
N* event queue and a thread) that communicate with one another asynchronously
N* by sending and receiving events. Within an active object, events are
N* processed sequentially in a run-to-completion (RTC) fashion, while QF
N* encapsulates all the details of thread-safe event exchange and queuing.
N*
N* \note ::QActive is not intended to be instantiated directly, but rather
N* serves as the base structure for derivation of active objects in the
N* application code.
N*
N* \usage
N* The following example illustrates how to derive an active object from
N* QActive. Please note that the QActive member \c super is defined as the
N* __first__ member of the derived struct (see \ref derivation).
N* \include qf_qactive.c
N*
N* \sa ::QMActive
N*/
Ntypedef struct {
N    QHsm super; /*!< inherits ::QHsm */
N
N#ifdef QF_EQUEUE_TYPE
N    /*! OS-dependent event-queue type. */
N    /**
N    * \description
N    * The type of the queue depends on the underlying operating system or
N    * a kernel. Many kernels support "message queues" that can be adapted
N    * to deliver QF events to the active object. Alternatively, QF provides
N    * a native event queue implementation that can be used as well.
N    *
N    * \note The native QF event queue is configured by defining the macro
N    * #QF_EQUEUE_TYPE as ::QEQueue.
N    */
N    QF_EQUEUE_TYPE eQueue;
X    QEQueue eQueue;
N#endif
N
N#ifdef QF_OS_OBJECT_TYPE
S    /*! OS-dependent per-thread object. */
S    /**
S    * \description
S    * This data might be used in various ways, depending on the QF port.
S    * In some ports osObject is used to block the calling thread when
S    * the native QF queue is empty. In other QF ports the OS-dependent
S    * object might be used differently.
S    */
S    QF_OS_OBJECT_TYPE osObject;
N#endif
N
N#ifdef QF_THREAD_TYPE
S    /*! OS-dependent representation of the thread of the active object. */
S    /**
S    * \description
S    * This data might be used in various ways, depending on the QF port.
S    * In some ports thread is used to store the thread handle. In other
S    * ports thread can be the pointer to the Thread-Local-Storage (TLS).
S    */
S    QF_THREAD_TYPE thread;
N#endif
N
N    /*! QF priority associated with the active object. */
N    uint_fast8_t prio;
N
N} QActive;
N
N/*! Virtual table for the ::QActiveVtbl class */
Ntypedef struct {
N    QMsmVtbl super; /*!< inherits QMsmVtbl */
N
N    /*! virtual function to start the active object (thread) */
N    /** \sa QACTIVE_START() */
N    void (*start)(QActive * const me, uint_fast8_t prio,
N                  QEvt const *qSto[], uint_fast16_t qLen,
N                  void *stkSto, uint_fast16_t stkSize,
N                  QEvt const *ie);
N
N#ifdef Q_SPY
S    /*! virtual function to asynchronously post (FIFO) an event to an AO */
S    /** \sa QACTIVE_POST() and QACTIVE_POST_X() */
S    bool (*post)(QActive * const me, QEvt const * const e,
S                 uint_fast16_t const margin, void const * const sender);
N#else
N    bool (*post)(QActive * const me, QEvt const * const e,
X    _Bool (*post)(QActive * const me, QEvt const * const e,
N                 uint_fast16_t const margin);
N#endif
N
N    /*! virtual function to asynchronously post (LIFO) an event to an AO */
N    /** \sa QACTIVE_POST_LIFO() */
N    void (*postLIFO)(QActive * const me, QEvt const * const e);
N
N} QActiveVtbl;
N
N/* public functions */
N/*! Implementation of the active object start operation. */
Nvoid QActive_start_(QActive * const me, uint_fast8_t prio,
N                    QEvt const *qSto[], uint_fast16_t qLen,
N                    void *stkSto, uint_fast16_t stkSize,
N                    QEvt const *ie);
N
N/*! Polymorphically start an active object. */
N/**
N* \description
N* Performs the first step of FSM initialization by assigning the initial
N* pseudostate to the currently active state of the state machine.
N*
N* \arguments
N* \arg[in,out] \c me_      pointer (see \ref derivation)
N* \arg[in]     \c prio_    priority at which to start the active object
N* \arg[in]     \c qSto_    pointer to the storage for the ring buffer of the
N*                          event queue (used only with the built-in ::QEQueue)
N* \arg[in]     \c qLen_    length of the event queue (in events)
N* \arg[in]     \c stkSto_  pointer to the stack storage (used only when
N*                          per-AO stack is needed)
N* \arg[in]     \c stkSize_ stack size (in bytes)
N* \arg[in]     \c ie_      pointer to the optional initialization event
N*                          (might be NULL).
N*/
N#define QACTIVE_START(me_, prio_, qSto_, qLen_, stkSto_, stkLen_, ie_) \
N    ((*((QActiveVtbl const *)((me_)->super.vptr))->start)( \
N        (me_), (prio_), (qSto_), (qLen_), (stkSto_), (stkLen_), (ie_)))
X#define QACTIVE_START(me_, prio_, qSto_, qLen_, stkSto_, stkLen_, ie_)     ((*((QActiveVtbl const *)((me_)->super.vptr))->start)(         (me_), (prio_), (qSto_), (qLen_), (stkSto_), (stkLen_), (ie_)))
N
N#ifdef Q_SPY
S    /*! Implementation of the active object post (FIFO) operation */
S    bool QActive_post_(QActive * const me, QEvt const * const e,
S                         uint_fast16_t const margin,
S                         void const * const sender);
S
S    /*! Polymorphically posts an event to an active object (FIFO)
S    * with delivery guarantee. */
S    /**
S    * \description
S    * This macro asserts if the queue overflows and cannot accept the event.
S    *
S    * \arguments
S    * \arg[in,out] \c me_   pointer (see \ref derivation)
S    * \arg[in]     \c e_    pointer to the event to post
S    * \arg[in]     \c sender_ pointer to the sender object.
S    *
S    * \note The \c sendedr_ argument is actually only used when QS tracing
S    * is enabled (macro #Q_SPY is defined). When QS software tracing is
S    * disenabled, the QACTIVE_POST() macro does not pass the \c sender_
S    * argument, so the overhead of passing this extra argument is entirely
S    * avoided.
S    *
S    * \note the pointer to the sender object is not necessarily a pointer
S    * to an active object. In fact, if QACTIVE_POST() is called from an
S    * interrupt or other context, you can create a unique object just to
S    * unambiguously identify the sender of the event.
S    *
S    * \sa #QACTIVE_POST_X, QActive_post_().
S    */
S    #define QACTIVE_POST(me_, e_, sender_) \
S        ((void)(*((QActiveVtbl const *)((me_)->super.vptr))->post)((me_), \
S         (e_), (uint_fast16_t)0, (sender_)))
X    #define QACTIVE_POST(me_, e_, sender_)         ((void)(*((QActiveVtbl const *)((me_)->super.vptr))->post)((me_),          (e_), (uint_fast16_t)0, (sender_)))
S
S    /*! Polymorphically posts an event to an active object (FIFO)
S    * without delivery guarantee. */
S    /**
S    * \description
S    * This macro does not assert if the queue overflows and cannot accept
S    * the event with the specified margin of free slots remaining.
S    *
S    * \arguments
S    * \arg[in,out] \c me_   pointer (see \ref derivation)
S    * \arg[in]     \c e_    pointer to the event to post
S    * \arg[in]     \c margin_ the minimum free slots in the queue, which
S    *                         must still be available after posting the event
S    * \arg[in]     \c sender_ pointer to the sender object.
S    *
S    * \returns 'true' if the posting succeeded, and 'false' if the posting
S    * failed due to insufficient margin of free slots available in the queue.
S    *
S    * \note The \c sender_ argument is actually only used when QS tracing
S    * is enabled (macro #Q_SPY is defined). When QS software tracing is
S    * disabled, the QACTIVE_POST() macro does not pass the \c sender_
S    * argument, so the overhead of passing this extra argument is entirely
S    * avoided.
S    *
S    * \note the pointer to the sender object is not necessarily a pointer
S    * to an active object. In fact, if QACTIVE_POST() is called from an
S    * interrupt or other context, you can create a unique object just to
S    * unambiguously identify the sender of the event.
S    *
S    * \usage
S    * \include qf_postx.c
S    */
S    #define QACTIVE_POST_X(me_, e_, margin_, sender_) \
S        ((*((QActiveVtbl const *)((me_)->super.vptr))->post)((me_), \
S         (e_), (margin_), (sender_)))
X    #define QACTIVE_POST_X(me_, e_, margin_, sender_)         ((*((QActiveVtbl const *)((me_)->super.vptr))->post)((me_),          (e_), (margin_), (sender_)))
N#else
N
N    bool QActive_post_(QActive * const me, QEvt const * const e,
X    _Bool QActive_post_(QActive * const me, QEvt const * const e,
N                         uint_fast16_t const margin);
N
N    #define QACTIVE_POST(me_, e_, sender_) \
N        ((void)(*((QActiveVtbl const *)((me_)->super.vptr))->post)((me_), \
N                  (e_), (uint_fast16_t)0))
X    #define QACTIVE_POST(me_, e_, sender_)         ((void)(*((QActiveVtbl const *)((me_)->super.vptr))->post)((me_),                   (e_), (uint_fast16_t)0))
N
N    #define QACTIVE_POST_X(me_, e_, margin_, sender_) \
N        ((*((QActiveVtbl const *)((me_)->super.vptr))->post)((me_), \
N                  (e_), (margin_)))
X    #define QACTIVE_POST_X(me_, e_, margin_, sender_)         ((*((QActiveVtbl const *)((me_)->super.vptr))->post)((me_),                   (e_), (margin_)))
N
N#endif
N
N/*! Implementation of the active object post LIFO operation */
Nvoid QActive_postLIFO_(QActive * const me, QEvt const * const e);
N
N/*! Polymorphically posts an event to an active object using the
N* Last-In-First-Out (LIFO) policy. */
N/**
N* \arguments
N* \arg[in,out] \c me_   pointer (see \ref derivation)
N* \arg[in]     \c e_    pointer to the event to post
N*/
N#define QACTIVE_POST_LIFO(me_, e_) \
N    ((*((QActiveVtbl const *)((me_)->super.vptr))->postLIFO)((me_), (e_)))
X#define QACTIVE_POST_LIFO(me_, e_)     ((*((QActiveVtbl const *)((me_)->super.vptr))->postLIFO)((me_), (e_)))
N
N
N/* protected functions ...*/
N
N/*! protected "constructor" of an active object. */
Nvoid QActive_ctor(QActive * const me, QStateHandler initial);
N
N/*! Stops execution of an active object and removes it from the
N* framework's supervision. */
Nvoid QActive_stop(QActive * const me);
N
N/*! Subscribes for delivery of signal \a sig to the active object \a me. */
Nvoid QActive_subscribe(QActive const * const me, enum_t const sig);
N
N/*! Un-subscribes from the delivery of signal \a sig to the AO \a me. */
Nvoid QActive_unsubscribe(QActive const * const me, enum_t const sig);
N
N/*! Un-subscribes from the delivery of all signals to the AO \a me. */
Nvoid QActive_unsubscribeAll(QActive const * const me);
N
N
N/*! Defer an event to a given separate event queue. */
Nbool QActive_defer(QActive * const me,
X_Bool QActive_defer(QActive * const me,
N                   QEQueue * const eq, QEvt const * const e);
N
N/*! Recall a deferred event from a given event queue. */
Nbool QActive_recall(QActive * const me, QEQueue * const eq);
X_Bool QActive_recall(QActive * const me, QEQueue * const eq);
N
N/*! Get an event from the event queue of an active object. */
NQEvt const *QActive_get_(QActive *const me);
N
N/****************************************************************************/
N/*! QM Active Object */
N/**
N* \description
N* QMActive represents an active object version based on the ::QMsm state
N* machine. The application-level active object derived from QMActive
N* typically require the use of QM, but are the fastest and need the least
N* run-time support (the smallest event-processor taking up the least code
N* space). QMActive inherits QActive "as is" without adding new attributes,
N* so it is typedef'ed as ::QActive.
N*/
Ntypedef QActive QMActive;
N
N/*! protected "constructor" of an QMActive active object. */
Nvoid QMActive_ctor(QMActive * const me, QStateHandler initial);
N
N/****************************************************************************/
N#if (QF_TIMEEVT_CTR_SIZE == 1)
X#if (2 == 1)
S    typedef uint8_t QTimeEvtCtr;
N#elif (QF_TIMEEVT_CTR_SIZE == 2)
X#elif (2 == 2)
N
N    /*! type of the Time Event counter, which determines the dynamic
N    * range of the time delays measured in clock ticks. */
N    /**
N    * \description
N    * This typedef is configurable via the preprocessor switch
N    * #QF_TIMEEVT_CTR_SIZE. The other possible values of this type are
N    * as follows: \n
N    * uint8_t when (QF_TIMEEVT_CTR_SIZE == 1), and \n
N    * uint32_t when (QF_TIMEEVT_CTR_SIZE == 4).
N    */
N    typedef uint16_t QTimeEvtCtr;
N#elif (QF_TIMEEVT_CTR_SIZE == 4)
S    typedef uint32_t QTimeEvtCtr;
S#else
S    #error "QF_TIMEEVT_CTR_SIZE defined incorrectly, expected 1, 2, or 4"
N#endif
N
N/*! Time Event structure */
N/**
N* \description
N* Time events are special QF events equipped with the notion of time passage.
N* The basic usage model of the time events is as follows. An active object
N* allocates one or more QTimeEvt objects (provides the storage for them).
N* When the active object needs to arrange for a timeout, it arms one of its
N* time events to fire either just once (one-shot) or periodically. Each time
N* event times out independently from the others, so a QF application can make
N* multiple parallel timeout requests (from the same or different active
N* objects). When QF detects that the appropriate moment has arrived, it
N* inserts the time event directly into the recipient's event queue. The
N* recipient then processes the time event just like any other event.
N*
N* Time events, as any other QF events derive from the ::QEvt base structure.
N* Typically, you will use a time event as-is, but you can also further
N* derive more specialized time events from it by adding some more data
N* members and/or specialized functions that operate on the specialized
N* time events.
N*
N* Internally, the armed time events are organized into linked lists--one list
N* for every supported ticking rate. These linked lists are scanned in every
N* invocation of the QF_tickX_() function. Only armed (timing out) time events
N* are in the list, so only armed time events consume CPU cycles.
N*
N* \sa ::QTimeEvt for the description of the data members \n \ref derivation
N*
N* \note QF manages the time events in the function QF_tickX_(), which
N* must be called periodically, preferably from the clock tick ISR.
N*
N* \note In this version of QF QTimeEvt objects should be allocated statically
N* rather than dynamically from event pools. Currently, QF will not correctly
N* recycle the dynamically allocated Time Events.
N*/
Ntypedef struct QTimeEvt {
N    /*! base structure from which QTimeEvt derives */
N    QEvt super;
N
N    /*! link to the next time event in the list */
N    struct QTimeEvt * volatile next;
N
N    /*! the active object that receives the time events */
N    void * volatile act;
N
N    /*! the internal down-counter of the time event. */
N    /**
N    * \description
N    * The down-counter is decremented by 1 in every QF_tickX_() invocation.
N    * The time event fires (gets posted or published) when the down-counter
N    * reaches zero.
N    */
N    QTimeEvtCtr volatile ctr;
N
N    /*! the interval for periodic time event (zero for one-shot time event) */
N    /**
N    * \description
N    * The value of the interval is re-loaded to the internal down-counter
N    * when the time event expires, so that the time event keeps timing out
N    * periodically.
N    */
N    QTimeEvtCtr interval;
N} QTimeEvt;
N
N/* public functions */
N
N/*! The extended "constructor" to initialize a Time Event. */
Nvoid QTimeEvt_ctorX(QTimeEvt * const me, QActive * const act,
N                    enum_t const sig, uint_fast8_t tickRate);
N
N/*! Arm a time event (one shot or periodic) for direct event posting. */
Nvoid QTimeEvt_armX(QTimeEvt * const me,
N                   QTimeEvtCtr const nTicks, QTimeEvtCtr const interval);
N
N/*! Rearm a time event. */
Nbool QTimeEvt_rearm(QTimeEvt * const me, QTimeEvtCtr const nTicks);
X_Bool QTimeEvt_rearm(QTimeEvt * const me, QTimeEvtCtr const nTicks);
N
N/*! Disarm a time event. */
Nbool QTimeEvt_disarm(QTimeEvt * const me);
X_Bool QTimeEvt_disarm(QTimeEvt * const me);
N
N/*! Get the current value of the down-counter of a time event. */
NQTimeEvtCtr QTimeEvt_ctr(QTimeEvt const * const me);
N
N/****************************************************************************/
N/* QF facilities */
N
N/*! Subscriber-List structure */
N/**
N* \description
N* This data type represents a set of active objects that subscribe to
N* a given signal. The set is represented as an array of bits, where each
N* bit corresponds to the unique priority of an active object.
N*
N* \sa ::QSubscrList for the description of the data members
N*/
Ntypedef struct {
N
N    /*! An array of bits representing subscriber active objects. */
N    /**
N    * \description
N    * Each bit in the array corresponds to the unique priority of the AO.
N    * The size of the array is determined of the maximum number of AOs
N    * in the application configured by the #QF_MAX_ACTIVE macro.
N    * For example, an active object of priority p is a subscriber if the
N    * following is true: ((bits[QF_div8Lkup[p]] & QF_pwr2Lkup[p]) != 0)
N    *
N    * \sa QF_psInit(), ::QF_div8Lkup, ::QF_pwr2Lkup, #QF_MAX_ACTIVE
N    */
N    uint8_t bits[((QF_MAX_ACTIVE - 1) / 8) + 1];
X    uint8_t bits[((8 - 1) / 8) + 1];
N} QSubscrList;
N
N/* public functions */
N
N/*! QF initialization. */
Nvoid QF_init(void);
N
N/*! Publish-subscribe initialization. */
Nvoid QF_psInit(QSubscrList * const subscrSto, enum_t const maxSignal);
N
N/*! Event pool initialization for dynamic allocation of events. */
Nvoid QF_poolInit(void * const poolSto, uint_fast16_t const poolSize,
N                 uint_fast16_t const evtSize);
N
N/*! Transfers control to QF to run the application. */
Nint_t QF_run(void);
N
N/*! Function invoked by the application layer to stop the QF
N* application and return control to the OS/Kernel. */
Nvoid QF_stop(void);
N
N/*! Startup QF callback. */
N/**
N* \description
N* The timeline for calling QF_onStartup() depends on the particular
N* QF port. In most cases, QF_onStartup() is called from QF_run(), right
N* before starting any multitasking kernel or the background loop.
N*/
Nvoid QF_onStartup(void);
N
N/*! Cleanup QF callback. */
N/**
N* \description
N* QF_onCleanup() is called in some QF ports before QF returns to the
N* underlying operating system or RTOS.
N*
N* This function is strongly platform-specific and is not implemented in
N* the QF, but either in the QF port or in the Board Support Package (BSP)
N* for the given application. Some QF ports might not require implementing
N* QF_onCleanup() at all, because many embedded applications don't have
N* anything to exit to.
N*
N* \sa QF_stop()
N*/
Nvoid QF_onCleanup(void);
N
N#ifdef Q_SPY
S
S    /*! Publish event to the framework. */
S    void QF_publish_(QEvt const * const e, void const * const sender);
S
S    /*! Invoke the event publishing facility QF_publish_(). */
S    /**
S    * \description
S    * This macro is the recommended way of publishing events, because it
S    * provides the vital information for software tracing and avoids any
S    * overhead when the tracing is disabled.
S    *
S    * \arguments
S    * \arg[in] \c e_      pointer to the posted event
S    * \arg[in] \c sender_ pointer to the sender object. This argument is
S    *          actually only used when QS software tracing is enabled
S    *          (macro #Q_SPY is defined). When QS software tracing is
S    *          disabled, the macro calls QF_publish_() without the
S    *          \c sender_ argument, so the overhead of passing this
S    *          extra argument is entirely avoided.
S    *
S    * \note the pointer to the sender object is not necessarily a pointer
S    * to an active object. In fact, if QF_PUBLISH() is called from an
S    * interrupt or other context, you can create a unique object just to
S    * unambiguously identify the publisher of the event.
S    *
S    * \sa QF_publish_().
S    */
S    #define QF_PUBLISH(e_, sender_) \
S        (QF_publish_((e_), (void const *)(sender_)))
X    #define QF_PUBLISH(e_, sender_)         (QF_publish_((e_), (void const *)(sender_)))
N#else
N
N    void QF_publish_(QEvt const * const e);
N    #define QF_PUBLISH(e_, dummy_)   (QF_publish_(e_))
N
N#endif
N
N#ifdef Q_SPY
S
S    /*! Processes all armed time events at every clock tick. */
S    void QF_tickX_(uint_fast8_t const tickRate, void const * const sender);
S
S    /*! Invoke the system clock tick processing QF_tickX_(). */
S    /**
S    * \description
S    * This macro is the recommended way of invoking clock tick processing,
S    * because it provides the vital information for software tracing and
S    * avoids any overhead when the tracing is disabled.
S    *
S    * \arguments
S    * \arg[in] \c tickRate clock tick rate to be serviced through this call
S    * \arg[in] \c sender   pointer to the sender object. This argument
S    *            is actually only used when QS software tracing is enabled
S    *            (macro #Q_SPY is defined)
S    * \note
S    * When QS software tracing is disabled, the macro calls QF_tickX_()
S    * without the \c sender argument, so the overhead of passing this
S    * extra argument is entirely avoided.
S    *
S    * \note
S    * The pointer to the sender object is not necessarily a pointer
S    * to an active object. In fact, when #QF_TICK_X() is called from
S    * an interrupt, you would create a unique object just to unambiguously
S    * identify the ISR as the sender of the time events.
S    *
S    * \sa QF_tickX_().
S    */
S    #define QF_TICK_X(tickRate_, sender_) (QF_tickX_((tickRate_), (sender_)))
S
N#else
N
N    void QF_tickX_(uint_fast8_t const tickRate);
N    #define QF_TICK_X(tickRate_, dummy)   (QF_tickX_(tickRate_))
N
N#endif
N
N/*! Invoke the system clock tick processing for rate 0 */
N#define QF_TICK(sender_)   QF_TICK_X((uint_fast8_t)0, (sender_))
N
N/*! Returns 'true' if there are no armed time events at a given tick rate */
Nbool QF_noTimeEvtsActiveX(uint_fast8_t const tickRate);
X_Bool QF_noTimeEvtsActiveX(uint_fast8_t const tickRate);
N
N/*! Register an active object to be managed by the framework */
Nvoid QF_add_(QActive * const a);
N
N/*! Remove the active object from the framework. */
Nvoid QF_remove_(QActive const * const a);
N
N/*! Obtain the minimum of free entries of the given event pool. */
Nuint_fast16_t QF_getPoolMin(uint_fast8_t const poolId);
N
N/*! This function returns the minimum of free entries of
N* the given event queue. */
Nuint_fast16_t QF_getQueueMin(uint_fast8_t const prio);
N
N/*! Internal QP implementation of the dynamic event allocator. */
NQEvt *QF_newX_(uint_fast16_t const evtSize,
N               uint_fast16_t const margin, enum_t const sig);
N
N#ifdef Q_EVT_CTOR /* Shall the constructor for the QEvt class be provided? */
S
S    #define Q_NEW(evtT_, sig_, ...) \
S        (evtT_##_ctor((evtT_ *)QF_newX_((uint_fast16_t)sizeof(evtT_), \
S                      (uint_fast16_t)0, (enum_t)0), (sig_), ##__VA_ARGS__))
X    #define Q_NEW(evtT_, sig_, ...)         (evtT_##_ctor((evtT_ *)QF_newX_((uint_fast16_t)sizeof(evtT_),                       (uint_fast16_t)0, (enum_t)0), (sig_), ##__VA_ARGS__))
S
S    #define Q_NEW_X(e_, evtT_, margin_, sig_, ...) do { \
S        (e_) = (evtT_ *)QF_newX_((uint_fast16_t)sizeof(evtT_), \
S                                 (margin_), (enum_t)0); \
S        if ((e_) != (evtT_ *)0) { \
S            evtT_##_ctor((e_), (sig_), ##__VA_ARGS__); \
S        } \
S     } while (0)
X    #define Q_NEW_X(e_, evtT_, margin_, sig_, ...) do {         (e_) = (evtT_ *)QF_newX_((uint_fast16_t)sizeof(evtT_),                                  (margin_), (enum_t)0);         if ((e_) != (evtT_ *)0) {             evtT_##_ctor((e_), (sig_), ##__VA_ARGS__);         }      } while (0)
S
N#else
N
N    /*! Allocate a dynamic event. */
N    /**
N    * \description
N    * The macro calls the internal QF function QF::newX_() with
N    * margin == 0, which causes an assertion when the event cannot be
N    * successfully allocated.
N    *
N    * \arguments
N    * \arg[in] \c evtT_ event type (class name) of the event to allocate
N    * \arg[in] \c sig_  signal to assign to the newly allocated event
N    *
N    * \returns a valid event pointer cast to the type \a evtT_.
N    *
N    * \note
N    * If #Q_EVT_CTOR is defined, the Q_NEW() macro becomes variadic and
N    * takes all the arguments needed by the constructor of the event
N    * class being allocated. The constructor is then called by means
N    * of the placement-new operator.
N    *
N    * \usage
N    * The following example illustrates dynamic allocation of an event:
N    * \include qf_post.c
N    */
N    #define Q_NEW(evtT_, sig_) \
N        ((evtT_ *)QF_newX_((uint_fast16_t)sizeof(evtT_), \
N                           (uint_fast16_t)0, (sig_)))
X    #define Q_NEW(evtT_, sig_)         ((evtT_ *)QF_newX_((uint_fast16_t)sizeof(evtT_),                            (uint_fast16_t)0, (sig_)))
N
N    /*! Allocate a dynamic event (non-asserting version). */
N    /**
N    * \description
N    * \description
N    * This macro allocates a new event and sets the pointer \a e_, while
N    * leaving at least \a margin_ of events still available in the pool
N    *
N    * \arguments
N    * \arg[in] \c evtT_   event type (class name) of the event to allocate
N    * \arg[in] \c margin_ number of events that must remain available
N    *                     in the given pool after this allocation
N    * \arg[in] \c sig_    signal to assign to the newly allocated event
N    *
N    * \returns an event pointer cast to the type \a evtT_ or NULL if the
N    * event cannot be allocated with the specified \a margin.
N    *
N    * \note
N    * If #Q_EVT_CTOR is defined, the Q_NEW_X() macro becomes variadic and
N    * takes all the arguments needed by the constructor of the event
N    * class being allocated. The constructor is then called and all the
N    * extra arguments are passed to it.
N    *
N    * \usage
N    * The following example illustrates dynamic allocation of an event:
N    * \include qf_postx.c
N    */
N    #define Q_NEW_X(e_, evtT_, margin_, sig_) ((e_) = \
N        (evtT_ *)QF_newX_((uint_fast16_t)sizeof(evtT_), (margin_), (sig_)))
X    #define Q_NEW_X(e_, evtT_, margin_, sig_) ((e_) =         (evtT_ *)QF_newX_((uint_fast16_t)sizeof(evtT_), (margin_), (sig_)))
N
N#endif /* Q_EVT_CTOR */
N
N
N/*! Recycle a dynamic event. */
Nvoid QF_gc(QEvt const * const e);
N
N/*! Clear a specified region of memory to zero. */
Nvoid QF_bzero(void * const start, uint_fast16_t len);
N
N#ifndef QF_CRIT_EXIT_NOP
N    /*! No-operation for exiting a critical section */
N    /**
N    * \description
N    * In some QF ports the critical section exit takes effect only on the
N    * next machine instruction. If this next instruction is another entry
N    * to a critical section, the critical section won't be really exited,
N    * but rather the two adjacent critical sections would be merged.
N    * The #QF_CRIT_EXIT_NOP() macro contains minimal code required to
N    * prevent such merging of critical sections in QF ports, in which it
N    * can occur.
N    */
N    #define QF_CRIT_EXIT_NOP()   ((void)0)
N#endif
N
N/****************************************************************************/
N/* Useful lookup tables ...*/
N/*! Lookup table for \c (1 << ((n-1) % 8)), where n is the index into
N* the table. */
N/**
N* \note Index range n = 0..64. The first index (n == 0) should never be used.
N*/
Nextern uint8_t const Q_ROM QF_pwr2Lkup[65];
Xextern uint8_t const  QF_pwr2Lkup[65];
N
N/*! Lookup table for \c ~(1 << ((n-1) % 8)), where n is the index
N* into the table. */
N/**
N* \note Index range n = 0..64. The first index (n == 0) should never be used.
N*/
Nextern uint8_t const Q_ROM QF_invPwr2Lkup[65];
Xextern uint8_t const  QF_invPwr2Lkup[65];
N
N/*! Lookup table for \c (n-1)/8 , where n is the index into the table. */
N/**
N* \note Index range n = 0..64. The first index (n == 0) should never be used.
N*/
Nextern uint8_t const Q_ROM QF_div8Lkup[65];
Xextern uint8_t const  QF_div8Lkup[65];
N
N/* Log-base-2 calculations ...*/
N#ifndef QF_LOG2
N
N    /*! Macro to return (log2(n_) + 1), where \a n_ = 0..255. */
N    /**
N    * \description
N    * This macro delivers the 1-based number of the most significant 1-bit
N    * of a byte. This macro can be re-implemented in the QP ports, if the CPU
N    * supports special instructions, such as CLZ (count leading zeros).
N    *
N    * If the macro is not defined in the port, the default implementation
N    * uses a lookup table.
N    */
N    #define QF_LOG2(n_) (Q_ROM_BYTE(QF_log2Lkup[(n_)]))
N
N    /*! Lookup table for (log2(n) + 1), where n is the index into the table */
N    /**
N    * \description
N    * This lookup delivers the 1-based number of the most significant 1-bit
N    * of a byte.
N    */
N    extern uint8_t const Q_ROM QF_log2Lkup[256];
X    extern uint8_t const  QF_log2Lkup[256];
N
N    #define QF_LOG2LKUP 1
N
N#endif /* QF_LOG2 */
N
N/*! array of registered active objects */
N/**
N* \note Not to be used by Clients directly, only in ports of QF
N*/
Nextern QActive *QF_active_[QF_MAX_ACTIVE + 1];
Xextern QActive *QF_active_[8 + 1];
N
N/****************************************************************************/
N/*! Returns the QF version. */
N/**
N* \description
N* version of QF as a constant 5-character string of the form X.Y.Z,
N* where X is a 1-digit major version number, Y is a 1-digit minor
N* version number, and Z is a 1-digit release number.
N*/
N#define QF_getVersion() (QP_VERSION_STR)
N
N#endif /* qf_h */
N
N
L 55 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil\qf_port.h" 2
N
N#endif                                                         /* qf_port_h */
L 55 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qp_port.h" 2
N#include "qassert.h"      /* QP assertions */
L 1 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qassert.h" 1
N/**
N* \file
N* \brief customizable and memory-efficient assertions for embedded systems.
N* \cond
N******************************************************************************
N* Product: QP/C/C++/nano
N* Last updated for version 5.3.0
N* Last updated on  2014-03-01
N*
N*                    Q u a n t u m     L e a P s
N*                    ---------------------------
N*                    innovating embedded systems
N*
N* Copyright (C) Quantum Leaps, www.state-machine.com.
N*
N* This program is open source software: you can redistribute it and/or
N* modify it under the terms of the GNU General Public License as published
N* by the Free Software Foundation, either version 3 of the License, or
N* (at your option) any later version.
N*
N* Alternatively, this program may be distributed and modified under the
N* terms of Quantum Leaps commercial licenses, which expressly supersede
N* the GNU General Public License and are specifically designed for
N* licensees interested in retaining the proprietary status of their code.
N*
N* This program is distributed in the hope that it will be useful,
N* but WITHOUT ANY WARRANTY; without even the implied warranty of
N* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
N* GNU General Public License for more details.
N*
N* You should have received a copy of the GNU General Public License
N* along with this program. If not, see <http://www.gnu.org/licenses/>.
N*
N* Contact information:
N* Web:   www.state-machine.com
N* Email: info@state-machine.com
N******************************************************************************
N* \endcond
N*/
N#ifndef qassert_h
N#define qassert_h
N
N/**
N* \note
N* This header file can be used in C, C++, and mixed C/C++ programs.
N*
N* \note The preprocessor switch #Q_NASSERT disables checking assertions.
N* However, it is generally __not__ advisable to disable assertions,
N* __especially__ in the production code. Instead, the assertion handler
N* Q_onAssert() should be very carefully designed and tested.
N*/
N
N#ifdef Q_NASSERT /* Q_NASSERT defined--assertion checking disabled */
S
S    #define Q_DEFINE_THIS_FILE
S    #define Q_DEFINE_THIS_MODULE(name_)
S    #define Q_ASSERT(test_)             ((void)0)
S    #define Q_ASSERT_ID(id_, test_)     ((void)0)
S    #define Q_ALLEGE(test_)             ((void)(test_))
S    #define Q_ALLEGE_ID(id_, test_)     ((void)(test_))
S    #define Q_ERROR()                   ((void)0)
S    #define Q_ERROR_ID(id_)             ((void)0)
S
N#else  /* Q_NASSERT not defined--assertion checking enabled */
N
N    /*! Define the file name (with `__FILE__`) for assertions in this file. */
N    /**
N    * \description
N    * Macro to be placed at the top of each C/C++ module to define the
N    * single instance of the file name string to be used in reporting
N    * assertions in this module.
N    *
N    * \note The file name string literal is defined by means of the standard
N    * preprocessor macro `__FILE__`. However, please note that, depending
N    * on the compiler, the `__FILE__` macro might contain the whole path name
N    * to the file, which might be inconvenient to log assertions.
N    * \note This macro should __not__ be terminated by a semicolon.
N    * \sa Q_DEFINE_THIS_MODULE()
N    */
N    #define Q_DEFINE_THIS_FILE \
N        static char_t const Q_ROM Q_this_module_[] = __FILE__;
X    #define Q_DEFINE_THIS_FILE         static char_t const Q_ROM Q_this_module_[] = __FILE__;
N
N    /*! Define the user-specified module name for assertions in this file. */
N    /**
N    * \description
N    * Macro to be placed at the top of each C/C++ module to define the
N    * single instance of the module name string to be used in reporting
N    * assertions in this module. This macro takes the user-supplied argument
N    * \a name_ instead of `__FILE__` to precisely control the name of the
N    * module.
N    *
N    * \arguments
N    * \arg[in] \c name_ string constant representing the module name
N    *
N    * \note This macro should __not__ be terminated by a semicolon.
N    */
N    #define Q_DEFINE_THIS_MODULE(name_) \
N        static char_t const Q_ROM Q_this_module_[] = name_;
X    #define Q_DEFINE_THIS_MODULE(name_)         static char_t const Q_ROM Q_this_module_[] = name_;
N
N    /*! General purpose assertion. */
N    /**
N    * \description
N    * Makes sure the \a test_ argument is TRUE. Calls the Q_onAssert()
N    * callback if the \a test_ expression evaluates to FALSE. This
N    * macro identifies the assertion location within the file by means
N    * of the standard `__LINE__` macro.
N    *
N    * \arguments
N    * \arg[in] \c test_ Boolean expression
N    *
N    * \note the \a test_ is __not__ evaluated if assertions are disabled
N    * with the #Q_NASSERT switch.
N    */
N    #define Q_ASSERT(test_) ((test_) \
N        ? (void)0 : Q_onAssert(&Q_this_module_[0], (int_t)__LINE__))
X    #define Q_ASSERT(test_) ((test_)         ? (void)0 : Q_onAssert(&Q_this_module_[0], (int_t)__LINE__))
N
N    /*! General purpose assertion with user-specified assertion-id. */
N    /**
N    * \description
N    * Makes sure the \c test_ argument is TRUE. Calls the Q_onAssert()
N    * callback if the \c test_ evaluates to FALSE. This assertion takes the
N    * user-supplied argument \c id_ to identify the location of this
N    * assertion within the file. This avoids the volatility of using line
N    * numbers, which change whenever a line of code is added or removed
N    * upstream from the assertion.
N    *
N    * \arguments
N    * \arg[in] \c id_   ID number (unique within the module) of the assertion
N    * \arg[in] \c test_ Boolean expression
N    *
N    * \note the \c test_ expression is __not__ evaluated if assertions are
N    * disabled with the #Q_NASSERT switch.
N    */
N    #define Q_ASSERT_ID(id_, test_) ((test_) \
N        ? (void)0 : Q_onAssert(&Q_this_module_[0], (int_t)(id_)))
X    #define Q_ASSERT_ID(id_, test_) ((test_)         ? (void)0 : Q_onAssert(&Q_this_module_[0], (int_t)(id_)))
N
N    /*! General purpose assertion that __always__ evaluates the \a test_
N    * expression. */
N    /**
N    * \description
N    * Like the Q_ASSERT() macro, except it __always__ evaluates the \a test_
N    * expression even when assertions are disabled with the #Q_NASSERT macro.
N    * However, when the #Q_NASSERT macro is defined, the Q_onAssert()
N    * callback is __not__ called, even if \a test_ evaluates to FALSE.
N    *
N    * \arguments
N    * \arg[in] \c test_ Boolean expression (__always__ evaluated)
N    *
N    * \sa #Q_ALLEGE_ID
N    */
N    #define Q_ALLEGE(test_)    Q_ASSERT(test_)
N
N    /*! General purpose assertion with user-specified assertion-id that
N    * __always__ evaluates the \a test_ expression. */
N    /**
N    * \description
N    * Like the Q_ASSERT_ID() macro, except it __always__ evaluates the
N    * \a test_ expression even when assertions are disabled with the
N    * #Q_NASSERT macro. However, when the #Q_NASSERT macro is defined, the
N    * Q_onAssert() callback is __not__ called, even if \a test_ evaluates
N    * to FALSE.
N    *
N    * \arguments
N    * \arg[in] \c id_   ID number (unique within the module) of the assertion
N    * \arg[in] \c test_ Boolean expression
N    */
N    #define Q_ALLEGE_ID(id_, test_) Q_ASSERT_ID(id_, test_)
N
N    /*! Assertion for a wrong path through the code. */
N    /**
N    * \description
N    * Calls the Q_onAssert() callback if ever executed.
N    *
N    * \note Does noting if assertions are disabled with the #Q_NASSERT switch.
N    */
N    #define Q_ERROR() \
N        Q_onAssert(&Q_this_module_[0], (int_t)__LINE__)
X    #define Q_ERROR()         Q_onAssert(&Q_this_module_[0], (int_t)__LINE__)
N
N    /*! Assertion with user-specified assertion-id for a wrong path. */
N    /**
N    * \description
N    * Calls the Q_onAssert() callback if ever executed. This assertion
N    * takes the user-supplied argument \a id_ to identify the location of
N    * this assertion within the file. This avoids the volatility of using
N    * line numbers, which change whenever a line of code is added or removed
N    * upstream from the assertion.
N    *
N    * \arguments
N    * \arg[in] \c id_   ID number (unique within the module) of the assertion
N    *
N    * \note Does noting if assertions are disabled with the #Q_NASSERT switch.
N    */
N    #define Q_ERROR_ID(id_) \
N        Q_onAssert(&Q_this_module_[0], (int_t)(id_))
X    #define Q_ERROR_ID(id_)         Q_onAssert(&Q_this_module_[0], (int_t)(id_))
N
N#endif /* Q_NASSERT */
N
N#ifdef __cplusplus
S    extern "C" {
N#endif
N
N/*! Callback function invoked in case of any assertion failure. */
N/**
N* \description
N* This is an application-specific callback function needs to be defined in
N* the application to perform the clean system shutdown and perhaps a reset.
N*
N* \arguments
N* \arg[in] \c module name of the file/module in which the assertion failed
N*                    (constant ROM-based, zero-terminated C string)
N* \arg[in] \c line   line number or user-specified ID-number to identify
N*                    the location of the failing assertion within the file.
N*
N* \note This callback function should _not_ return, as continuation after
N* an assertion failure does not make sense.
N*
N* \note The Q_onAssert() function is the last line of defense after the
N* system failure and its implementation shouild be very __carefully__
N* designed and __tested__ under various fault conditions, including but
N* not limited to: stack overflow, stack corruption, or calling Q_onAssert()
N* from an interrupt.
N*
N* \note It is typically a __bad idea__ to implement Q_onAssert() as an
N* endless loop that ties up the CPU. During debuggin, Q_onAssert() is an
N* ideal place to put a breakpoint.
N*
N* Called by the following macros: #Q_ASSERT, #Q_REQUIRE, #Q_ENSURE,
N* #Q_ERROR, #Q_ALLEGE as well as #Q_ASSERT_ID, #Q_REQUIRE_ID, #Q_ENSURE_ID,
N* #Q_ERROR_ID, and #Q_ALLEGE_ID.
N*/
Nvoid Q_onAssert(char_t const Q_ROM * const file, int_t line);
Xvoid Q_onAssert(char_t const  * const file, int_t line);
N
N#ifdef __cplusplus
S    }
N#endif
N
N/*! Assertion for checking preconditions. */
N/**
N* \description
N* This macro is equivalent to #Q_ASSERT, except the name provides a better
N* documentation of the intention of this assertion.
N*
N* \arguments
N* \arg[in] \c test_ Boolean expression
N*/
N#define Q_REQUIRE(test_)         Q_ASSERT(test_)
N
N/*! Assertion for checking preconditions with user-specified assertion-id. */
N/**
N* \description
N* Equivalent to #Q_ASSERT_ID, except the macro name provides a better
N* documentation of the intention of this assertion.
N*
N* \arguments
N* \arg[in] \c id_   ID number (unique within the module) of the assertion
N* \arg[in] \c test_ Boolean expression
N*/
N#define Q_REQUIRE_ID(id_, test_) Q_ASSERT_ID(id_, test_)
N
N/*! Assertion for checking postconditions. */
N/** Equivalent to #Q_ASSERT, except the macro name provides a better
N* documentation of the intention of this assertion.
N*
N* \arguments
N* \arg[in] \c test_ Boolean expression
N*/
N#define Q_ENSURE(test_) Q_ASSERT(test_)
N
N/*! Assertion for checking postconditions with user-specified assertion-id. */
N/**
N* \description
N* Equivalent to #Q_ASSERT_ID, except the name provides a better documentation
N* of the intention of this assertion.
N*
N* \arguments
N* \arg[in] \c id_   ID number (unique within the module) of the assertion
N* \arg[in] \c test_ Boolean expression
N*/
N#define Q_ENSURE_ID(id_, test_) Q_ASSERT_ID(id_, test_)
N
N/*! Assertion for checking invariants. */
N/**
N* \description
N* Equivalent to #Q_ASSERT, except the macro name provides a better
N* documentation of the intention of this assertion.
N*
N* \arguments
N* \arg[in] \c test_ Boolean expression
N*/
N#define Q_INVARIANT(test_) Q_ASSERT(test_)
N
N/*! Assertion for checking invariants with user-specified assertion-id. */
N/**
N* \description
N* Equivalent to #Q_ASSERT_ID, except the macro name provides a better
N* documentation of the intention of this assertion.
N*
N* \arguments
N* \arg[in] \c id_   ID number (unique within the module) of the assertion
N* \arg[in] \c test_ Boolean expression
N*/
N#define Q_INVARIANT_ID(id_, test_) Q_ASSERT_ID(id_, test_)
N
N/*! Compile-time assertion. */
N/**
N* \description
N* This type of assertion deliberately causes a compile-time error when
N* the \c test_ evaluates to FALSE. The macro exploits the fact that in C/C++
N* a dimension of an array cannot be negative. The compile-time assertion has
N* no runtime side effects.
N*
N* \arguments
N* \arg[in] \c test_ Compile-time Boolean expression
N*/
N#define Q_ASSERT_COMPILE(test_) \
N    extern int_t Q_assert_compile[(test_) ? 1 : -1]
X#define Q_ASSERT_COMPILE(test_)     extern int_t Q_assert_compile[(test_) ? 1 : -1]
N
N#endif /* qassert_h */
L 56 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qp_port.h" 2
N
N#ifdef Q_SPY /* software tracing enabled? */
S    #include "qs_port.h"  /* QS/C port from the port directory */
N#else
N    #include "qs_dummy.h" /* QS/C dummy (inactive) interface */
L 1 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qs_dummy.h" 1
N/**
N* \file
N* \brief Dummy definitions of the QS macros that avoid code generation from
N* the QS instrumentation.
N* \ingroup qs
N* \cond
N******************************************************************************
N* Product: QP/C
N* Last updated for version 5.3.0
N* Last updated on  2014-02-24
N*
N*                    Q u a n t u m     L e a P s
N*                    ---------------------------
N*                    innovating embedded systems
N*
N* Copyright (C) Quantum Leaps, www.state-machine.com.
N*
N* This program is open source software: you can redistribute it and/or
N* modify it under the terms of the GNU General Public License as published
N* by the Free Software Foundation, either version 3 of the License, or
N* (at your option) any later version.
N*
N* Alternatively, this program may be distributed and modified under the
N* terms of Quantum Leaps commercial licenses, which expressly supersede
N* the GNU General Public License and are specifically designed for
N* licensees interested in retaining the proprietary status of their code.
N*
N* This program is distributed in the hope that it will be useful,
N* but WITHOUT ANY WARRANTY; without even the implied warranty of
N* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
N* GNU General Public License for more details.
N*
N* You should have received a copy of the GNU General Public License
N* along with this program. If not, see <http://www.gnu.org/licenses/>.
N*
N* Contact information:
N* Web:   www.state-machine.com
N* Email: info@state-machine.com
N******************************************************************************
N* \endcond
N*/
N#ifndef qs_dummy_h
N#define qs_dummy_h
N
N#ifdef Q_SPY
S    #error "Q_SPY must NOT be defined to include qs_dummy.h"
N#endif
N
N#define QS_INIT(arg_)                   (0 == 0)
N#define QS_EXIT()                       ((void)0)
N#define QS_DUMP()                       ((void)0)
N#define QS_FILTER_ON(rec_)              ((void)0)
N#define QS_FILTER_OFF(rec_)             ((void)0)
N#define QS_FILTER_SM_OBJ(obj_)          ((void)0)
N#define QS_FILTER_AO_OBJ(obj_)          ((void)0)
N#define QS_FILTER_MP_OBJ(obj_)          ((void)0)
N#define QS_FILTER_EQ_OBJ(obj_)          ((void)0)
N#define QS_FILTER_TE_OBJ(obj_)          ((void)0)
N#define QS_FILTER_AP_OBJ(obj_)          ((void)0)
N
N#define QS_GET_BYTE(pByte_)             ((uint16_t)0xFFFFU)
N#define QS_GET_BLOCK(pSize_)            ((uint8_t *)0)
N
N#define QS_BEGIN(rec_, obj_)            if (0) {
N#define QS_END()                        }
N#define QS_BEGIN_NOCRIT(rec_, obj_)     if (0) {
N#define QS_END_NOCRIT()                 }
N
N#define QS_I8(width_, data_)            ((void)0)
N#define QS_U8(width_, data_)            ((void)0)
N#define QS_I16(width_, data_)           ((void)0)
N#define QS_U16(width_, data_)           ((void)0)
N#define QS_I32(width_, data_)           ((void)0)
N#define QS_U32(width_, data_)           ((void)0)
N#define QS_F32(width_, data_)           ((void)0)
N#define QS_F64(width_, data_)           ((void)0)
N#define QS_U64(width_, data_)           ((void)0)
N#define QS_U32_HEX(width_, data_)       ((void)0)
N#define QS_STR(str_)                    ((void)0)
N#define QS_STR_ROM(str_)                ((void)0)
N#define QS_MEM(mem_, size_)             ((void)0)
N#define QS_SIG(sig_, obj_)              ((void)0)
N#define QS_OBJ(obj_)                    ((void)0)
N#define QS_FUN(fun_)                    ((void)0)
N
N#define QS_SIG_DICTIONARY(sig_, obj_)   ((void)0)
N#define QS_OBJ_DICTIONARY(obj_)         ((void)0)
N#define QS_FUN_DICTIONARY(fun_)         ((void)0)
N#define QS_USR_DICTIONARY(rec_)         ((void)0)
N#define QS_ASSERTION(module_, loc_)     ((void)0)
N#define QS_TEST_ASSERTION(file_, loc_)  ((void)0)
N#define QS_TEST(file_, test_)           ((void)0)
N#define QS_FLUSH()                      ((void)0)
N
N/****************************************************************************/
N/* internal QS macros used only in the QP components */
N#define QS_CRIT_STAT_
N#define QS_BEGIN_(rec_, refObj_, obj_)  if (0) {
N#define QS_END_()                       }
N#define QS_BEGIN_NOCRIT_(rec_, refObj_, obj_) if (0) {
N#define QS_END_NOCRIT_()                }
N#define QS_U8_(data_)                   ((void)0)
N#define QS_2U8_(data1_, data2_)         ((void)0)
N#define QS_U16_(data_)                  ((void)0)
N#define QS_U32_(data_)                  ((void)0)
N#define QS_U64_(data_)                  ((void)0)
N#define QS_TIME_()                      ((void)0)
N#define QS_SIG_(sig_)                   ((void)0)
N#define QS_EVS_(size_)                  ((void)0)
N#define QS_OBJ_(obj_)                   ((void)0)
N#define QS_FUN_(fun_)                   ((void)0)
N#define QS_EQC_(ctr_)                   ((void)0)
N#define QS_MPC_(ctr_)                   ((void)0)
N#define QS_MPS_(size_)                  ((void)0)
N#define QS_TEC_(ctr_)                   ((void)0)
N
N#define QF_QS_CRIT_ENTRY()              ((void)0)
N#define QF_QS_CRIT_EXIT()               ((void)0)
N#define QF_QS_ISR_ENTRY(isrnest_, prio_) ((void)0)
N#define QF_QS_ISR_EXIT(isrnest_, prio_) ((void)0)
N#define QF_QS_ACTION(act_)              ((void)0)
N
N#endif /* qs_dummy_h */
L 61 "..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include\qp_port.h" 2
N#endif
N
N
N/****************************************************************************/
N#ifndef QP_API_VERSION
N
N/*! Specifies the backwards compatibility with the QP/C API version. */
N/**
N* \description
N* For example, QP_API_VERSION=450 will cause generating the compatibility
N* layer with QP/C version 4.5.0 and newer, but not older than 4.5.0.
N* QP_API_VERSION=0 causes generation of the compatibility layer "from the
N* begining of time", which is the maximum backwards compatibilty. This is
N* the default.\n
N* \n
N* Conversely, QP_API_VERSION=9999 means that no compatibility layer should
N* be generated. This setting is useful for checking if an application
N* complies with the latest QP/C API.
N*/
N#define QP_API_VERSION 0
N#endif /* #ifndef QP_API_VERSION */
N
N/****************************************************************************/
N/* QP API compatibility layer */
N#if (QP_API_VERSION < 500)
X#if (0 < 500)
N
N/*! \deprecated macro for odd 8-bit CPUs. */
N#define Q_ROM_VAR
N
N/*! \deprecated call to the QHsm init operation */
N#define QHsm_init(me_, e_)     QMSM_INIT((me_), (e_))
N
N/*! \deprecated call to the QHsm dispatch operation */
N#define QHsm_dispatch(me_, e_) QMSM_DISPATCH((me_), (e_))
N
N/*! \deprecated call to the QFsm init operation */
N#define QFsm_init(me_, e_)     QMSM_INIT((me_), (e_))
N
N/*! \deprecated to the QFsm dispatch operation */
N#define QFsm_dispatch(me_, e_) QMSM_DISPATCH((me_), (e_))
N
N/*! \deprecated interface defined for backwards compatibility */
N#define QEQueue_postFIFO(me_, e_) \
N    ((void)QEQueue_post((me_), (e_), (uint16_t)0))
X#define QEQueue_postFIFO(me_, e_)     ((void)QEQueue_post((me_), (e_), (uint16_t)0))
N
N/*! \deprecated name of the QActive start operation */
N#define QActive_start QActive_start_
N
N
N#ifdef Q_SPY
S
S    /*! \deprecated call to QActive post FIFO operation */
S    #define QActive_postFIFO(me_, e_, sender_) \
S        QACTIVE_POST((me_), (e_), (sender_))
X    #define QActive_postFIFO(me_, e_, sender_)         QACTIVE_POST((me_), (e_), (sender_))
S
S    /*! \deprecated call of QF system clock tick (for rate 0) */
S    #define QF_tick(sender_)   QF_TICK_X((uint8_t)0, (sender_))
S
N#else
N
N    #define QActive_postFIFO(me_, e_) \
N        QACTIVE_POST((me_), (e_), dummy)
X    #define QActive_postFIFO(me_, e_)         QACTIVE_POST((me_), (e_), dummy)
N    #define QF_tick()          QF_TICK_X((uint8_t)0, dummy)
N
N#endif
N
N/*! \deprecated time event constructor */
N#define QTimeEvt_ctor(me_, sig_) \
N    QTimeEvt_ctorX((me_), (QActive *)0, (sig_), (uint8_t)0)
X#define QTimeEvt_ctor(me_, sig_)     QTimeEvt_ctorX((me_), (QActive *)0, (sig_), (uint8_t)0)
N
N/*! \deprecated time event one-shot arm operation */
N#define QTimeEvt_postIn(me_, act_, nTicks_) do { \
N    (me_)->act = (act_); \
N    QTimeEvt_armX((me_), (nTicks_), (uint8_t)0); \
N} while (0)
X#define QTimeEvt_postIn(me_, act_, nTicks_) do {     (me_)->act = (act_);     QTimeEvt_armX((me_), (nTicks_), (uint8_t)0); } while (0)
N
N/*! \deprecated time event periodic arm operation */
N#define QTimeEvt_postEvery(me_, act_, nTicks_) do { \
N    (me_)->act = (act_); \
N    QTimeEvt_armX((me_), (nTicks_), (nTicks_)); \
N} while (0)
X#define QTimeEvt_postEvery(me_, act_, nTicks_) do {     (me_)->act = (act_);     QTimeEvt_armX((me_), (nTicks_), (nTicks_)); } while (0)
N
N/*! \deprecated macro for generating QS-Reset trace record. */
N#define QS_RESET() ((void)0)
N
N
N/****************************************************************************/
N#if (QP_API_VERSION < 450)
X#if (0 < 450)
N
N/*! \deprecated typedef for backwards compatibility */
Ntypedef QEvt QEvent;
N
N#endif /* QP_API_VERSION < 450 */
N#endif /* QP_API_VERSION < 500 */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* qp_port_h */
L 29 "src\comp.c" 2
N#include "qmbsp.h"
L 1 "src\qmbsp.h" 1
N
N/*****************************************************************************
N* Product: Board Support Package (BSP) for the QM examples Bomb1-4
N* Keil ARM MDK  2300 
N* Dr. Ron Barker 
N* WS 2014 - Event Driven Systems
N*****************************************************************************/
N
N#ifndef  bombqmbsp_h
N#define bombqmbsp_h
N
N             /* Exact-width types. WG14/N843 C99 Standard, Section 7.18.1.1 */
N#include <stdint.h>
N
N	  
N
N# define BSP_TICKS_PER_SEC		 12000000/10
N
N/*  bsp function references for the mcb 2300 */
N
Nvoid    Init_Timer1(void );
Nvoid    Init_timer0(void );
Nvoid    init_serial(void );                              
Nvoid    uart_init_0(void );
Nvoid    _sys_exit(int);
N
N#define _exit(x)  _sys_exit(x)
N
N/* bsp function references for standalone port of QM FSM 7 HSM */
N
Nvoid    delay( int time );
N
Nint  _kbhit(void);
Nint   kbhit(void);
Nint  _getch(void);
Nint   getch(void);
Nvoid _sys_exit(int);
N
N
N
N
Nvoid BSP_display(uint8_t timeout);
Nvoid BSP_boom(void);
Nvoid BSP_LCD_display_str(char *msg, int pos, int line);
Nvoid BSP_display_str(char *msg);
Nvoid BSP_exit(void);	 
Nvoid BSP_Init(void);
Nvoid BSP_delay(int delay);
N
N
N
N#endif                                                             /* bsp_h */
L 30 "src\comp.c" 2
N#include "alarm.h"
L 1 "src\alarm.h" 1
N/*****************************************************************************
N* Product: Orthogonal Component state pattern example
N* Last Updated for Version: 4.0.00
N* Date of the Last Update:  Apr 07, 2008
N*
N*                    Q u a n t u m     L e a P s
N*                    ---------------------------
N*                    innovating embedded systems
N*
N* Copyright (C) 2002-2008 Quantum Leaps, LLC. All rights reserved.
N*
N* This software may be distributed and modified under the terms of the GNU
N* General Public License version 2 (GPL) as published by the Free Software
N* Foundation and appearing in the file GPL.TXT included in the packaging of
N* this file. Please note that GPL Section 2[b] requires that all works based
N* on this software must also be made publicly available under the terms of
N* the GPL ("Copyleft").
N*
N* Alternatively, this software may be distributed and modified under the
N* terms of Quantum Leaps commercial licenses, which expressly supersede
N* the GPL and are specifically designed for licensees interested in
N* retaining the proprietary status of their code.
N*
N* Contact information:
N* Quantum Leaps Web site:  http://www.quantum-leaps.com
N* e-mail:                  info@quantum-leaps.com
N*****************************************************************************/
N#ifndef alarm_h
N#define alarm_h
N
Ntypedef struct AlarmTag {         /* the HSM version of the Alarm component */
N    QFsm super;                                         /* derive from QFsm */
N    uint32_t alarm_time;
N} Alarm;
N
Nvoid Alarm_ctor(Alarm *me);
N#define Alarm_init(me_)           QFsm_init    ((QFsm *)(me_), (QEvent *)0)
N#define Alarm_dispatch(me_, e_)   QFsm_dispatch((QFsm *)(me_), e_)
N
N#endif                                                           /* alarm_h */
L 31 "src\comp.c" 2
N#include "clock.h"
L 1 "src\clock.h" 1
N/*****************************************************************************
N* Product: Orthogonal Component state pattern example
N* Last Updated for Version: 4.0.00
N* Date of the Last Update:  Apr 07, 2008
N*
N*                    Q u a n t u m     L e a P s
N*                    ---------------------------
N*                    innovating embedded systems
N*
N* Copyright (C) 2002-2008 Quantum Leaps, LLC. All rights reserved.
N*
N* This software may be distributed and modified under the terms of the GNU
N* General Public License version 2 (GPL) as published by the Free Software
N* Foundation and appearing in the file GPL.TXT included in the packaging of
N* this file. Please note that GPL Section 2[b] requires that all works based
N* on this software must also be made publicly available under the terms of
N* the GPL ("Copyleft").
N*
N* Alternatively, this software may be distributed and modified under the
N* terms of Quantum Leaps commercial licenses, which expressly supersede
N* the GPL and are specifically designed for licensees interested in
N* retaining the proprietary status of their code.
N*
N* Contact information:
N* Quantum Leaps Web site:  http://www.quantum-leaps.com
N* e-mail:                  info@quantum-leaps.com
N*****************************************************************************/
N#ifndef clock_h
N#define clock_h
N
Nenum AlarmClockSignals {
N    TICK_SIG = Q_USER_SIG,                               /* time tick event */
N    ALARM_SET_SIG,                                         /* set the alarm */
N    ALARM_ON_SIG,                                      /* turn the alarm on */
N    ALARM_OFF_SIG,                                    /* turn the alarm off */
N    ALARM_SIG,  /* alarm event from Alarm component to AlarmClock container */
N    CLOCK_12H_SIG,                             /* set the clock in 12H mode */
N    CLOCK_24H_SIG,                             /* set the clock in 24H mode */
N    TIME_SIG,           /* time event sent to Alarm (contains current time) */
N    TERMINATE_SIG                              /* terminate the application */
N};
N/*..........................................................................*/
Ntypedef struct SetEvtTag {
N    QEvent super;                                     /* derive from QEvent */
N    uint8_t digit;
N} SetEvt;
N
Ntypedef struct TimeEvtTag {
N    QEvent super;                                     /* derive from QEvent */
N    uint32_t current_time;
N} TimeEvt;
N
Nextern QActive *APP_alarmClock;       /* AlarmClock container active object */
N
N#endif                                                           /* clock_h */
L 32 "src\comp.c" 2
N
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 179217 $
N * Checkin $Date: 2013-03-12 14:03:19 +0000 (Tue, 12 Mar 2013) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5040049
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 34 "src\comp.c" 2
N
N//Q_DEFINE_THIS_FILE				Qasert not used 
N
N/*..........................................................................*/
Ntypedef struct AlarmClockTag {              /* the AlarmClock active object */
N
N    QActive super;                                   /* derive from QActive */
N
N    uint32_t current_time;                   /* the current time in seconds */
N    Alarm alarm;                              /* Alarm orthogonal component */
N    QTimeEvt timeEvt;        /* time event generator (generates time ticks) */
N} AlarmClock;
N
Nvoid AlarmClock_ctor(AlarmClock *me);                       /* default ctor */
N                                          /* hierarchical state machine ... */
Nstatic QState AlarmClock_initial    (AlarmClock *me, QEvent const *e);
Nstatic QState AlarmClock_timekeeping(AlarmClock *me, QEvent const *e);
Nstatic QState AlarmClock_mode12hr   (AlarmClock *me, QEvent const *e);
Nstatic QState AlarmClock_mode24hr   (AlarmClock *me, QEvent const *e);
Nstatic QState AlarmClock_final      (AlarmClock *me, QEvent const *e);
N
N/*..........................................................................*/
Nvoid AlarmClock_ctor(AlarmClock *me) {                      /* default ctor */
N    QActive_ctor(&me->super, (QStateHandler)&AlarmClock_initial);
N    Alarm_ctor(&me->alarm);                /* orthogonal component ctor */
N    QTimeEvt_ctor(&me->timeEvt, TICK_SIG);       /* private time event ctor */
X    QTimeEvt_ctorX((&me ->timeEvt), (QActive *)0, (TICK_SIG), (uint8_t)0);        
N}
N/* HSM definition ----------------------------------------------------------*/
NQState AlarmClock_initial(AlarmClock *me, QEvent const *e) {
N    (void)e;               /* avoid compiler warning about unused parameter */
N    me->current_time = 0;
N    Alarm_init(&me->alarm);      /* the initial transition in the component */
X    ((*(((QFsm *)(&me ->alarm)))->vptr->init)((((QFsm *)(&me ->alarm))), (((QEvent *)0))));       
N    return Q_TRAN(&AlarmClock_timekeeping);
X    return ((((QMsm *)(me)))->temp . fun = ((QStateHandler)(&AlarmClock_timekeeping)), (QState)Q_RET_TRAN);
N}
N/*..........................................................................*/
NQState AlarmClock_final(AlarmClock *me, QEvent const *e) {
N    (void)me;          /* avoid the compiler warning about unused parameter */
N    switch (e->sig) {
N        case Q_ENTRY_SIG: {
N            printf("-> final\nBye!Bye!\n");
N            QF_stop();                         /* terminate the application */
N            return Q_HANDLED();
X            return ((QState)Q_RET_HANDLED);
N        }
N    }
N    return Q_SUPER(&QHsm_top);
X    return ((((QMsm *)(me)))->temp . fun = ((QStateHandler)(&QHsm_top)), (QState)Q_RET_SUPER);
N}
N/*..........................................................................*/
NQState AlarmClock_timekeeping(AlarmClock *me, QEvent const *e) {
N    switch (e->sig) {
N        case Q_ENTRY_SIG: {
N                                           /* periodic timeout every second */
N            QTimeEvt_postEvery(&me->timeEvt,
W "src\comp.c" 85 13 integer conversion resulted in truncation
W "src\comp.c" 85 13 integer conversion resulted in truncation
N                              (QActive *)me, BSP_TICKS_PER_SEC);
X            do { (&me ->timeEvt)->act = ((QActive *)me); QTimeEvt_armX((&me ->timeEvt), (12000000/10), (12000000/10)); } while (0);
N            return Q_HANDLED();
X            return ((QState)Q_RET_HANDLED);
N        }
N        case Q_EXIT_SIG: {
N            QTimeEvt_disarm(&me->timeEvt);
N            return Q_HANDLED();
X            return ((QState)Q_RET_HANDLED);
N        }
N        case Q_INIT_SIG: {
N            return Q_TRAN(&AlarmClock_mode24hr);
X            return ((((QMsm *)(me)))->temp . fun = ((QStateHandler)(&AlarmClock_mode24hr)), (QState)Q_RET_TRAN);
N        }
N        case CLOCK_12H_SIG: {
N            return Q_TRAN(&AlarmClock_mode12hr);
X            return ((((QMsm *)(me)))->temp . fun = ((QStateHandler)(&AlarmClock_mode12hr)), (QState)Q_RET_TRAN);
N        }
N        case CLOCK_24H_SIG: {
N            return Q_TRAN(&AlarmClock_mode24hr);
X            return ((((QMsm *)(me)))->temp . fun = ((QStateHandler)(&AlarmClock_mode24hr)), (QState)Q_RET_TRAN);
N        }
N        case ALARM_SIG: {
N            printf("Wake up!!!\n");
N            return Q_HANDLED();
X            return ((QState)Q_RET_HANDLED);
N        }
N        case ALARM_SET_SIG:
N        case ALARM_ON_SIG:
N        case ALARM_OFF_SIG: {
N                      /* synchronously dispatch to the orthogonal component */
N            Alarm_dispatch(&me->alarm, e);
X            ((*(((QFsm *)(&me ->alarm)))->vptr->dispatch)((((QFsm *)(&me ->alarm))), ((e))));
N            return Q_HANDLED();
X            return ((QState)Q_RET_HANDLED);
N        }
N        case TERMINATE_SIG: {
N            return Q_TRAN(&AlarmClock_final);
X            return ((((QMsm *)(me)))->temp . fun = ((QStateHandler)(&AlarmClock_final)), (QState)Q_RET_TRAN);
N        }
N    }
N    return Q_SUPER(&QHsm_top);
X    return ((((QMsm *)(me)))->temp . fun = ((QStateHandler)(&QHsm_top)), (QState)Q_RET_SUPER);
N}
N/*..........................................................................*/
NQState AlarmClock_mode24hr(AlarmClock *me, QEvent const *e) {
N    switch (e->sig) {
N        case Q_ENTRY_SIG: {
N            printf("*** 24-hour mode\n");
N            return Q_HANDLED();
X            return ((QState)Q_RET_HANDLED);
N        }
N        case TICK_SIG: {
N            TimeEvt pe;    /* temporary synchronous event for the component */
N
N            if (++me->current_time == 24*60) {  /* roll over in 24-hr mode? */
N                me->current_time = 0;
N            }
N            printf("%02ld:%02ld\n",
N                   me->current_time/60, me->current_time%60);
N            ((QEvent *)&pe)->sig = TIME_SIG;
N            pe.current_time = me->current_time;
N                      /* synchronously dispatch to the orthogonal component */
N            Alarm_dispatch(&me->alarm, (QEvent *)&pe);
X            ((*(((QFsm *)(&me ->alarm)))->vptr->dispatch)((((QFsm *)(&me ->alarm))), (((QEvent *)&pe))));
N            return Q_HANDLED();
X            return ((QState)Q_RET_HANDLED);
N        }
N    }
N    return Q_SUPER(&AlarmClock_timekeeping);
X    return ((((QMsm *)(me)))->temp . fun = ((QStateHandler)(&AlarmClock_timekeeping)), (QState)Q_RET_SUPER);
N}
N/*..........................................................................*/
NQState AlarmClock_mode12hr(AlarmClock *me, QEvent const *e) {
N    switch (e->sig) {
N        case Q_ENTRY_SIG: {
N            printf("*** 12-hour mode\n");
N            return Q_HANDLED();
X            return ((QState)Q_RET_HANDLED);
N        }
N        case TICK_SIG: {
N            TimeEvt pe;    /* temporary synchronous event for the component */
N            uint32_t h;                  /* temporary variable to hold hour */
N
N            if (++me->current_time == 12*60) {  /* roll over in 12-hr mode? */
N                me->current_time = 0;
N            }
N            h = me->current_time/60;
N            printf("%02ld:%02ld %s\n", (h % 12) ? (h % 12) : 12,
N                   me->current_time % 60, (h / 12) ? "PM" : "AM");
N            ((QEvent *)&pe)->sig = TIME_SIG;
N            pe.current_time = me->current_time;
N
N                      /* synchronously dispatch to the orthogonal component */
N            Alarm_dispatch(&me->alarm, (QEvent *)&pe);
X            ((*(((QFsm *)(&me ->alarm)))->vptr->dispatch)((((QFsm *)(&me ->alarm))), (((QEvent *)&pe))));
N            return Q_HANDLED();
X            return ((QState)Q_RET_HANDLED);
N        }
N    }
N    return Q_SUPER(&AlarmClock_timekeeping);
X    return ((((QMsm *)(me)))->temp . fun = ((QStateHandler)(&AlarmClock_timekeeping)), (QState)Q_RET_SUPER);
N}
N
N/* test harness ============================================================*/
N
N/* Local-scope objects -----------------------------------------------------*/
Nstatic AlarmClock l_alarmClock;            /* the AlarmClock active object  */
Nstatic QEvent const *l_alarmClockQSto[10];  /* queue storage for AlarmClock */
Nstatic TimeEvt l_smlPoolSto[10];       /* storage for small-size event pool */
N
N/* Global-scope objects (opaque pointer to the AlarmClock container) -------*/
NQActive *APP_alarmClock= (QActive *)&l_alarmClock;/*AlarmClock container AO */
N
N/*..........................................................................*/
Nint main() {
N   
N   BSP_Init();
N    printf("Orthogonal Component pattern\nQEP version: %s\nQF  version: %s\n"
N           "Press 'o' to turn the Alarm ON\n"
N           "Press 'f' to turn the Alarm OFF\n"
N           "Press '0'..'9' to set the Alarm time\n"
N           "Press 'a' to set the Clock in 12-hour mode\n"
N           "Press 'b' to set the Clock in 24-hour mode\n"
N           "Press ESC to quit...\n",
N           QEP_getVersion(), QF_getVersion());
X           ("5.3.1"), ("5.3.1"));
N
N   
N
N    QF_init();    /* initialize the framework and the underlying RT kernel */
N
N    
N
N                                               /* initialize event pools... */
N
N    QF_poolInit(l_smlPoolSto, sizeof(l_smlPoolSto), sizeof(l_smlPoolSto[0]));
N
N                             /* instantiate and start the active objects... */
N    AlarmClock_ctor(&l_alarmClock);
N    QActive_start((QActive *)&l_alarmClock, 1,
X    QActive_start_((QActive *)&l_alarmClock, 1,
N                  l_alarmClockQSto, Q_DIM(l_alarmClockQSto),
X                  l_alarmClockQSto, (sizeof(l_alarmClockQSto) / sizeof((l_alarmClockQSto)[0])),
N                  (void *)0, 0, (QEvent *)0);
N
N    QF_run();                                     /* run the QF application */
N
N    return 0;
N}
N/*..........................................................................*/
Nvoid BSP_onKeyboardInput(uint8_t key) {
N    switch (key) {
N        case 0x6f: {                                  /* 'o': Alarm on event? */
N            QActive_postFIFO((QActive *)&l_alarmClock,
N                             Q_NEW(QEvent, ALARM_ON_SIG));
X            ((void)(*((QActiveVtbl const *)((((QActive *)&l_alarmClock))->super . vptr))->post)((((QActive *)&l_alarmClock)), ((((QEvent *)QF_newX_((uint_fast16_t)sizeof(QEvent), (uint_fast16_t)0, (ALARM_ON_SIG))))), (uint_fast16_t)0));
N            break;
N        }
N        case 0x66: {                                 /* 'f': Alarm off event? */
N            QActive_postFIFO((QActive *)&l_alarmClock,
N                             Q_NEW(QEvent, ALARM_OFF_SIG));
X            ((void)(*((QActiveVtbl const *)((((QActive *)&l_alarmClock))->super . vptr))->post)((((QActive *)&l_alarmClock)), ((((QEvent *)QF_newX_((uint_fast16_t)sizeof(QEvent), (uint_fast16_t)0, (ALARM_OFF_SIG))))), (uint_fast16_t)0));
N            break;
N        }
N        case  0x32:                                                     /* '1' */
N        case  0x33:                                                     /* '2' */
N        case  0x34:                                                     /* '3' */
N        case  0x35:                                                     /* '4' */
N        case  0x36:                                                     /* '5' */
N        case  0x37:                                                     /* '6' */
N        case  0x38:                                                     /* '7' */
N        case  0x39:                                                     /* '8' */
N        case  0x31:{                                                   /* '9' */
N            SetEvt *e = Q_NEW(SetEvt, ALARM_SET_SIG);
X            SetEvt *e = ((SetEvt *)QF_newX_((uint_fast16_t)sizeof(SetEvt), (uint_fast16_t)0, (ALARM_SET_SIG)));
N            e->digit = (uint8_t)(key - 1);
N            QActive_postFIFO((QActive *)&l_alarmClock, (QEvent *)e);
X            ((void)(*((QActiveVtbl const *)((((QActive *)&l_alarmClock))->super . vptr))->post)((((QActive *)&l_alarmClock)), (((QEvent *)e)), (uint_fast16_t)0));
N            break;
N        }
N        case 0x4f: {                                                   /* '0' */
N            SetEvt *e = Q_NEW(SetEvt, ALARM_SET_SIG);
X            SetEvt *e = ((SetEvt *)QF_newX_((uint_fast16_t)sizeof(SetEvt), (uint_fast16_t)0, (ALARM_SET_SIG)));
N            e->digit = 0;
N            QActive_postFIFO((QActive *)&l_alarmClock, (QEvent *)e);
X            ((void)(*((QActiveVtbl const *)((((QActive *)&l_alarmClock))->super . vptr))->post)((((QActive *)&l_alarmClock)), (((QEvent *)e)), (uint_fast16_t)0));
N            break;
N        }
N        case 0x61: {                                 /* 'a': Clock 12H event? */
N            QActive_postFIFO((QActive *)&l_alarmClock,
N                             Q_NEW(QEvent, CLOCK_12H_SIG));
X            ((void)(*((QActiveVtbl const *)((((QActive *)&l_alarmClock))->super . vptr))->post)((((QActive *)&l_alarmClock)), ((((QEvent *)QF_newX_((uint_fast16_t)sizeof(QEvent), (uint_fast16_t)0, (CLOCK_12H_SIG))))), (uint_fast16_t)0));
N            break;
N        }
N        case 0x62: {                                 /* 'b': Clock 24H event? */
N            QActive_postFIFO((QActive *)&l_alarmClock,
N                             Q_NEW(QEvent, CLOCK_24H_SIG));
X            ((void)(*((QActiveVtbl const *)((((QActive *)&l_alarmClock))->super . vptr))->post)((((QActive *)&l_alarmClock)), ((((QEvent *)QF_newX_((uint_fast16_t)sizeof(QEvent), (uint_fast16_t)0, (CLOCK_24H_SIG))))), (uint_fast16_t)0));
N            break;
N        }
N        case 0x1b: {                                         /* ESC pressed? */
N            QActive_postFIFO((QActive *)&l_alarmClock,
N                             Q_NEW(QEvent, TERMINATE_SIG));
X            ((void)(*((QActiveVtbl const *)((((QActive *)&l_alarmClock))->super . vptr))->post)((((QActive *)&l_alarmClock)), ((((QEvent *)QF_newX_((uint_fast16_t)sizeof(QEvent), (uint_fast16_t)0, (TERMINATE_SIG))))), (uint_fast16_t)0));
N            break;
N        }
N    }
N}
