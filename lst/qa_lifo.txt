; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\qa_lifo.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\qa_lifo.d --apcs=interwork -O0 --diag_suppress=9931 -I.\bombqmbsp -I..\..\..\..\..\..\..\CPU_Platforms\ARM\ARM7\MCB2300\include -I..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil -I..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include -I.\src -I.\src\coffee -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\Philips -D__MICROLIB -DQM_TICK -DQM_ActiveObject --omf_browse=.\obj\qa_lifo.crf ..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\qf\source\qa_lifo.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  QActive_postLIFO_ PROC
;;;72     */
;;;73     void QActive_postLIFO_(QActive * const me, QEvt const * const e) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;74         QEvt const *frontEvt;  /* temporary to avoid UB for volatile access */
;;;75         QEQueueCtr nFree;      /* temporary to avoid UB for volatile access */
;;;76         QF_CRIT_STAT_
;;;77     
;;;78         QF_CRIT_ENTRY_();
00000c  ef0000fe          SVC      #0xfe
;;;79         nFree = me->eQueue.nFree; /* get volatile into the temporary */
000010  e5946020          LDR      r6,[r4,#0x20]
;;;80     
;;;81         /* the queue must be able to accept the event (cannot overflow) */
;;;82         Q_ASSERT_ID(110, nFree != (QEQueueCtr)0);
000014  e3560000          CMP      r6,#0
000018  0a000000          BEQ      |L1.32|
00001c  ea000002          B        |L1.44|
                  |L1.32|
000020  e3a0106e          MOV      r1,#0x6e
000024  e59f00a0          LDR      r0,|L1.204|
000028  ebfffffe          BL       Q_onAssert
                  |L1.44|
;;;83     
;;;84         QS_BEGIN_NOCRIT_(QS_QF_ACTIVE_POST_LIFO, QS_priv_.aoObjFilter, me)
;;;85             QS_TIME_();                  /* timestamp */
;;;86             QS_SIG_(e->sig);             /* the signal of this event */
;;;87             QS_OBJ_(me);                 /* this active object */
;;;88             QS_2U8_(e->poolId_, e->refCtr_);/* pool Id & ref Count of the event */
;;;89             QS_EQC_(nFree);              /* number of free entries */
;;;90             QS_EQC_(me->eQueue.nMin);    /* min number of free entries */
;;;91         QS_END_NOCRIT_()
;;;92     
;;;93         /* is it a pool event? */
;;;94         if (e->poolId_ != (uint8_t)0) {
00002c  e5d50002          LDRB     r0,[r5,#2]
000030  e3500000          CMP      r0,#0
000034  0a000002          BEQ      |L1.68|
;;;95             QF_EVT_REF_CTR_INC_(e);      /* increment the reference counter */
000038  e5d50003          LDRB     r0,[r5,#3]
00003c  e2800001          ADD      r0,r0,#1
000040  e5c50003          STRB     r0,[r5,#3]
                  |L1.68|
;;;96         }
;;;97     
;;;98         --nFree; /* one free entry just used up */
000044  e2466001          SUB      r6,r6,#1
;;;99         me->eQueue.nFree = nFree; /* update the volatile */
000048  e5846020          STR      r6,[r4,#0x20]
;;;100        if (me->eQueue.nMin > nFree) {
00004c  e5940024          LDR      r0,[r4,#0x24]
000050  e1500006          CMP      r0,r6
000054  9a000000          BLS      |L1.92|
;;;101            me->eQueue.nMin = nFree; /* update minimum so far */
000058  e5846024          STR      r6,[r4,#0x24]
                  |L1.92|
;;;102        }
;;;103    
;;;104        frontEvt = me->eQueue.frontEvt; /* read volatile into the temporary */
00005c  e594700c          LDR      r7,[r4,#0xc]
;;;105        me->eQueue.frontEvt = e; /* deliver the event directly to the front */
000060  e584500c          STR      r5,[r4,#0xc]
;;;106    
;;;107        /* was the queue empty? */
;;;108        if (frontEvt == (QEvt const *)0) {
000064  e3570000          CMP      r7,#0
000068  1a000008          BNE      |L1.144|
;;;109            QACTIVE_EQUEUE_SIGNAL_(me); /* signal the event queue */
00006c  e59f005c          LDR      r0,|L1.208|
000070  e5900000          LDR      r0,[r0,#0]  ; QF_readySet_
000074  e59f2058          LDR      r2,|L1.212|
000078  e5941028          LDR      r1,[r4,#0x28]
00007c  e7d21001          LDRB     r1,[r2,r1]
000080  e1800001          ORR      r0,r0,r1
000084  e59f1044          LDR      r1,|L1.208|
000088  e5810000          STR      r0,[r1,#0]  ; QF_readySet_
00008c  ea00000b          B        |L1.192|
                  |L1.144|
;;;110        }
;;;111        /* queue was not empty, leave the event in the ring-buffer */
;;;112        else {
;;;113            ++me->eQueue.tail;
000090  e594001c          LDR      r0,[r4,#0x1c]
000094  e2800001          ADD      r0,r0,#1
000098  e584001c          STR      r0,[r4,#0x1c]
;;;114            /* need to wrap the tail? */
;;;115            if (me->eQueue.tail == me->eQueue.end) {
00009c  e594001c          LDR      r0,[r4,#0x1c]
0000a0  e5941014          LDR      r1,[r4,#0x14]
0000a4  e1500001          CMP      r0,r1
0000a8  1a000001          BNE      |L1.180|
;;;116                me->eQueue.tail = (QEQueueCtr)0; /* wrap around */
0000ac  e3a00000          MOV      r0,#0
0000b0  e584001c          STR      r0,[r4,#0x1c]
                  |L1.180|
;;;117            }
;;;118    
;;;119            QF_PTR_AT_(me->eQueue.ring, me->eQueue.tail) = frontEvt;
0000b4  e5940010          LDR      r0,[r4,#0x10]
0000b8  e594101c          LDR      r1,[r4,#0x1c]
0000bc  e7807101          STR      r7,[r0,r1,LSL #2]
                  |L1.192|
;;;120        }
;;;121        QF_CRIT_EXIT_();
0000c0  ef0000ff          SVC      #0xff
;;;122    }
0000c4  e8bd41f0          POP      {r4-r8,lr}
0000c8  e12fff1e          BX       lr
;;;123    
                          ENDP

                  |L1.204|
                          DCD      Q_this_module_
                  |L1.208|
                          DCD      QF_readySet_
                  |L1.212|
                          DCD      QF_pwr2Lkup

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  Q_this_module_
000000  71615f6c          DCB      0x71,0x61,0x5f,0x6c
000004  69666f00          DCB      0x69,0x66,0x6f,0x00
