; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\qvanilla.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\qvanilla.d --apcs=interwork -O0 --diag_suppress=9931 -I.\bombqmbsp -I..\..\..\..\..\..\..\CPU_Platforms\ARM\ARM7\MCB2300\include -I..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\ports\arm7\Keil -I..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\include -I.\src -I.\src\coffee -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\Philips -D__MICROLIB -DQM_TICK -DQM_ActiveObject --omf_browse=.\obj\qvanilla.crf ..\..\..\..\..\..\..\Framewworks\Quantum\qpc_5.3.1\qpc\qf\source\qvanilla.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  QF_init PROC
;;;77     */
;;;78     void QF_init(void) {
000000  e92d4010          PUSH     {r4,lr}
;;;79         /* clear the internal QF variables, so that the framework can start
;;;80         * correctly even if the startup code fails to clear the uninitialized
;;;81         * data (as is required by the C Standard).
;;;82         */
;;;83         QF_maxPool_ = (uint_fast8_t)0;
000004  e3a00000          MOV      r0,#0
000008  e59f1158          LDR      r1,|L1.360|
00000c  e5810000          STR      r0,[r1,#0]  ; QF_maxPool_
;;;84         QF_bzero(&QF_readySet_,       (uint_fast16_t)sizeof(QF_readySet_));
000010  e3a01004          MOV      r1,#4
000014  e59f0150          LDR      r0,|L1.364|
000018  ebfffffe          BL       QF_bzero
;;;85         QF_bzero(&QF_timeEvtHead_[0], (uint_fast16_t)sizeof(QF_timeEvtHead_));
00001c  e3a01020          MOV      r1,#0x20
000020  e59f0148          LDR      r0,|L1.368|
000024  ebfffffe          BL       QF_bzero
;;;86         QF_bzero(&QF_active_[0],      (uint_fast16_t)sizeof(QF_active_));
000028  e3a01024          MOV      r1,#0x24
00002c  e59f0140          LDR      r0,|L1.372|
000030  ebfffffe          BL       QF_bzero
;;;87     }
000034  e8bd4010          POP      {r4,lr}
000038  e12fff1e          BX       lr
;;;88     
                          ENDP

                  QF_stop PROC
;;;100    */
;;;101    void QF_stop(void) {
00003c  e92d4010          PUSH     {r4,lr}
;;;102        QF_onCleanup(); /* application-specific cleanup callback */
000040  ebfffffe          BL       QF_onCleanup
;;;103        /* nothing else to do for the "vanilla" kernel */
;;;104    }
000044  e8bd4010          POP      {r4,lr}
000048  e12fff1e          BX       lr
;;;105    
                          ENDP

                  QF_run PROC
;;;121    */
;;;122    int_t QF_run(void) {
00004c  ebfffffe          BL       QF_onStartup
;;;123    
;;;124        QF_onStartup(); /* application-specific startup callback */
;;;125    
;;;126        /* the combined event-loop and background-loop of the "Vanilla" kernel */
;;;127        for (;;) {
000050  e1a00000          MOV      r0,r0
                  |L1.84|
;;;128            QEvt const *e;
;;;129            QActive *a;
;;;130            uint_fast8_t p;
;;;131    
;;;132            QF_INT_DISABLE();
000054  e10f0000          MRS      r0,APSR ; formerly CPSR
000058  e3800080          ORR      r0,r0,#0x80
00005c  e121f000          MSR      CPSR_c,r0
;;;133    
;;;134            /* find the maximum priority AO ready to run */
;;;135    #if (QF_MAX_ACTIVE <= 8)
;;;136            if (QPSet8_notEmpty(&QF_readySet_)) {
000060  e59f0104          LDR      r0,|L1.364|
000064  e5900000          LDR      r0,[r0,#0]  ; QF_readySet_
000068  e3500000          CMP      r0,#0
00006c  0a000014          BEQ      |L1.196|
;;;137                QPSet8_findMax(&QF_readySet_, p);
000070  e59f00f4          LDR      r0,|L1.364|
000074  e5900000          LDR      r0,[r0,#0]  ; QF_readySet_
000078  e59f10f8          LDR      r1,|L1.376|
00007c  e7d15000          LDRB     r5,[r1,r0]
;;;138    #else
;;;139            if (QPSet64_notEmpty(&QF_readySet_)) {
;;;140                QPSet64_findMax(&QF_readySet_, p);
;;;141    #endif
;;;142                a = QF_active_[p];
000080  e59f00ec          LDR      r0,|L1.372|
000084  e7904105          LDR      r4,[r0,r5,LSL #2]
;;;143                QF_INT_ENABLE();
000088  e10f0000          MRS      r0,APSR ; formerly CPSR
00008c  e3c00080          BIC      r0,r0,#0x80
000090  e121f000          MSR      CPSR_c,r0
;;;144    
;;;145                /* perform the run-to-completion (RTS) step...
;;;146                * 1. retrieve the event from the AO's event queue, which by this
;;;147                *    time must be non-empty and The "Vanialla" kernel asserts it.
;;;148                * 2. dispatch the event to the AO's state machine.
;;;149                * 3. determine if event is garbage and collect it if so
;;;150                */
;;;151                e = QActive_get_(a);
000094  e1a00004          MOV      r0,r4
000098  ebfffffe          BL       QActive_get_
00009c  e1a06000          MOV      r6,r0
;;;152                QMSM_DISPATCH(&a->super, e);
0000a0  e5940000          LDR      r0,[r4,#0]
0000a4  e1a01006          MOV      r1,r6
0000a8  e5902004          LDR      r2,[r0,#4]
0000ac  e1a00004          MOV      r0,r4
0000b0  e1a0e00f          MOV      lr,pc
0000b4  e12fff12          BX       r2
;;;153                QF_gc(e);
0000b8  e1a00006          MOV      r0,r6
0000bc  ebfffffe          BL       QF_gc
0000c0  ea000000          B        |L1.200|
                  |L1.196|
;;;154            }
;;;155            else {
;;;156                /* QF_onIdle() must be called with interrupts DISABLED because
;;;157                * the determination of the idle condition (no events in the
;;;158                * queues) can change at any time by an interrupt posting events
;;;159                * to a queue. QF_onIdle() MUST enable interrupts internally,
;;;160                * perhaps at the same time as putting the CPU into a power-saving
;;;161                * mode.
;;;162                */
;;;163                QF_onIdle();
0000c4  ebfffffe          BL       QF_onIdle
                  |L1.200|
;;;164            }
;;;165        }
0000c8  eaffffe1          B        |L1.84|
;;;166    #ifdef __GNUC__  /* GNU compiler? */
;;;167        return (int_t)0;
;;;168    #endif
;;;169    }
;;;170    
                          ENDP

                  QActive_start_ PROC
;;;193    */
;;;194    void QActive_start_(QActive * const me, uint_fast8_t prio,
0000cc  e92d47f0          PUSH     {r4-r10,lr}
;;;195                        QEvt const *qSto[], uint_fast16_t qLen,
;;;196                        void *stkSto, uint_fast16_t stkSize,
;;;197                        QEvt const *ie)
;;;198    {
0000d0  e1a04000          MOV      r4,r0
0000d4  e1a05001          MOV      r5,r1
0000d8  e1a06002          MOV      r6,r2
0000dc  e1a07003          MOV      r7,r3
0000e0  e28da020          ADD      r10,sp,#0x20
0000e4  e89a0500          LDM      r10,{r8,r10}
0000e8  e59d9028          LDR      r9,[sp,#0x28]
;;;199        /** \pre the priority must be in range and the stack storage must not
;;;200        * be provided, because "Vanilla" kernel does not need per-AO stacks.
;;;201        */
;;;202        Q_REQUIRE_ID(400, ((uint_fast8_t)0 < prio)
0000ec  e3550000          CMP      r5,#0
0000f0  9a000004          BLS      |L1.264|
0000f4  e3550008          CMP      r5,#8
0000f8  8a000002          BHI      |L1.264|
0000fc  e3580000          CMP      r8,#0
000100  1a000000          BNE      |L1.264|
000104  ea000002          B        |L1.276|
                  |L1.264|
000108  e3a01e19          MOV      r1,#0x190
00010c  e59f0068          LDR      r0,|L1.380|
000110  ebfffffe          BL       Q_onAssert
                  |L1.276|
;;;203                    && (prio <= (uint_fast8_t)QF_MAX_ACTIVE)
;;;204                  && (stkSto == (void *)0));
;;;205    
;;;206        (void)stkSize; /* avoid the "unused parameter" compiler warning */
;;;207    
;;;208        QEQueue_init(&me->eQueue, qSto, qLen);
000114  e1a02007          MOV      r2,r7
000118  e1a01006          MOV      r1,r6
00011c  e284000c          ADD      r0,r4,#0xc
000120  ebfffffe          BL       QEQueue_init
;;;209        me->prio = prio; /* set QF priority of this AO before adding it to QF */
000124  e5845028          STR      r5,[r4,#0x28]
;;;210        QF_add_(me);     /* make QF aware of this active object */
000128  e1a00004          MOV      r0,r4
00012c  ebfffffe          BL       QF_add_
;;;211        QMSM_INIT(&me->super, ie); /* execute top-most initial transition */
000130  e5940000          LDR      r0,[r4,#0]
000134  e1a01009          MOV      r1,r9
000138  e5902000          LDR      r2,[r0,#0]
00013c  e1a00004          MOV      r0,r4
000140  e1a0e00f          MOV      lr,pc
000144  e12fff12          BX       r2
;;;212    
;;;213        QS_FLUSH(); /* flush the QS trace buffer to the host */
;;;214    }
000148  e8bd47f0          POP      {r4-r10,lr}
00014c  e12fff1e          BX       lr
;;;215    
                          ENDP

                  QActive_stop PROC
;;;227    */
;;;228    void QActive_stop(QActive * const me) {
000150  e92d4010          PUSH     {r4,lr}
000154  e1a04000          MOV      r4,r0
;;;229        QF_remove_(me);  /* remove the AO from the framework */
000158  e1a00004          MOV      r0,r4
00015c  ebfffffe          BL       QF_remove_
;;;230    }
000160  e8bd4010          POP      {r4,lr}
000164  e12fff1e          BX       lr
                          ENDP

                  |L1.360|
                          DCD      QF_maxPool_
                  |L1.364|
                          DCD      QF_readySet_
                  |L1.368|
                          DCD      QF_timeEvtHead_
                  |L1.372|
                          DCD      QF_active_
                  |L1.376|
                          DCD      QF_log2Lkup
                  |L1.380|
                          DCD      Q_this_module_

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  Q_this_module_
000000  7176616e          DCB      0x71,0x76,0x61,0x6e
000004  696c6c61          DCB      0x69,0x6c,0x6c,0x61
000008  00                DCB      0x00

                          AREA ||.data||, DATA, ALIGN=2

                  QF_readySet_
                          DCD      0x00000000
